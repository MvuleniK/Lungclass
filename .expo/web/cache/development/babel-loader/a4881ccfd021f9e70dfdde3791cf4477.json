{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport var MeanProgram = _createClass(function MeanProgram(reduceInfo, divisor) {\n  _classCallCheck(this, MeanProgram);\n\n  this.variableNames = ['x'];\n  var windowSize = reduceInfo.windowSize,\n      batchSize = reduceInfo.batchSize,\n      inSize = reduceInfo.inSize,\n      outSize = reduceInfo.outSize;\n  this.outputShape = [batchSize, outSize];\n  var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n  var windowSizeVec4Remainder = windowSize % 4;\n  var updateSnippet = \"sumValue += dot(values, ones);\";\n\n  if (divisor != null) {\n    var denominator = 1 / divisor;\n    updateSnippet = \"sumValue += dot(values * \" + (util.isInt(denominator) ? denominator.toPrecision(2) : denominator) + \", ones);\";\n  }\n\n  var checkOutOfBounds = '';\n\n  if (inSize % windowSize > 0) {\n    checkOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \" + inSize + \") {\\n          return 0.0;\\n        }\\n      \";\n  }\n\n  this.userCode = \"\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + checkOutOfBounds + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + windowSize + \";\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \" + windowSizeNearestVec4 + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          \" + updateSnippet + \"\\n        }\\n\\n        int inIdx = inOffset + \" + windowSizeNearestVec4 + \";\\n        if (\" + (windowSizeVec4Remainder === 1) + \") {\\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\\n\\n          \" + updateSnippet + \"\\n        } else if (\" + (windowSizeVec4Remainder === 2) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1), 0.0, 0.0);\\n\\n          \" + updateSnippet + \"\\n        } else if (\" + (windowSizeVec4Remainder === 3) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2), 0.0);\\n\\n          \" + updateSnippet + \"\\n        }\\n        setOutput(sumValue);\\n      }\\n    \";\n});","map":{"version":3,"sources":["../src/mean_gpu.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAsB,IAAtB,QAAiC,uBAAjC;AAGA,WAAa,WAAb,gBAKE,qBAAY,UAAZ,EAAiD,OAAjD,EAAiE;EAAA;;EAJjE,KAAA,aAAA,GAAgB,CAAC,GAAD,CAAhB;EAKE,IAAO,UAAP,GAAiD,UAAjD,CAAO,UAAP;EAAA,IAAmB,SAAnB,GAAiD,UAAjD,CAAmB,SAAnB;EAAA,IAA8B,MAA9B,GAAiD,UAAjD,CAA8B,MAA9B;EAAA,IAAsC,OAAtC,GAAiD,UAAjD,CAAsC,OAAtC;EACA,KAAK,WAAL,GAAmB,CAAC,SAAD,EAAY,OAAZ,CAAnB;EAEA,IAAM,qBAAqB,GAAG,IAAI,CAAC,KAAL,CAAW,UAAU,GAAG,CAAxB,IAA6B,CAA3D;EACA,IAAM,uBAAuB,GAAG,UAAU,GAAG,CAA7C;EAEA,IAAI,aAAa,mCAAjB;;EACA,IAAI,OAAO,IAAI,IAAf,EAAqB;IACnB,IAAM,WAAW,GAAG,IAAI,OAAxB;IACA,aAAa,kCACT,IAAI,CAAC,KAAL,CAAW,WAAX,IAA0B,WAAW,CAAC,WAAZ,CAAwB,CAAxB,CAA1B,GAC0B,WAFjB,cAAb;EAGD;;EAED,IAAI,gBAAgB,GAAG,EAAvB;;EACA,IAAI,MAAM,GAAG,UAAT,GAAsB,CAA1B,EAA6B;IAC3B,gBAAgB,4CACc,MADd,kDAAhB;EAKD;;EAED,KAAK,QAAL,qHAIM,gBAJN,0NAY8B,UAZ9B,0EAgB0B,qBAhB1B,kRAyBQ,aAzBR,sDA4B6B,qBA5B7B,wBA6BU,uBAAuB,KAAK,CA7BtC,gGAgCQ,aAhCR,8BAiCiB,uBAAuB,KAAK,CAjC7C,kJAsCQ,aAtCR,8BAuCiB,uBAAuB,KAAK,CAvC7C,sLA6CQ,aA7CR;AAkDD,CA/EH","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport class MeanProgram {\n    constructor(reduceInfo, divisor) {\n        this.variableNames = ['x'];\n        const { windowSize, batchSize, inSize, outSize } = reduceInfo;\n        this.outputShape = [batchSize, outSize];\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        const windowSizeVec4Remainder = windowSize % 4;\n        let updateSnippet = `sumValue += dot(values, ones);`;\n        if (divisor != null) {\n            const denominator = 1 / divisor;\n            updateSnippet = `sumValue += dot(values * ${util.isInt(denominator) ? denominator.toPrecision(2) :\n                denominator}, ones);`;\n        }\n        let checkOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return 0.0;\n        }\n      `;\n        }\n        this.userCode = `\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${updateSnippet}\n        }\n        setOutput(sumValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mean_gpu.js.map"]},"metadata":{},"sourceType":"module"}