{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from \"./engine\";\nimport { inferShape } from \"./tensor_util_env\";\nimport { arraysEqual, encodeString, flatten, isString, isTypedArray } from \"./util\";\nvar TEST_EPSILON_FLOAT32 = 1e-3;\nexport var TEST_EPSILON_FLOAT16 = 1e-1;\nexport function expectArraysClose(actual, expected, epsilon) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n\n  return expectArraysPredicate(actual, expected, function (a, b) {\n    return areClose(a, b, epsilon);\n  });\n}\nexport function testEpsilon() {\n  return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;\n}\n\nfunction expectArraysPredicate(actual, expected, predicate) {\n  var checkClassType = true;\n\n  if (isTypedArray(actual) || isTypedArray(expected)) {\n    checkClassType = false;\n  }\n\n  if (isTypedArray(actual) && isTypedArray(expected)) {\n    checkClassType = true;\n  }\n\n  if (checkClassType) {\n    var aType = actual.constructor.name;\n    var bType = expected.constructor.name;\n\n    if (aType !== bType) {\n      throw new Error(\"Arrays are of different type. Actual: \" + aType + \". \" + (\"Expected: \" + bType));\n    }\n  }\n\n  if (Array.isArray(actual) && Array.isArray(expected)) {\n    var actualShape = inferShape(actual);\n    var expectedShape = inferShape(expected);\n\n    if (!arraysEqual(actualShape, expectedShape)) {\n      throw new Error(\"Arrays have different shapes. \" + (\"Actual: [\" + actualShape + \"]. Expected: [\" + expectedShape + \"]\"));\n    }\n  }\n\n  var actualFlat = isTypedArray(actual) ? actual : flatten(actual);\n  var expectedFlat = isTypedArray(expected) ? expected : flatten(expected);\n\n  if (actualFlat.length !== expectedFlat.length) {\n    throw new Error(\"Arrays have different lengths actual: \" + actualFlat.length + \" vs \" + (\"expected: \" + expectedFlat.length + \".\\n\") + (\"Actual:   \" + actualFlat + \".\\n\") + (\"Expected: \" + expectedFlat + \".\"));\n  }\n\n  for (var i = 0; i < expectedFlat.length; ++i) {\n    var a = actualFlat[i];\n    var e = expectedFlat[i];\n\n    if (!predicate(a, e)) {\n      throw new Error(\"Arrays differ: actual[\" + i + \"] = \" + a + \", expected[\" + i + \"] = \" + e + \".\\n\" + (\"Actual:   \" + actualFlat + \".\\n\") + (\"Expected: \" + expectedFlat + \".\"));\n    }\n  }\n}\n\nexport function expectPromiseToFail(fn, done) {\n  fn().then(function () {\n    return done.fail();\n  }, function () {\n    return done();\n  });\n}\nexport function expectArraysEqual(actual, expected) {\n  var exp = typeof expected === 'string' || typeof expected === 'number' || typeof expected === 'boolean' ? [expected] : expected;\n\n  if (isString(actual) || isString(actual[0]) || isString(expected) || isString(expected[0])) {\n    return expectArraysPredicate(actual, exp, function (a, b) {\n      return a == b;\n    });\n  }\n\n  return expectArraysPredicate(actual, expected, function (a, b) {\n    return areClose(a, b, 0);\n  });\n}\nexport function expectNumbersClose(a, e, epsilon) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n\n  if (!areClose(a, e, epsilon)) {\n    throw new Error(\"Numbers differ: actual === \" + a + \", expected === \" + e);\n  }\n}\n\nfunction areClose(a, e, epsilon) {\n  if (!isFinite(a) && !isFinite(e)) {\n    return true;\n  }\n\n  if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function expectValuesInRange(actual, low, high) {\n  for (var i = 0; i < actual.length; i++) {\n    if (actual[i] < low || actual[i] > high) {\n      throw new Error(\"Value out of range:\" + actual[i] + \" low: \" + low + \", high: \" + high);\n    }\n  }\n}\nexport function expectArrayBuffersEqual(actual, expected) {\n  expect(new Float32Array(actual)).toEqual(new Float32Array(expected));\n}\nexport function encodeStrings(a) {\n  for (var i = 0; i < a.length; i++) {\n    var val = a[i];\n\n    if (Array.isArray(val)) {\n      encodeStrings(val);\n    } else {\n      a[i] = encodeString(val);\n    }\n  }\n\n  return a;\n}","map":{"version":3,"sources":["../src/test_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { inferShape } from './tensor_util_env';\nimport { arraysEqual, encodeString, flatten, isString, isTypedArray } from './util';\nconst TEST_EPSILON_FLOAT32 = 1e-3;\nexport const TEST_EPSILON_FLOAT16 = 1e-1;\nexport function expectArraysClose(actual, expected, epsilon) {\n    if (epsilon == null) {\n        epsilon = testEpsilon();\n    }\n    return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, epsilon));\n}\nexport function testEpsilon() {\n    return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 :\n        TEST_EPSILON_FLOAT16;\n}\nfunction expectArraysPredicate(actual, expected, predicate) {\n    let checkClassType = true;\n    if (isTypedArray(actual) || isTypedArray(expected)) {\n        checkClassType = false;\n    }\n    if (isTypedArray(actual) && isTypedArray(expected)) {\n        checkClassType = true;\n    }\n    if (checkClassType) {\n        const aType = actual.constructor.name;\n        const bType = expected.constructor.name;\n        if (aType !== bType) {\n            throw new Error(`Arrays are of different type. Actual: ${aType}. ` +\n                `Expected: ${bType}`);\n        }\n    }\n    if (Array.isArray(actual) && Array.isArray(expected)) {\n        const actualShape = inferShape(actual);\n        const expectedShape = inferShape(expected);\n        if (!arraysEqual(actualShape, expectedShape)) {\n            throw new Error(`Arrays have different shapes. ` +\n                `Actual: [${actualShape}]. Expected: [${expectedShape}]`);\n        }\n    }\n    const actualFlat = isTypedArray(actual) ? actual : flatten(actual);\n    const expectedFlat = isTypedArray(expected) ?\n        expected :\n        flatten(expected);\n    if (actualFlat.length !== expectedFlat.length) {\n        throw new Error(`Arrays have different lengths actual: ${actualFlat.length} vs ` +\n            `expected: ${expectedFlat.length}.\\n` +\n            `Actual:   ${actualFlat}.\\n` +\n            `Expected: ${expectedFlat}.`);\n    }\n    for (let i = 0; i < expectedFlat.length; ++i) {\n        const a = actualFlat[i];\n        const e = expectedFlat[i];\n        if (!predicate(a, e)) {\n            throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${e}.\\n` +\n                `Actual:   ${actualFlat}.\\n` +\n                `Expected: ${expectedFlat}.`);\n        }\n    }\n}\nexport function expectPromiseToFail(fn, done) {\n    fn().then(() => done.fail(), () => done());\n}\nexport function expectArraysEqual(actual, expected) {\n    const exp = typeof expected === 'string' || typeof expected === 'number' ||\n        typeof expected === 'boolean' ?\n        [expected] :\n        expected;\n    if (isString(actual) || isString(actual[0]) ||\n        isString(expected) || isString(expected[0])) {\n        // tslint:disable-next-line: triple-equals\n        return expectArraysPredicate(actual, exp, (a, b) => a == b);\n    }\n    return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, 0));\n}\nexport function expectNumbersClose(a, e, epsilon) {\n    if (epsilon == null) {\n        epsilon = testEpsilon();\n    }\n    if (!areClose(a, e, epsilon)) {\n        throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);\n    }\n}\nfunction areClose(a, e, epsilon) {\n    if (!isFinite(a) && !isFinite(e)) {\n        return true;\n    }\n    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {\n        return false;\n    }\n    return true;\n}\nexport function expectValuesInRange(actual, low, high) {\n    for (let i = 0; i < actual.length; i++) {\n        if (actual[i] < low || actual[i] > high) {\n            throw new Error(`Value out of range:${actual[i]} low: ${low}, high: ${high}`);\n        }\n    }\n}\nexport function expectArrayBuffersEqual(actual, expected) {\n    // Safari & Jasmine don't like comparing ArrayBuffers directly. Wrapping in\n    // a Float32Array solves this issue.\n    expect(new Float32Array(actual)).toEqual(new Float32Array(expected));\n}\n/** Encodes strings into utf-8 bytes. */\nexport function encodeStrings(a) {\n    for (let i = 0; i < a.length; i++) {\n        const val = a[i];\n        if (Array.isArray(val)) {\n            encodeStrings(val);\n        }\n        else {\n            a[i] = encodeString(val);\n        }\n    }\n    return a;\n}\n//# sourceMappingURL=test_util.js.map"]},"metadata":{},"sourceType":"module"}