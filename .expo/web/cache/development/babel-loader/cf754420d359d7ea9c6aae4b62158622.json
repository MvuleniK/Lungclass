{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinear, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from \"../cpu_util\";\nexport function resizeBilinear(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var images = inputs.images;\n  var alignCorners = attrs.alignCorners,\n      halfPixelCenters = attrs.halfPixelCenters,\n      size = attrs.size;\n  assertNotComplex(images, 'resizeBilinear');\n  var imagesStrides = util.computeStrides(images.shape);\n\n  var _size = _slicedToArray(size, 2),\n      newHeight = _size[0],\n      newWidth = _size[1];\n\n  var _images$shape = _slicedToArray(images.shape, 4),\n      batch = _images$shape[0],\n      oldHeight = _images$shape[1],\n      oldWidth = _images$shape[2],\n      numChannels = _images$shape[3];\n\n  var xValues = backend.data.get(images.dataId).values;\n  var result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n  var effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];\n  var effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];\n  var outputIdx = 0;\n  var effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n  var effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n\n  for (var b = 0; b < batch; b++) {\n    for (var r = 0; r < newHeight; r++) {\n      var sourceFracRow = void 0;\n\n      if (halfPixelCenters) {\n        sourceFracRow = effectiveRowSizeRatio * (r + 0.5) - 0.5;\n      } else {\n        sourceFracRow = effectiveRowSizeRatio * r;\n      }\n\n      var sourceRowFloor = Math.max(0, Math.floor(sourceFracRow));\n      var rowFrac = sourceFracRow - sourceRowFloor;\n      var sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n      var topRowOffset = b * imagesStrides[0] + sourceRowFloor * imagesStrides[1];\n      var botRowOffset = b * imagesStrides[0] + sourceRowCeil * imagesStrides[1];\n\n      for (var c = 0; c < newWidth; c++) {\n        var sourceFracCol = void 0;\n\n        if (halfPixelCenters) {\n          sourceFracCol = effectiveColSizeRatio * (c + 0.5) - 0.5;\n        } else {\n          sourceFracCol = effectiveColSizeRatio * c;\n        }\n\n        var sourceColFloor = Math.max(0, Math.floor(sourceFracCol));\n        var colFrac = sourceFracCol - sourceColFloor;\n        var sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n        var topLeftOffest = topRowOffset + sourceColFloor * imagesStrides[2];\n        var botLeftOffset = botRowOffset + sourceColFloor * imagesStrides[2];\n        var topRightOffset = topRowOffset + sourceColCeil * imagesStrides[2];\n        var botRightOffest = botRowOffset + sourceColCeil * imagesStrides[2];\n\n        for (var d = 0; d < numChannels; d++) {\n          var topLeft = xValues[topLeftOffest + d];\n          var bottomLeft = xValues[botLeftOffset + d];\n          var topRight = xValues[topRightOffset + d];\n          var bottomRight = xValues[botRightOffest + d];\n          var top = topLeft + (topRight - topLeft) * colFrac;\n          var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n          var newValue = top + (bottom - top) * rowFrac;\n          result[outputIdx++] = newValue;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], 'float32', result);\n}\nexport var resizeBilinearConfig = {\n  kernelName: ResizeBilinear,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinear\n};","map":{"version":3,"sources":["../../src/kernels/ResizeBilinear.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinear, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinear(args) {\n    const { inputs, backend, attrs } = args;\n    const { images } = inputs;\n    const { alignCorners, halfPixelCenters, size } = attrs;\n    assertNotComplex(images, 'resizeBilinear');\n    const imagesStrides = util.computeStrides(images.shape);\n    const [newHeight, newWidth] = size;\n    const [batch, oldHeight, oldWidth, numChannels] = images.shape;\n    const xValues = backend.data.get(images.dataId).values;\n    const result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n    const effectiveInputSize = [\n        (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n        (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n    const effectiveOutputSize = [\n        (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n        (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n    let outputIdx = 0;\n    const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n    const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n    for (let b = 0; b < batch; b++) {\n        for (let r = 0; r < newHeight; r++) {\n            let sourceFracRow;\n            if (halfPixelCenters) {\n                sourceFracRow = effectiveRowSizeRatio * (r + 0.5) - 0.5;\n            }\n            else {\n                sourceFracRow = effectiveRowSizeRatio * r;\n            }\n            const sourceRowFloor = Math.max(0, Math.floor(sourceFracRow));\n            const rowFrac = sourceFracRow - sourceRowFloor;\n            const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n            const topRowOffset = b * imagesStrides[0] + sourceRowFloor * imagesStrides[1];\n            const botRowOffset = b * imagesStrides[0] + sourceRowCeil * imagesStrides[1];\n            for (let c = 0; c < newWidth; c++) {\n                let sourceFracCol;\n                if (halfPixelCenters) {\n                    sourceFracCol = effectiveColSizeRatio * (c + 0.5) - 0.5;\n                }\n                else {\n                    sourceFracCol = effectiveColSizeRatio * c;\n                }\n                const sourceColFloor = Math.max(0, Math.floor(sourceFracCol));\n                const colFrac = sourceFracCol - sourceColFloor;\n                const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n                const topLeftOffest = topRowOffset + sourceColFloor * imagesStrides[2];\n                const botLeftOffset = botRowOffset + sourceColFloor * imagesStrides[2];\n                const topRightOffset = topRowOffset + sourceColCeil * imagesStrides[2];\n                const botRightOffest = botRowOffset + sourceColCeil * imagesStrides[2];\n                for (let d = 0; d < numChannels; d++) {\n                    // Begin shader.\n                    // Compute the fractional index of the source.\n                    const topLeft = xValues[topLeftOffest + d];\n                    const bottomLeft = xValues[botLeftOffset + d];\n                    const topRight = xValues[topRightOffset + d];\n                    const bottomRight = xValues[botRightOffest + d];\n                    const top = topLeft + (topRight - topLeft) * colFrac;\n                    const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n                    const newValue = top + (bottom - top) * rowFrac;\n                    result[outputIdx++] = newValue;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], 'float32', result);\n}\nexport const resizeBilinearConfig = {\n    kernelName: ResizeBilinear,\n    backendName: 'cpu',\n    kernelFunc: resizeBilinear\n};\n//# sourceMappingURL=ResizeBilinear.js.map"]},"metadata":{},"sourceType":"module"}