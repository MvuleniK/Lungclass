{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { OneHot, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from \"../cpu_util\";\nexport function oneHot(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var indices = inputs.indices;\n  var depth = attrs.depth,\n      onValue = attrs.onValue,\n      offValue = attrs.offValue;\n  assertNotComplex(indices, 'oneHot');\n  var indicesSize = util.sizeFromShape(indices.shape);\n  var res = new Float32Array(indicesSize * depth);\n  res.fill(offValue);\n  var indicesVal = backend.data.get(indices.dataId).values;\n\n  for (var event = 0; event < indicesSize; ++event) {\n    if (indicesVal[event] >= 0 && indicesVal[event] < depth) {\n      res[event * depth + indicesVal[event]] = onValue;\n    }\n  }\n\n  return backend.makeTensorInfo([].concat(_toConsumableArray(indices.shape), [depth]), 'int32', res);\n}\nexport var oneHotConfig = {\n  kernelName: OneHot,\n  backendName: 'cpu',\n  kernelFunc: oneHot\n};","map":{"version":3,"sources":["../../src/kernels/OneHot.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAkC,MAAlC,EAA6F,IAA7F,QAAwG,uBAAxG;AAGA,SAAQ,gBAAR;AAEA,OAAM,SAAU,MAAV,CACF,IADE,EACuE;EAE3E,IAAO,MAAP,GAAiC,IAAjC,CAAO,MAAP;EAAA,IAAe,OAAf,GAAiC,IAAjC,CAAe,OAAf;EAAA,IAAwB,KAAxB,GAAiC,IAAjC,CAAwB,KAAxB;EACA,IAAO,OAAP,GAAkB,MAAlB,CAAO,OAAP;EACA,IAAO,KAAP,GAAmC,KAAnC,CAAO,KAAP;EAAA,IAAc,OAAd,GAAmC,KAAnC,CAAc,OAAd;EAAA,IAAuB,QAAvB,GAAmC,KAAnC,CAAuB,QAAvB;EAEA,gBAAgB,CAAC,OAAD,EAAU,QAAV,CAAhB;EAEA,IAAM,WAAW,GAAG,IAAI,CAAC,aAAL,CAAmB,OAAO,CAAC,KAA3B,CAApB;EAEA,IAAM,GAAG,GAAG,IAAI,YAAJ,CAAiB,WAAW,GAAG,KAA/B,CAAZ;EACA,GAAG,CAAC,IAAJ,CAAS,QAAT;EACA,IAAM,UAAU,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,OAAO,CAAC,MAAzB,EAAiC,MAApD;;EAEA,KAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,WAA5B,EAAyC,EAAE,KAA3C,EAAkD;IAChD,IAAI,UAAU,CAAC,KAAD,CAAV,IAAqB,CAArB,IAA0B,UAAU,CAAC,KAAD,CAAV,GAAoB,KAAlD,EAAyD;MACvD,GAAG,CAAC,KAAK,GAAG,KAAR,GAAgB,UAAU,CAAC,KAAD,CAA3B,CAAH,GAAyC,OAAzC;IACD;EACF;;EAED,OAAO,OAAO,CAAC,cAAR,8BAA2B,OAAO,CAAC,KAAnC,IAA0C,KAA1C,IAAkD,OAAlD,EAA2D,GAA3D,CAAP;AACD;AAED,OAAO,IAAM,YAAY,GAAiB;EACxC,UAAU,EAAE,MAD4B;EAExC,WAAW,EAAE,KAF2B;EAGxC,UAAU,EAAE;AAH4B,CAAnC","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { OneHot, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function oneHot(args) {\n    const { inputs, backend, attrs } = args;\n    const { indices } = inputs;\n    const { depth, onValue, offValue } = attrs;\n    assertNotComplex(indices, 'oneHot');\n    const indicesSize = util.sizeFromShape(indices.shape);\n    const res = new Float32Array(indicesSize * depth);\n    res.fill(offValue);\n    const indicesVal = backend.data.get(indices.dataId).values;\n    for (let event = 0; event < indicesSize; ++event) {\n        if (indicesVal[event] >= 0 && indicesVal[event] < depth) {\n            res[event * depth + indicesVal[event]] = onValue;\n        }\n    }\n    return backend.makeTensorInfo([...indices.shape, depth], 'int32', res);\n}\nexport const oneHotConfig = {\n    kernelName: OneHot,\n    backendName: 'cpu',\n    kernelFunc: oneHot\n};\n//# sourceMappingURL=OneHot.js.map"]},"metadata":{},"sourceType":"module"}