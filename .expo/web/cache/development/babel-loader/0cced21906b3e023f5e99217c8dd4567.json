{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from \"./canvas_util\";\nimport { getTextureConfig } from \"./tex_util\";\nexport function callAndCheck(gl, func) {\n  var returnValue = func();\n\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n\n  return returnValue;\n}\n\nfunction checkWebGLError(gl) {\n  var error = gl.getError();\n\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n}\n\nvar MIN_FLOAT16 = 5.96e-8;\nvar MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {\n    return true;\n  }\n\n  return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n\n    default:\n      return \"Unknown error code \" + status;\n  }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n  return throwIfNull(gl, function () {\n    return gl.getExtension(extensionName);\n  }, 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n  var vertexShader = throwIfNull(gl, function () {\n    return gl.createShader(gl.VERTEX_SHADER);\n  }, 'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, function () {\n    return gl.shaderSource(vertexShader, vertexShaderSource);\n  });\n  callAndCheck(gl, function () {\n    return gl.compileShader(vertexShader);\n  });\n\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n\n  return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n  var fragmentShader = throwIfNull(gl, function () {\n    return gl.createShader(gl.FRAGMENT_SHADER);\n  }, 'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, function () {\n    return gl.shaderSource(fragmentShader, fragmentShaderSource);\n  });\n  callAndCheck(gl, function () {\n    return gl.compileShader(fragmentShader);\n  });\n\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n\n  return fragmentShader;\n}\nvar lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\n\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n  var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n\n  if (lineNumberRegexResult == null) {\n    console.log(\"Couldn't parse line number in error: \" + shaderInfoLog);\n    console.log(shaderSource);\n    return;\n  }\n\n  var lineNumber = +lineNumberRegexResult[1];\n  var shaderLines = shaderSource.split('\\n');\n  var pad = shaderLines.length.toString().length + 2;\n  var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {\n    return util.rightPad((lineNumber + 1).toString(), pad) + line;\n  });\n  var maxLineLength = 0;\n\n  for (var i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  var afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(\"%c \" + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\n\nexport function createProgram(gl) {\n  return throwIfNull(gl, function () {\n    return gl.createProgram();\n  }, 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n  callAndCheck(gl, function () {\n    return gl.linkProgram(program);\n  });\n\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\nexport function validateProgram(gl, program) {\n  callAndCheck(gl, function () {\n    return gl.validateProgram(program);\n  });\n\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\nexport function createStaticVertexBuffer(gl, data) {\n  var buffer = throwIfNull(gl, function () {\n    return gl.createBuffer();\n  }, 'Unable to create WebGLBuffer');\n  callAndCheck(gl, function () {\n    return gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  });\n  callAndCheck(gl, function () {\n    return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n  });\n  return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n  var buffer = throwIfNull(gl, function () {\n    return gl.createBuffer();\n  }, 'Unable to create WebGLBuffer');\n  callAndCheck(gl, function () {\n    return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n  });\n  callAndCheck(gl, function () {\n    return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);\n  });\n  return buffer;\n}\nexport function getNumChannels() {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n\n  return 4;\n}\nexport function createTexture(gl) {\n  return throwIfNull(gl, function () {\n    return gl.createTexture();\n  }, 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n  var maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n\n  if (width <= 0 || height <= 0) {\n    var requested = \"[\" + width + \"x\" + height + \"]\";\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n\n  if (width > maxTextureSize || height > maxTextureSize) {\n    var _requested = \"[\" + width + \"x\" + height + \"]\";\n\n    var max = \"[\" + maxTextureSize + \"x\" + maxTextureSize + \"]\";\n    throw new Error('Requested texture size ' + _requested + ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\nexport function createFramebuffer(gl) {\n  return throwIfNull(gl, function () {\n    return gl.createFramebuffer();\n  }, 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n  var loc = gl.getAttribLocation(program, attribute);\n\n  if (loc === -1) {\n    return false;\n  }\n\n  callAndCheck(gl, function () {\n    return gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  });\n  callAndCheck(gl, function () {\n    return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes);\n  });\n  callAndCheck(gl, function () {\n    return gl.enableVertexAttribArray(loc);\n  });\n  return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, function () {\n    return gl.activeTexture(gl.TEXTURE0 + textureUnit);\n  });\n  callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, texture);\n  });\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, function () {\n    return gl.activeTexture(gl.TEXTURE0 + textureUnit);\n  });\n  callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, null);\n  });\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n  return throwIfNull(gl, function () {\n    return gl.getUniformLocation(program, uniformName);\n  }, 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n  return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n  callAndCheck(gl, function () {\n    return bindTextureUnit(gl, texture, textureUnit);\n  });\n  callAndCheck(gl, function () {\n    return gl.uniform1i(uniformSamplerLocation, textureUnit);\n  });\n}\nexport function bindCanvasToFramebuffer(gl) {\n  callAndCheck(gl, function () {\n    return gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  });\n  callAndCheck(gl, function () {\n    return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n  });\n  callAndCheck(gl, function () {\n    return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);\n  });\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n  callAndCheck(gl, function () {\n    return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n  });\n  callAndCheck(gl, function () {\n    return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  });\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n  callAndCheck(gl, function () {\n    return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n  });\n  callAndCheck(gl, function () {\n    return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);\n  });\n}\nexport function validateFramebuffer(gl) {\n  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n\n    default:\n      return \"unknown error \" + status;\n  }\n}\n\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n  var tOrNull = callAndCheck(gl, function () {\n    return returnTOrNull();\n  });\n\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl, textureUnit) {\n  var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  var glTextureUnit = textureUnit + gl.TEXTURE0;\n\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    var textureUnitRange = \"[gl.TEXTURE0, gl.TEXTURE\" + maxTextureUnit + \"]\";\n    throw new Error(\"textureUnit must be in \" + textureUnitRange + \".\");\n  }\n}\n\nexport function getBatchDim(shape) {\n  var dimsToSkip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\nexport function getShapeAs3D(shape) {\n  var shapeAs3D = [1, 1, 1];\n  var isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;\n\n  if (!isScalar) {\n    shapeAs3D = [getBatchDim(shape)].concat(_toConsumableArray(getRowsCols(shape)));\n  }\n\n  return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape) {\n  var isPacked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n    logShape = logShape.map(function (d, i) {\n      return i >= logShape.length - 2 ? util.nearestLargerEven(logShape[i]) : logShape[i];\n    });\n\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  }\n\n  if (logShape.length !== 2) {\n    var squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  var size = util.sizeFromShape(logShape);\n\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    return [1, size];\n  } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {\n    return logShape;\n  } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {\n    return [logShape[0] * logShape[1], logShape[2]];\n  } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2]];\n  } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {\n    return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  } else {\n    if (isPacked) {\n      var batchDim = getBatchDim(logShape);\n      var rows = 2,\n          cols = 2;\n\n      if (logShape.length) {\n        var _getRowsCols = getRowsCols(logShape);\n\n        var _getRowsCols2 = _slicedToArray(_getRowsCols, 2);\n\n        rows = _getRowsCols2[0];\n        cols = _getRowsCols2[1];\n      }\n\n      size = batchDim * (rows / 2) * (cols / 2);\n      return util.sizeToSquarishShape(size).map(function (d) {\n        return d * 2;\n      });\n    }\n\n    return util.sizeToSquarishShape(size);\n  }\n}\n\nfunction isEven(n) {\n  return n % 2 === 0;\n}\n\nexport function isReshapeFree(shape1, shape2) {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {\n    var shape1Cols = shape1.slice(-1)[0];\n    var shape2Cols = shape2.slice(-1)[0];\n\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\nvar MAX_TEXTURE_SIZE;\nvar MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n  if (MAX_TEXTURE_SIZE == null) {\n    var gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n\n  return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    var gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  }\n\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  var queryTimerVersion;\n  var gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') && webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n\n  return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n  var ext = gl.getExtension(extensionName);\n  return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n  try {\n    var gl = getWebGLContext(webGLVersion);\n\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n\n  return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  var gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  var isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  var gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    var COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      var textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  var isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n  var texConfig = getTextureConfig(gl);\n  var texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  var width = 1;\n  var height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n  var frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  var isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension) {\n  var texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  var texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  var width = 1;\n  var height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n  var frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  var isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n\n  var gl = getWebGLContext(webGLVersion);\n  var isEnabled = gl.fenceSync != null;\n  return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n\n  tensor.forEach(function (t) {\n    if (t != null) {\n      util.assert(t.dtype !== 'complex64', function () {\n        return opName + \" does not support complex64 tensors \" + 'in the WebGL backend.';\n      });\n    }\n  });\n}","map":{"version":3,"sources":["../src/webgl_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n    const returnValue = func();\n    if (env().getBool('DEBUG')) {\n        checkWebGLError(gl);\n    }\n    return returnValue;\n}\nfunction checkWebGLError(gl) {\n    const error = gl.getError();\n    if (error !== gl.NO_ERROR) {\n        throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n    }\n}\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n        (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n        return true;\n    }\n    return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n    switch (status) {\n        case gl.NO_ERROR:\n            return 'NO_ERROR';\n        case gl.INVALID_ENUM:\n            return 'INVALID_ENUM';\n        case gl.INVALID_VALUE:\n            return 'INVALID_VALUE';\n        case gl.INVALID_OPERATION:\n            return 'INVALID_OPERATION';\n        case gl.INVALID_FRAMEBUFFER_OPERATION:\n            return 'INVALID_FRAMEBUFFER_OPERATION';\n        case gl.OUT_OF_MEMORY:\n            return 'OUT_OF_MEMORY';\n        case gl.CONTEXT_LOST_WEBGL:\n            return 'CONTEXT_LOST_WEBGL';\n        default:\n            return `Unknown error code ${status}`;\n    }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n    return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n    const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n    callAndCheck(gl, () => gl.compileShader(vertexShader));\n    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n        console.log(gl.getShaderInfoLog(vertexShader));\n        throw new Error('Failed to compile vertex shader.');\n    }\n    return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n    const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n    callAndCheck(gl, () => gl.compileShader(fragmentShader));\n    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n    }\n    return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n    const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n    if (lineNumberRegexResult == null) {\n        console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n        console.log(shaderSource);\n        return;\n    }\n    const lineNumber = +lineNumberRegexResult[1];\n    const shaderLines = shaderSource.split('\\n');\n    const pad = shaderLines.length.toString().length + 2;\n    const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n    let maxLineLength = 0;\n    for (let i = 0; i < linesWithLineNumbers.length; i++) {\n        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n    }\n    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n    const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n    const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n    console.log(beforeErrorLines.join('\\n'));\n    console.log(shaderInfoLog.split('\\n')[0]);\n    console.log(`%c ${util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n    console.log(afterErrorLines.join('\\n'));\n}\nexport function createProgram(gl) {\n    return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n    callAndCheck(gl, () => gl.linkProgram(program));\n    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Failed to link vertex and fragment shaders.');\n    }\n}\nexport function validateProgram(gl, program) {\n    callAndCheck(gl, () => gl.validateProgram(program));\n    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Shader program validation failed.');\n    }\n}\nexport function createStaticVertexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function getNumChannels() {\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        return 1;\n    }\n    return 4;\n}\nexport function createTexture(gl) {\n    return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n    const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if ((width <= 0) || (height <= 0)) {\n        const requested = `[${width}x${height}]`;\n        throw new Error('Requested texture size ' + requested + ' is invalid.');\n    }\n    if ((width > maxTextureSize) || (height > maxTextureSize)) {\n        const requested = `[${width}x${height}]`;\n        const max = `[${maxTextureSize}x${maxTextureSize}]`;\n        throw new Error('Requested texture size ' + requested +\n            ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n    }\n}\nexport function createFramebuffer(gl) {\n    return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n    const loc = gl.getAttribLocation(program, attribute);\n    if (loc === -1) {\n        // The GPU compiler decided to strip out this attribute because it's unused,\n        // thus no need to bind.\n        return false;\n    }\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n    callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n    return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n    return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n    return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n    callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n    callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n    callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n    }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n    switch (status) {\n        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n        case gl.FRAMEBUFFER_UNSUPPORTED:\n            return 'FRAMEBUFFER_UNSUPPORTED';\n        default:\n            return `unknown error ${status}`;\n    }\n}\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n    const tOrNull = callAndCheck(gl, () => returnTOrNull());\n    if (tOrNull == null) {\n        throw new Error(failureMessage);\n    }\n    return tOrNull;\n}\nfunction validateTextureUnit(gl, textureUnit) {\n    const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n    const glTextureUnit = textureUnit + gl.TEXTURE0;\n    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n        const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n        throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n    }\n}\nexport function getBatchDim(shape, dimsToSkip = 2) {\n    return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n    if (shape.length === 0) {\n        throw Error('Cannot get rows and columns of an empty shape array.');\n    }\n    return [\n        shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n    ];\n}\nexport function getShapeAs3D(shape) {\n    let shapeAs3D = [1, 1, 1];\n    const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n    if (!isScalar) {\n        shapeAs3D =\n            [getBatchDim(shape), ...getRowsCols(shape)];\n    }\n    return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape, isPacked = false) {\n    let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if (isPacked) {\n        maxTexSize = maxTexSize * 2;\n        // This logic ensures we accurately count the number of packed texels needed\n        // to accommodate the tensor. We can only pack values in the same texel if\n        // they are from adjacent pairs of rows/cols within the same batch. So if a\n        // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n        // fact that the texels containing the third row are half empty.\n        logShape = logShape.map((d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n        // Packed texture height is at least 2 (the channel height of a single\n        // texel).\n        if (logShape.length === 1) {\n            logShape = [2, logShape[0]];\n        }\n    }\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n        const squeezeResult = util.squeezeShape(logShape);\n        logShape = squeezeResult.newShape;\n    }\n    let size = util.sizeFromShape(logShape);\n    if (logShape.length <= 1 && size <= maxTexSize) {\n        return [1, size];\n    }\n    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&\n        logShape[1] <= maxTexSize) {\n        return logShape;\n    }\n    else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n        logShape[2] <= maxTexSize) {\n        return [logShape[0] * logShape[1], logShape[2]];\n    }\n    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2]];\n    }\n    else if (logShape.length === 4 &&\n        logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n        logShape[3] <= maxTexSize) {\n        return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    }\n    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    }\n    else {\n        if (isPacked) {\n            // For packed textures size equals the number of channels required to\n            // accommodate the texture data. However in order to squarify such that\n            // inner dimensions stay even, we rewrite size to equal the number of\n            // texels. Then in the return statement we rehydrate the squarified\n            // dimensions to channel units.\n            const batchDim = getBatchDim(logShape);\n            let rows = 2, cols = 2;\n            if (logShape.length) {\n                [rows, cols] = getRowsCols(logShape);\n            }\n            size = batchDim * (rows / 2) * (cols / 2);\n            return util.sizeToSquarishShape(size).map(d => d * 2);\n        }\n        return util.sizeToSquarishShape(size);\n    }\n}\nfunction isEven(n) {\n    return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1, shape2) {\n    shape1 = shape1.slice(-2);\n    shape2 = shape2.slice(-2);\n    if (util.arraysEqual(shape1, shape2)) {\n        return true;\n    }\n    if (!shape1.length || !shape2.length) { // One of the shapes is a scalar.\n        return true;\n    }\n    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n        shape2[1] === 0) {\n        return true;\n    }\n    if (shape1.length !== shape2.length) { // One of the shapes is a vector.\n        const shape1Cols = shape1.slice(-1)[0];\n        const shape2Cols = shape2.slice(-1)[0];\n        if (shape1Cols === shape2Cols) {\n            return true;\n        }\n        if (isEven(shape1Cols) && isEven(shape2Cols) &&\n            (shape1[0] === 1 || shape2[0] === 1)) {\n            return true;\n        }\n    }\n    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n    if (MAX_TEXTURE_SIZE == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    }\n    return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n    MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n    MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n    if (MAX_TEXTURES_IN_SHADER == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    }\n    // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n    return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    let queryTimerVersion;\n    const gl = getWebGLContext(webGLVersion);\n    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n        webGLVersion === 2) {\n        queryTimerVersion = 2;\n    }\n    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n        queryTimerVersion = 1;\n    }\n    else {\n        queryTimerVersion = 0;\n    }\n    return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n    const ext = gl.getExtension(extensionName);\n    return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n    try {\n        const gl = getWebGLContext(webGLVersion);\n        if (gl != null) {\n            return true;\n        }\n    }\n    catch (e) {\n        console.log('Error when getting WebGL context: ', e);\n        return false;\n    }\n    return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n    }\n    else {\n        if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n            return false;\n        }\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n        if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n            return false;\n        }\n    }\n    else {\n        if (hasExtension(gl, 'EXT_color_buffer_float')) {\n            return createFloatTextureAndBindToFramebuffer(gl);\n        }\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n            const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n        }\n        return false;\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n    const texConfig = getTextureConfig(gl);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nfunction createHalfFloatTextureAndBindToFramebuffer(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nexport function isWebGLFenceEnabled(webGLVersion) {\n    if (webGLVersion !== 2) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    // tslint:disable-next-line:no-any\n    const isEnabled = gl.fenceSync != null;\n    return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n    if (!Array.isArray(tensor)) {\n        tensor = [tensor];\n    }\n    tensor.forEach(t => {\n        if (t != null) {\n            util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` +\n                'in the WebGL backend.');\n        }\n    });\n}\n//# sourceMappingURL=webgl_util.js.map"]},"metadata":{},"sourceType":"module"}