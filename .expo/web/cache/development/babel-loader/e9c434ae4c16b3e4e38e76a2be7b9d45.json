{"ast":null,"code":"import { tensor3d, util } from '@tensorflow/tfjs-core';\nimport * as jpeg from 'jpeg-js';\nvar ImageType;\n\n(function (ImageType) {\n  ImageType[\"JPEG\"] = \"jpeg\";\n  ImageType[\"PNG\"] = \"png\";\n  ImageType[\"GIF\"] = \"gif\";\n  ImageType[\"BMP\"] = \"BMP\";\n})(ImageType || (ImageType = {}));\n\nexport function decodeJpeg(contents) {\n  var channels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  util.assert(getImageType(contents) === ImageType.JPEG, function () {\n    return 'The passed contents are not a valid JPEG image';\n  });\n  util.assert(channels === 3, function () {\n    return 'Only 3 channels is supported at this time';\n  });\n  var TO_UINT8ARRAY = true;\n\n  var _jpeg$decode = jpeg.decode(contents, TO_UINT8ARRAY),\n      width = _jpeg$decode.width,\n      height = _jpeg$decode.height,\n      data = _jpeg$decode.data;\n\n  var buffer = new Uint8Array(width * height * 3);\n  var offset = 0;\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    buffer[i] = data[offset];\n    buffer[i + 1] = data[offset + 1];\n    buffer[i + 2] = data[offset + 2];\n    offset += 4;\n  }\n\n  return tensor3d(buffer, [height, width, channels]);\n}\n\nfunction getImageType(content) {\n  if (content.length > 3 && content[0] === 255 && content[1] === 216 && content[2] === 255) {\n    return ImageType.JPEG;\n  } else if (content.length > 4 && content[0] === 71 && content[1] === 73 && content[2] === 70 && content[3] === 56) {\n    return ImageType.GIF;\n  } else if (content.length > 8 && content[0] === 137 && content[1] === 80 && content[2] === 78 && content[3] === 71 && content[4] === 13 && content[5] === 10 && content[6] === 26 && content[7] === 10) {\n    return ImageType.PNG;\n  } else if (content.length > 3 && content[0] === 66 && content[1] === 77) {\n    return ImageType.BMP;\n  } else {\n    throw new Error('Expected image (JPEG, PNG, or GIF), but got unsupported image type');\n  }\n}","map":{"version":3,"sources":["../src/decode_image.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { tensor3d, util } from '@tensorflow/tfjs-core';\nimport * as jpeg from 'jpeg-js';\nvar ImageType;\n(function (ImageType) {\n    ImageType[\"JPEG\"] = \"jpeg\";\n    ImageType[\"PNG\"] = \"png\";\n    ImageType[\"GIF\"] = \"gif\";\n    ImageType[\"BMP\"] = \"BMP\";\n})(ImageType || (ImageType = {}));\n/**\n * Decode a JPEG-encoded image to a 3D Tensor of dtype `int32`.\n *\n * ```js\n * // Load an image as a Uint8Array\n * const imageUri = 'http://image-uri-here.example.com/image.jpg'; *\n * const response = await fetch(imageUri, {}, { isBinary: true });\n * const imageDataArrayBuffer = await response.arrayBuffer();\n * cosnt imageData = new Uint8Array(imageDataArrayBuffer);\n *\n * // Decode image data to a tensor\n * const imageTensor = decodeJpeg(imageData);\n * ```\n *\n * @param contents The JPEG-encoded image in an Uint8Array.\n * @param channels An optional int. Defaults to 3. Accepted values are\n *     0: use the number of channels in the JPG-encoded image.\n *     1: output a grayscale image.\n *     3: output an RGB image.\n * @returns A 3D Tensor of dtype `int32` with shape [height, width, 1/3].\n *\n * @doc {heading: 'Media', subheading: 'Images'}\n */\nexport function decodeJpeg(contents, channels = 3) {\n    util.assert(getImageType(contents) === ImageType.JPEG, () => 'The passed contents are not a valid JPEG image');\n    util.assert(channels === 3, () => 'Only 3 channels is supported at this time');\n    const TO_UINT8ARRAY = true;\n    const { width, height, data } = jpeg.decode(contents, TO_UINT8ARRAY);\n    // Drop the alpha channel info because jpeg.decode always returns a typedArray\n    // with 255\n    const buffer = new Uint8Array(width * height * 3);\n    let offset = 0; // offset into original data\n    for (let i = 0; i < buffer.length; i += 3) {\n        buffer[i] = data[offset];\n        buffer[i + 1] = data[offset + 1];\n        buffer[i + 2] = data[offset + 2];\n        offset += 4;\n    }\n    return tensor3d(buffer, [height, width, channels]);\n}\n/**\n * Helper function to get image type based on starting bytes of the image file.\n */\nfunction getImageType(content) {\n    // Classify the contents of a file based on starting bytes (aka magic number:\n    // tslint:disable-next-line:max-line-length\n    // https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files)\n    // This aligns with TensorFlow Core code:\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/4213d5c1bd921f8d5b7b2dc4bbf1eea78d0b5258/tensorflow/core/kernels/decode_image_op.cc#L44\n    if (content.length > 3 && content[0] === 255 && content[1] === 216 &&\n        content[2] === 255) {\n        // JPEG byte chunk starts with `ff d8 ff`\n        return ImageType.JPEG;\n    }\n    else if (content.length > 4 && content[0] === 71 && content[1] === 73 &&\n        content[2] === 70 && content[3] === 56) {\n        // GIF byte chunk starts with `47 49 46 38`\n        return ImageType.GIF;\n    }\n    else if (content.length > 8 && content[0] === 137 && content[1] === 80 &&\n        content[2] === 78 && content[3] === 71 && content[4] === 13 &&\n        content[5] === 10 && content[6] === 26 && content[7] === 10) {\n        // PNG byte chunk starts with `\\211 P N G \\r \\n \\032 \\n (89 50 4E 47 0D 0A\n        // 1A 0A)`\n        return ImageType.PNG;\n    }\n    else if (content.length > 3 && content[0] === 66 && content[1] === 77) {\n        // BMP byte chunk starts with `42 4d`\n        return ImageType.BMP;\n    }\n    else {\n        throw new Error('Expected image (JPEG, PNG, or GIF), but got unsupported image type');\n    }\n}\n//# sourceMappingURL=decode_image.js.map"]},"metadata":{},"sourceType":"module"}