{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinearGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from \"../cpu_util\";\nexport function resizeBilinearGrad(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var images = inputs.images,\n      dy = inputs.dy;\n  var alignCorners = attrs.alignCorners;\n  assertNotComplex([dy, images], 'resizeBilinearGrad');\n  var imagesStrides = util.computeStrides(images.shape);\n\n  var _images$shape = _slicedToArray(images.shape, 4),\n      batch = _images$shape[0],\n      xHeight = _images$shape[1],\n      xWidth = _images$shape[2],\n      depth = _images$shape[3];\n\n  var _dy$shape = _slicedToArray(dy.shape, 3),\n      yHeight = _dy$shape[1],\n      yWidth = _dy$shape[2];\n\n  var output = new Float32Array(batch * xHeight * xWidth * depth);\n  var effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n  var effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n  var heightScale = effectiveXSize[0] / effectiveYSize[0];\n  var widthScale = effectiveXSize[1] / effectiveYSize[1];\n  var dyValues = backend.data.get(dy.dataId).values;\n  var offset = 0;\n\n  for (var b = 0; b < batch; b++) {\n    var bOffset = b * imagesStrides[0];\n\n    for (var r = 0; r < yHeight; r++) {\n      var dxR = r * heightScale;\n      var topDxRIndex = Math.floor(dxR);\n      var bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n      var topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n      var bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n      var dxRLerp = dxR - topDxRIndex;\n      var inverseDxRLerp = 1.0 - dxRLerp;\n\n      for (var c = 0; c < yWidth; c++) {\n        var dxC = c * widthScale;\n        var leftDxCIndex = Math.floor(dxC);\n        var rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n        var dxCLerp = dxC - leftDxCIndex;\n        var inverseDxCLerp = 1.0 - dxCLerp;\n        var topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n        var topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];\n        var bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];\n        var bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];\n        var inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n        var inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n        var dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n        var dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n\n        for (var d = 0; d < depth; d++) {\n          var dyVal = dyValues[offset++];\n          output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;\n          output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n          output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n          output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo([batch, xWidth, xHeight, depth], 'float32', output);\n}\nexport var resizeBilinearGradConfig = {\n  kernelName: ResizeBilinearGrad,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinearGrad\n};","map":{"version":3,"sources":["../../src/kernels/ResizeBilinearGrad.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinearGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinearGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { images, dy } = inputs;\n    const { alignCorners } = attrs;\n    assertNotComplex([dy, images], 'resizeBilinearGrad');\n    const imagesStrides = util.computeStrides(images.shape);\n    const [batch, xHeight, xWidth, depth] = images.shape;\n    const [, yHeight, yWidth] = dy.shape;\n    const output = new Float32Array(batch * xHeight * xWidth * depth);\n    // In the backwards pass, we want to find the pixels that were generated\n    // for each pixel in the input image the forward pass and add the\n    // corresponding coefficient from dy to the gradient (with some\n    // interpolation).\n    const effectiveXSize = [\n        (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n        (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n    const effectiveYSize = [\n        (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n        (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n    const dyValues = backend.data.get(dy.dataId).values;\n    let offset = 0;\n    for (let b = 0; b < batch; b++) {\n        const bOffset = b * imagesStrides[0];\n        for (let r = 0; r < yHeight; r++) {\n            const dxR = r * heightScale;\n            const topDxRIndex = Math.floor(dxR);\n            const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n            const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n            const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n            const dxRLerp = dxR - topDxRIndex;\n            const inverseDxRLerp = 1.0 - dxRLerp;\n            for (let c = 0; c < yWidth; c++) {\n                const dxC = c * widthScale;\n                const leftDxCIndex = Math.floor(dxC);\n                const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n                const dxCLerp = dxC - leftDxCIndex;\n                const inverseDxCLerp = 1.0 - dxCLerp;\n                const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n                const topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];\n                const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];\n                const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];\n                const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n                const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n                const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n                const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n                for (let d = 0; d < depth; d++) {\n                    const dyVal = dyValues[offset++];\n                    output[topLeftRCOffset + d] +=\n                        dyVal * inverseDxRLerpTimesInverseDxCLerp;\n                    output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n                    output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n                    output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batch, xWidth, xHeight, depth], 'float32', output);\n}\nexport const resizeBilinearGradConfig = {\n    kernelName: ResizeBilinearGrad,\n    backendName: 'cpu',\n    kernelFunc: resizeBilinearGrad\n};\n//# sourceMappingURL=ResizeBilinearGrad.js.map"]},"metadata":{},"sourceType":"module"}