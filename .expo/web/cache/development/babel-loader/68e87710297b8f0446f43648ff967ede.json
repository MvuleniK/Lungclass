{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from \"../util\";\nexport function assertParamsValid(input, begin, size) {\n  var inputRank = input.shape.length;\n  util.assert(inputRank === begin.length, function () {\n    return \"Error in slice\" + inputRank + \"D: Length of begin \" + begin + \" must \" + (\"match the rank of the array (\" + inputRank + \").\");\n  });\n  util.assert(inputRank === size.length, function () {\n    return \"Error in slice\" + inputRank + \"D: Length of size \" + size + \" must \" + (\"match the rank of the array (\" + inputRank + \").\");\n  });\n\n  var _loop = function _loop(i) {\n    util.assert(begin[i] + size[i] <= input.shape[i], function () {\n      return \"Error in slice\" + inputRank + \"D: begin[\" + i + \"] + size[\" + i + \"] \" + (\"(\" + (begin[i] + size[i]) + \") would overflow input.shape[\" + i + \"] (\" + input.shape[i] + \")\");\n    });\n  };\n\n  for (var i = 0; i < inputRank; ++i) {\n    _loop(i);\n  }\n}\nexport function maskToAxes(mask) {\n  var axes = [];\n  var axis = 0;\n\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n\n    mask /= 2;\n    axis++;\n  }\n\n  return axes;\n}\nexport function computeOutShape(begin, end, strides) {\n  var size = [];\n\n  for (var axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n\n  return size;\n}\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n  var newStrides = _toConsumableArray(strides);\n\n  for (var i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n\n  for (var _i = 0; _i < numElidedAxes; _i++) {\n    if (_i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(ellipsisInsertionIndex, 0, 1);\n      newStrides.pop();\n    }\n  }\n\n  return newStrides;\n}\n\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n  var elidedAxes = [];\n\n  for (var i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n\n  return elidedAxes;\n}\n\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n  var inputRank = inputShape.length;\n  var normalizedBegin = new Array(inputRank),\n      normalizedEnd = new Array(inputRank),\n      normalizedStrides = new Array(inputRank);\n\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    var fullIndex = ellipsisAxes[0];\n    var numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (var axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n}\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n  var newIndices = _toConsumableArray(inputShape);\n\n  var elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (var axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      var originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      var originalValue = originalBegin[originalAxis];\n\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  return newIndices;\n}\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n  var newIndices = _toConsumableArray(inputShape);\n\n  var elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (var axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      var originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      var originalValue = originalEnd[originalAxis];\n\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (var i = 0; i < newIndices.length; i++) {\n    var axisSize = inputShape[i];\n\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n\n  return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n  var stride = strides[axis];\n\n  if (ellipsisMask & 1 << axis || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n  var start = startIndices[axis];\n  var stride = strides[axis] || 1;\n\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  }\n\n  var axisSize = inputShape[axis];\n\n  if (start < 0) {\n    start += axisSize;\n  }\n\n  start = util.clamp(0, start, axisSize - 1);\n  return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n  var stop = stopIndices[axis];\n  var stride = strides[axis] || 1;\n\n  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {\n    if (stride > 0) {\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  }\n\n  var axisSize = inputShape[axis];\n\n  if (stop < 0) {\n    stop += axisSize;\n  }\n\n  if (stride > 0) {\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\nexport function isSliceContinous(shape, begin, size) {\n  var firstNonOneAxis = size.length;\n\n  for (var i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (var _i2 = firstNonOneAxis + 1; _i2 < size.length; _i2++) {\n    if (begin[_i2] > 0 || size[_i2] !== shape[_i2]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function computeFlatOffset(begin, strides) {\n  var flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n\n  for (var i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n\n  return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n  var begin_;\n  var xRank = x.shape.length;\n\n  if (typeof begin === 'number') {\n    begin_ = [begin].concat(_toConsumableArray(new Array(xRank - 1).fill(0)));\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n\n  begin_.forEach(function (d) {\n    util.assert(d !== -1, function () {\n      return 'slice() does not support negative begin indexing.';\n    });\n  });\n  var size_;\n\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size].concat(_toConsumableArray(new Array(xRank - 1).fill(-1)));\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n\n  size_ = size_.map(function (d, i) {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(d === -1, function () {\n        return \"Negative size values should be exactly -1 but got \" + (d + \" for the slice() size at index \" + i + \".\");\n      });\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n  var $begin = begin.slice();\n  var $end = end.slice();\n  var $strides = strides;\n\n  if (strides == null) {\n    $strides = new Array($begin.length);\n  }\n\n  var ellipsisAxes = maskToAxes(ellipsisMask);\n\n  if (ellipsisAxes.length > 1) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n\n  if (ellipsisMask !== 0 && newAxisMask !== 0) {\n    throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n  }\n\n  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n    throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n  }\n\n  var numInterpolatedAxes = xShape.length - $begin.length;\n  var expandAxes = maskToAxes(newAxisMask);\n  var newShape = xShape.slice();\n  expandAxes.forEach(function (axis) {\n    $begin[axis] = 0;\n    $end[axis] = 1;\n    newShape.splice(axis, 0, 1);\n  });\n\n  var _getNormalizedAxes = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask),\n      normalizedBegin = _getNormalizedAxes.begin,\n      normalizedEnd = _getNormalizedAxes.end,\n      normalizedStrides = _getNormalizedAxes.strides;\n\n  $begin = normalizedBegin;\n  $end = normalizedEnd;\n  $strides = normalizedStrides;\n  var shrinkAxes = maskToAxes(shrinkAxisMask);\n  shrinkAxes.forEach(function (axis) {\n    $end[axis] = $begin[axis] + 1;\n    $strides[axis] = 1;\n  });\n  var size = computeOutShape($begin, $end, $strides);\n  var outShape = size.filter(function (_, axis) {\n    return shrinkAxes.indexOf(axis) === -1;\n  });\n  var nonStrided = $strides.every(function (v) {\n    return v === 1;\n  });\n  return {\n    nonStrided: nonStrided,\n    $begin: $begin,\n    $end: $end,\n    $strides: $strides,\n    size: size,\n    newShape: newShape,\n    outShape: outShape\n  };\n}","map":{"version":3,"sources":["../../src/ops/slice_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n    const inputRank = input.shape.length;\n    util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n        `match the rank of the array (${inputRank}).`);\n    util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n        `match the rank of the array (${inputRank}).`);\n    for (let i = 0; i < inputRank; ++i) {\n        util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n    }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n    const axes = [];\n    let axis = 0;\n    while (mask > 0) {\n        if (mask & 1) {\n            axes.push(axis);\n        }\n        mask /= 2;\n        axis++;\n    }\n    return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n    const size = [];\n    for (let axis = 0; axis < begin.length; axis++) {\n        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n    }\n    return size;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n    const newStrides = [...strides];\n    for (let i = newStrides.length; i < inputShape.length; i++) {\n        newStrides.push(1);\n    }\n    for (let i = 0; i < numElidedAxes; i++) {\n        if (i === 0) {\n            newStrides[ellipsisInsertionIndex] = 1;\n        }\n        else {\n            newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);\n            newStrides.pop();\n        }\n    }\n    return newStrides;\n}\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n    if (normalizedAxis <= ellipsisInsertionIndex) {\n        return normalizedAxis;\n    }\n    return normalizedAxis - (numElidedAxes - 1);\n}\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n    const elidedAxes = [];\n    for (let i = 0; i < numElidedAxes; i++) {\n        elidedAxes.push(ellipsisInsertionIndex + i);\n    }\n    return elidedAxes;\n}\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n    const inputRank = inputShape.length;\n    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);\n    if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n        const fullIndex = ellipsisAxes[0];\n        // The ellipsis applies to the masked index as well as any dimensions\n        // that are interpolated.\n        const numElidedAxes = numInterpolatedAxes + 1;\n        normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n        normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n        normalizedStrides =\n            stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n    }\n    else {\n        for (let axis = 0; axis < inputRank; axis++) {\n            normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n            normalizedEnd[axis] =\n                stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n            normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n        }\n    }\n    return {\n        begin: normalizedBegin,\n        end: normalizedEnd,\n        strides: normalizedStrides\n    };\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = 0;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalBegin[originalAxis];\n            if (beginMask & 1 << originalAxis) {\n                originalValue = 0;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    return newIndices;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalEnd[originalAxis];\n            if (endMask & 1 << originalAxis) {\n                originalValue = Number.MAX_SAFE_INTEGER;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    for (let i = 0; i < newIndices.length; i++) {\n        // Handle negative indices\n        const axisSize = inputShape[i];\n        if (newIndices[i] < 0) {\n            newIndices[i] += axisSize;\n        }\n        newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n    }\n    return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n    let stride = strides[axis];\n    if (ellipsisMask & (1 << axis) || stride == null) {\n        stride = 1;\n    }\n    return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let start = startIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or the begin index is not set\n    // for the axis.\n    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n        if (stride > 0) {\n            // Forward iteration - use the first element. These values will get\n            // clamped below (Note: We could have set them to 0 and axis_size-1, but\n            // use lowest() and max() to maintain symmetry with StopForAxis())\n            start = Number.MIN_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the last element.\n            start = Number.MAX_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (start < 0) {\n        start += axisSize;\n    }\n    // Clamping\n    start = util.clamp(0, start, axisSize - 1);\n    return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let stop = stopIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or if the stop index is not\n    // set for this axis.\n    if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n        if (stride > 0) {\n            // Forward iteration - use the last element. These values will get\n            // clamped below\n            stop = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the first element.\n            stop = Number.MIN_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (stop < 0) {\n        stop += axisSize;\n    }\n    // Clamping\n    // Because the end index points one past the last element, we need slightly\n    // different clamping ranges depending on the direction.\n    if (stride > 0) {\n        // Forward iteration\n        stop = util.clamp(0, stop, axisSize);\n    }\n    else {\n        // Backward iteration\n        stop = util.clamp(-1, stop, axisSize - 1);\n    }\n    return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n    // Index of the first axis that has size > 1.\n    let firstNonOneAxis = size.length;\n    for (let i = 0; i < size.length; i++) {\n        if (size[i] > 1) {\n            firstNonOneAxis = i;\n            break;\n        }\n    }\n    for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n        if (begin[i] > 0 || size[i] !== shape[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function computeFlatOffset(begin, strides) {\n    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n    for (let i = 0; i < begin.length - 1; i++) {\n        flatOffset += begin[i] * strides[i];\n    }\n    return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n    // The following logic allows for more ergonomic calls.\n    let begin_;\n    const xRank = x.shape.length;\n    if (typeof begin === 'number') {\n        begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n    }\n    else if (begin.length < xRank) {\n        begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n    }\n    else {\n        begin_ = begin.slice();\n    }\n    begin_.forEach(d => {\n        util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n    });\n    let size_;\n    if (size == null) {\n        size_ = new Array(xRank).fill(-1);\n    }\n    else if (typeof size === 'number') {\n        size_ = [size, ...new Array(xRank - 1).fill(-1)];\n    }\n    else if (size.length < xRank) {\n        size_ = size.concat(new Array(xRank - size.length).fill(-1));\n    }\n    else {\n        size_ = size;\n    }\n    size_ = size_.map((d, i) => {\n        if (d >= 0) {\n            return d;\n        }\n        else {\n            util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` +\n                `${d} for the slice() size at index ${i}.`);\n            return x.shape[i] - begin_[i];\n        }\n    });\n    return [begin_, size_];\n}\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n    // make a copy because it may be modified further down.\n    let $begin = begin.slice();\n    let $end = end.slice();\n    let $strides = strides;\n    if (strides == null) {\n        $strides = new Array($begin.length);\n    }\n    const ellipsisAxes = maskToAxes(ellipsisMask);\n    if (ellipsisAxes.length > 1) {\n        throw new Error('Multiple ellipses in slice is not allowed.');\n    }\n    if (ellipsisMask !== 0 && newAxisMask !== 0) {\n        throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n    }\n    if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n        throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n    }\n    const numInterpolatedAxes = xShape.length - $begin.length;\n    // Expand the dims of x based on the newAxisMask.\n    const expandAxes = maskToAxes(newAxisMask);\n    const newShape = xShape.slice();\n    expandAxes.forEach(axis => {\n        $begin[axis] = 0;\n        $end[axis] = 1;\n        newShape.splice(axis, 0, 1);\n    });\n    const { begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides } = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask);\n    $begin = normalizedBegin;\n    $end = normalizedEnd;\n    $strides = normalizedStrides;\n    const shrinkAxes = maskToAxes(shrinkAxisMask);\n    // Adjust the ends based on the shrink mask.\n    shrinkAxes.forEach(axis => {\n        $end[axis] = $begin[axis] + 1;\n        $strides[axis] = 1;\n    });\n    // Figure out the output shape.\n    const size = computeOutShape($begin, $end, $strides);\n    // Remove the axes based on shrinkMask.\n    const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n    const nonStrided = $strides.every(v => v === 1);\n    return { nonStrided, $begin, $end, $strides, size, newShape, outShape };\n}\n//# sourceMappingURL=slice_util.js.map"]},"metadata":{},"sourceType":"module"}