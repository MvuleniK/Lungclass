{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { binaryInsert } from \"./non_max_suppression_util\";\nexport function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0);\n}\nexport function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {\n  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0, false, padToMaxOutputSize, true);\n}\nexport function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {\n  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true);\n}\n\nfunction nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {\n  var returnScoresTensor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var padToMaxOutputSize = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var returnValidOutputs = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n  var candidates = [];\n\n  for (var i = 0; i < scores.length; i++) {\n    if (scores[i] > scoreThreshold) {\n      candidates.push({\n        score: scores[i],\n        boxIndex: i,\n        suppressBeginIndex: 0\n      });\n    }\n  }\n\n  candidates.sort(ascendingComparator);\n  var scale = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0.0;\n  var selectedIndices = [];\n  var selectedScores = [];\n\n  while (selectedIndices.length < maxOutputSize && candidates.length > 0) {\n    var candidate = candidates.pop();\n    var originalScore = candidate.score,\n        boxIndex = candidate.boxIndex,\n        suppressBeginIndex = candidate.suppressBeginIndex;\n\n    if (originalScore < scoreThreshold) {\n      break;\n    }\n\n    var ignoreCandidate = false;\n\n    for (var j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {\n      var iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);\n\n      if (iou >= iouThreshold) {\n        ignoreCandidate = true;\n        break;\n      }\n\n      candidate.score = candidate.score * suppressWeight(iouThreshold, scale, iou);\n\n      if (candidate.score <= scoreThreshold) {\n        break;\n      }\n    }\n\n    candidate.suppressBeginIndex = selectedIndices.length;\n\n    if (!ignoreCandidate) {\n      if (candidate.score === originalScore) {\n        selectedIndices.push(boxIndex);\n        selectedScores.push(candidate.score);\n      } else if (candidate.score > scoreThreshold) {\n        binaryInsert(candidates, candidate, ascendingComparator);\n      }\n    }\n  }\n\n  var validOutputs = selectedIndices.length;\n  var elemsToPad = maxOutputSize - validOutputs;\n\n  if (padToMaxOutputSize && elemsToPad > 0) {\n    selectedIndices.push.apply(selectedIndices, _toConsumableArray(new Array(elemsToPad).fill(0)));\n    selectedScores.push.apply(selectedScores, _toConsumableArray(new Array(elemsToPad).fill(0.0)));\n  }\n\n  var result = {\n    selectedIndices: selectedIndices\n  };\n\n  if (returnScoresTensor) {\n    result['selectedScores'] = selectedScores;\n  }\n\n  if (returnValidOutputs) {\n    result['validOutputs'] = validOutputs;\n  }\n\n  return result;\n}\n\nfunction intersectionOverUnion(boxes, i, j) {\n  var iCoord = boxes.subarray(i * 4, i * 4 + 4);\n  var jCoord = boxes.subarray(j * 4, j * 4 + 4);\n  var yminI = Math.min(iCoord[0], iCoord[2]);\n  var xminI = Math.min(iCoord[1], iCoord[3]);\n  var ymaxI = Math.max(iCoord[0], iCoord[2]);\n  var xmaxI = Math.max(iCoord[1], iCoord[3]);\n  var yminJ = Math.min(jCoord[0], jCoord[2]);\n  var xminJ = Math.min(jCoord[1], jCoord[3]);\n  var ymaxJ = Math.max(jCoord[0], jCoord[2]);\n  var xmaxJ = Math.max(jCoord[1], jCoord[3]);\n  var areaI = (ymaxI - yminI) * (xmaxI - xminI);\n  var areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);\n\n  if (areaI <= 0 || areaJ <= 0) {\n    return 0.0;\n  }\n\n  var intersectionYmin = Math.max(yminI, yminJ);\n  var intersectionXmin = Math.max(xminI, xminJ);\n  var intersectionYmax = Math.min(ymaxI, ymaxJ);\n  var intersectionXmax = Math.min(xmaxI, xmaxJ);\n  var intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) * Math.max(intersectionXmax - intersectionXmin, 0.0);\n  return intersectionArea / (areaI + areaJ - intersectionArea);\n}\n\nfunction suppressWeight(iouThreshold, scale, iou) {\n  var weight = Math.exp(scale * iou * iou);\n  return iou <= iouThreshold ? weight : 0.0;\n}\n\nfunction ascendingComparator(c1, c2) {\n  return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;\n}","map":{"version":3,"sources":["../../src/backends/non_max_suppression_impl.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;AAeG;AAGH,SAAQ,YAAR;AAiBA,OAAM,SAAU,uBAAV,CACF,KADE,EACiB,MADjB,EACqC,aADrC,EAEF,YAFE,EAEoB,cAFpB,EAE0C;EAC9C,OAAO,sBAAsB,CACzB,KADyB,EAClB,MADkB,EACV,aADU,EACK,YADL,EACmB,cADnB,EAEzB,CAFyB,CAA7B;AAGD;AAED,OAAM,SAAU,uBAAV,CACF,KADE,EACiB,MADjB,EACqC,aADrC,EAEF,YAFE,EAEoB,cAFpB,EAGF,kBAHE,EAGyB;EAC7B,OAAO,sBAAsB,CACzB,KADyB,EAClB,MADkB,EACV,aADU,EACK,YADL,EACmB,cADnB,EAEzB,CAFyB,EAEH,KAFG,EAGzB,kBAHyB,EAGoB,IAHpB,CAA7B;AAKD;AAED,OAAM,SAAU,uBAAV,CACF,KADE,EACiB,MADjB,EACqC,aADrC,EAEF,YAFE,EAEoB,cAFpB,EAGF,YAHE,EAGkB;EACtB,OAAO,sBAAsB,CACzB,KADyB,EAClB,MADkB,EACV,aADU,EACK,YADL,EACmB,cADnB,EACmC,YADnC,EAEzB,IAFyB,CAA7B;AAGD;;AAED,SAAS,sBAAT,CACI,KADJ,EACuB,MADvB,EAC2C,aAD3C,EAEI,YAFJ,EAE0B,cAF1B,EAEkD,YAFlD,EAI8B;EAAA,IAD1B,kBAC0B,uEADL,KACK;EAAA,IADE,kBACF,uEADuB,KACvB;EAAA,IAA1B,kBAA0B,uEAAL,KAAK;EAG5B,IAAM,UAAU,GAAG,EAAnB;;EAEA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;IACtC,IAAI,MAAM,CAAC,CAAD,CAAN,GAAY,cAAhB,EAAgC;MAC9B,UAAU,CAAC,IAAX,CAAgB;QAAC,KAAK,EAAE,MAAM,CAAC,CAAD,CAAd;QAAmB,QAAQ,EAAE,CAA7B;QAAgC,kBAAkB,EAAE;MAApD,CAAhB;IACD;EACF;;EAED,UAAU,CAAC,IAAX,CAAgB,mBAAhB;EAIA,IAAM,KAAK,GAAG,YAAY,GAAG,CAAf,GAAoB,CAAC,GAAD,GAAO,YAA3B,GAA2C,GAAzD;EAEA,IAAM,eAAe,GAAa,EAAlC;EACA,IAAM,cAAc,GAAa,EAAjC;;EAEA,OAAO,eAAe,CAAC,MAAhB,GAAyB,aAAzB,IAA0C,UAAU,CAAC,MAAX,GAAoB,CAArE,EAAwE;IACtE,IAAM,SAAS,GAAG,UAAU,CAAC,GAAX,EAAlB;IACA,IAAc,aAAd,GAA6D,SAA7D,CAAO,KAAP;IAAA,IAA6B,QAA7B,GAA6D,SAA7D,CAA6B,QAA7B;IAAA,IAAuC,kBAAvC,GAA6D,SAA7D,CAAuC,kBAAvC;;IAEA,IAAI,aAAa,GAAG,cAApB,EAAoC;MAClC;IACD;;IAQD,IAAI,eAAe,GAAG,KAAtB;;IACA,KAAK,IAAI,CAAC,GAAG,eAAe,CAAC,MAAhB,GAAyB,CAAtC,EAAyC,CAAC,IAAI,kBAA9C,EAAkE,EAAE,CAApE,EAAuE;MACrE,IAAM,GAAG,GAAG,qBAAqB,CAAC,KAAD,EAAQ,QAAR,EAAkB,eAAe,CAAC,CAAD,CAAjC,CAAjC;;MAEA,IAAI,GAAG,IAAI,YAAX,EAAyB;QACvB,eAAe,GAAG,IAAlB;QACA;MACD;;MAED,SAAS,CAAC,KAAV,GACI,SAAS,CAAC,KAAV,GAAkB,cAAc,CAAC,YAAD,EAAe,KAAf,EAAsB,GAAtB,CADpC;;MAGA,IAAI,SAAS,CAAC,KAAV,IAAmB,cAAvB,EAAuC;QACrC;MACD;IACF;;IASD,SAAS,CAAC,kBAAV,GAA+B,eAAe,CAAC,MAA/C;;IAEA,IAAI,CAAC,eAAL,EAAsB;MAGpB,IAAI,SAAS,CAAC,KAAV,KAAoB,aAAxB,EAAuC;QACrC,eAAe,CAAC,IAAhB,CAAqB,QAArB;QACA,cAAc,CAAC,IAAf,CAAoB,SAAS,CAAC,KAA9B;MACD,CAHD,MAGO,IAAI,SAAS,CAAC,KAAV,GAAkB,cAAtB,EAAsC;QAG3C,YAAY,CAAC,UAAD,EAAa,SAAb,EAAwB,mBAAxB,CAAZ;MACD;IACF;EACF;;EAGD,IAAM,YAAY,GAAG,eAAe,CAAC,MAArC;EACA,IAAM,UAAU,GAAG,aAAa,GAAG,YAAnC;;EAEA,IAAI,kBAAkB,IAAI,UAAU,GAAG,CAAvC,EAA0C;IACxC,eAAe,CAAC,IAAhB,OAAA,eAAe,qBAAS,IAAI,KAAJ,CAAU,UAAV,EAAsB,IAAtB,CAA2B,CAA3B,CAAT,EAAf;IACA,cAAc,CAAC,IAAf,OAAA,cAAc,qBAAS,IAAI,KAAJ,CAAU,UAAV,EAAsB,IAAtB,CAA2B,GAA3B,CAAT,EAAd;EACD;;EAED,IAAM,MAAM,GAA4B;IAAC,eAAe,EAAf;EAAD,CAAxC;;EAEA,IAAI,kBAAJ,EAAwB;IACtB,MAAM,CAAC,gBAAD,CAAN,GAA2B,cAA3B;EACD;;EAED,IAAI,kBAAJ,EAAwB;IACtB,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAzB;EACD;;EAED,OAAO,MAAP;AACD;;AAED,SAAS,qBAAT,CAA+B,KAA/B,EAAkD,CAAlD,EAA6D,CAA7D,EAAsE;EACpE,IAAM,MAAM,GAAG,KAAK,CAAC,QAAN,CAAe,CAAC,GAAG,CAAnB,EAAsB,CAAC,GAAG,CAAJ,GAAQ,CAA9B,CAAf;EACA,IAAM,MAAM,GAAG,KAAK,CAAC,QAAN,CAAe,CAAC,GAAG,CAAnB,EAAsB,CAAC,GAAG,CAAJ,GAAQ,CAA9B,CAAf;EACA,IAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,CAAD,CAAf,EAAoB,MAAM,CAAC,CAAD,CAA1B,CAAd;EACA,IAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,CAAD,CAAf,EAAoB,MAAM,CAAC,CAAD,CAA1B,CAAd;EACA,IAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,CAAD,CAAf,EAAoB,MAAM,CAAC,CAAD,CAA1B,CAAd;EACA,IAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,CAAD,CAAf,EAAoB,MAAM,CAAC,CAAD,CAA1B,CAAd;EACA,IAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,CAAD,CAAf,EAAoB,MAAM,CAAC,CAAD,CAA1B,CAAd;EACA,IAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,CAAD,CAAf,EAAoB,MAAM,CAAC,CAAD,CAA1B,CAAd;EACA,IAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,CAAD,CAAf,EAAoB,MAAM,CAAC,CAAD,CAA1B,CAAd;EACA,IAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,CAAD,CAAf,EAAoB,MAAM,CAAC,CAAD,CAA1B,CAAd;EACA,IAAM,KAAK,GAAG,CAAC,KAAK,GAAG,KAAT,KAAmB,KAAK,GAAG,KAA3B,CAAd;EACA,IAAM,KAAK,GAAG,CAAC,KAAK,GAAG,KAAT,KAAmB,KAAK,GAAG,KAA3B,CAAd;;EACA,IAAI,KAAK,IAAI,CAAT,IAAc,KAAK,IAAI,CAA3B,EAA8B;IAC5B,OAAO,GAAP;EACD;;EACD,IAAM,gBAAgB,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,KAAhB,CAAzB;EACA,IAAM,gBAAgB,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,KAAhB,CAAzB;EACA,IAAM,gBAAgB,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,KAAhB,CAAzB;EACA,IAAM,gBAAgB,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,KAAhB,CAAzB;EACA,IAAM,gBAAgB,GAAG,IAAI,CAAC,GAAL,CAAS,gBAAgB,GAAG,gBAA5B,EAA8C,GAA9C,IACrB,IAAI,CAAC,GAAL,CAAS,gBAAgB,GAAG,gBAA5B,EAA8C,GAA9C,CADJ;EAEA,OAAO,gBAAgB,IAAI,KAAK,GAAG,KAAR,GAAgB,gBAApB,CAAvB;AACD;;AAMD,SAAS,cAAT,CAAwB,YAAxB,EAA8C,KAA9C,EAA6D,GAA7D,EAAwE;EACtE,IAAM,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,GAAG,GAAR,GAAc,GAAvB,CAAf;EACA,OAAO,GAAG,IAAI,YAAP,GAAsB,MAAtB,GAA+B,GAAtC;AACD;;AAED,SAAS,mBAAT,CAA6B,EAA7B,EAA4C,EAA5C,EAAyD;EAKvD,OAAQ,EAAE,CAAC,KAAH,GAAW,EAAE,CAAC,KAAf,IACD,EAAE,CAAC,KAAH,KAAa,EAAE,CAAC,KAAjB,IAA4B,EAAE,CAAC,QAAH,GAAc,EAAE,CAAC,QADlD;AAED","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { binaryInsert } from './non_max_suppression_util';\nexport function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0 /* softNmsSigma */);\n}\nexport function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0 /* softNmsSigma */, false /* returnScoresTensor */, padToMaxOutputSize /* padToMaxOutputSize */, true\n    /* returnValidOutputs */ );\n}\nexport function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true /* returnScoresTensor */);\n}\nfunction nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {\n    // The list is sorted in ascending order, so that we can always pop the\n    // candidate with the largest score in O(1) time.\n    const candidates = [];\n    for (let i = 0; i < scores.length; i++) {\n        if (scores[i] > scoreThreshold) {\n            candidates.push({ score: scores[i], boxIndex: i, suppressBeginIndex: 0 });\n        }\n    }\n    candidates.sort(ascendingComparator);\n    // If softNmsSigma is 0, the outcome of this algorithm is exactly same as\n    // before.\n    const scale = softNmsSigma > 0 ? (-0.5 / softNmsSigma) : 0.0;\n    const selectedIndices = [];\n    const selectedScores = [];\n    while (selectedIndices.length < maxOutputSize && candidates.length > 0) {\n        const candidate = candidates.pop();\n        const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;\n        if (originalScore < scoreThreshold) {\n            break;\n        }\n        // Overlapping boxes are likely to have similar scores, therefore we\n        // iterate through the previously selected boxes backwards in order to\n        // see if candidate's score should be suppressed. We use\n        // suppressBeginIndex to track and ensure a candidate can be suppressed\n        // by a selected box no more than once. Also, if the overlap exceeds\n        // iouThreshold, we simply ignore the candidate.\n        let ignoreCandidate = false;\n        for (let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {\n            const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);\n            if (iou >= iouThreshold) {\n                ignoreCandidate = true;\n                break;\n            }\n            candidate.score =\n                candidate.score * suppressWeight(iouThreshold, scale, iou);\n            if (candidate.score <= scoreThreshold) {\n                break;\n            }\n        }\n        // At this point, if `candidate.score` has not dropped below\n        // `scoreThreshold`, then we know that we went through all of the\n        // previous selections and can safely update `suppressBeginIndex` to the\n        // end of the selected array. Then we can re-insert the candidate with\n        // the updated score and suppressBeginIndex back in the candidate list.\n        // If on the other hand, `candidate.score` has dropped below the score\n        // threshold, we will not add it back to the candidates list.\n        candidate.suppressBeginIndex = selectedIndices.length;\n        if (!ignoreCandidate) {\n            // Candidate has passed all the tests, and is not suppressed, so\n            // select the candidate.\n            if (candidate.score === originalScore) {\n                selectedIndices.push(boxIndex);\n                selectedScores.push(candidate.score);\n            }\n            else if (candidate.score > scoreThreshold) {\n                // Candidate's score is suppressed but is still high enough to be\n                // considered, so add back to the candidates list.\n                binaryInsert(candidates, candidate, ascendingComparator);\n            }\n        }\n    }\n    // NonMaxSuppressionV4 feature: padding output to maxOutputSize.\n    const validOutputs = selectedIndices.length;\n    const elemsToPad = maxOutputSize - validOutputs;\n    if (padToMaxOutputSize && elemsToPad > 0) {\n        selectedIndices.push(...new Array(elemsToPad).fill(0));\n        selectedScores.push(...new Array(elemsToPad).fill(0.0));\n    }\n    const result = { selectedIndices };\n    if (returnScoresTensor) {\n        result['selectedScores'] = selectedScores;\n    }\n    if (returnValidOutputs) {\n        result['validOutputs'] = validOutputs;\n    }\n    return result;\n}\nfunction intersectionOverUnion(boxes, i, j) {\n    const iCoord = boxes.subarray(i * 4, i * 4 + 4);\n    const jCoord = boxes.subarray(j * 4, j * 4 + 4);\n    const yminI = Math.min(iCoord[0], iCoord[2]);\n    const xminI = Math.min(iCoord[1], iCoord[3]);\n    const ymaxI = Math.max(iCoord[0], iCoord[2]);\n    const xmaxI = Math.max(iCoord[1], iCoord[3]);\n    const yminJ = Math.min(jCoord[0], jCoord[2]);\n    const xminJ = Math.min(jCoord[1], jCoord[3]);\n    const ymaxJ = Math.max(jCoord[0], jCoord[2]);\n    const xmaxJ = Math.max(jCoord[1], jCoord[3]);\n    const areaI = (ymaxI - yminI) * (xmaxI - xminI);\n    const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);\n    if (areaI <= 0 || areaJ <= 0) {\n        return 0.0;\n    }\n    const intersectionYmin = Math.max(yminI, yminJ);\n    const intersectionXmin = Math.max(xminI, xminJ);\n    const intersectionYmax = Math.min(ymaxI, ymaxJ);\n    const intersectionXmax = Math.min(xmaxI, xmaxJ);\n    const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *\n        Math.max(intersectionXmax - intersectionXmin, 0.0);\n    return intersectionArea / (areaI + areaJ - intersectionArea);\n}\n// A Gaussian penalty function, this method always returns values in [0, 1].\n// The weight is a function of similarity, the more overlap two boxes are, the\n// smaller the weight is, meaning highly overlapping boxe will be significantly\n// penalized. On the other hand, a non-overlapping box will not be penalized.\nfunction suppressWeight(iouThreshold, scale, iou) {\n    const weight = Math.exp(scale * iou * iou);\n    return iou <= iouThreshold ? weight : 0.0;\n}\nfunction ascendingComparator(c1, c2) {\n    // For objects with same scores, we make the object with the larger index go\n    // first. In an array that pops from the end, this means that the object with\n    // the smaller index will be popped first. This ensures the same output as\n    // the TensorFlow python version.\n    return (c1.score - c2.score) ||\n        ((c1.score === c2.score) && (c2.boxIndex - c1.boxIndex));\n}\n//# sourceMappingURL=non_max_suppression_impl.js.map"]},"metadata":{},"sourceType":"module"}