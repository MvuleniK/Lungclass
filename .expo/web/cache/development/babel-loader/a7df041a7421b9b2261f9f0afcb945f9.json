{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from \"../engine\";\nimport { cast } from \"../ops/cast\";\nimport { scalar } from \"../ops/scalar\";\nimport { zeros } from \"../ops/zeros\";\nimport { decodeString, encodeString, hasEncodingLoss } from \"../util\";\nexport * from \"../ops/axis_util\";\nexport * from \"../ops/broadcast_util\";\nexport * from \"../ops/concat_util\";\nexport * from \"../ops/conv_util\";\nexport * from \"../ops/fused_util\";\nexport * from \"../ops/reduce_util\";\nimport * as slice_util from \"../ops/slice_util\";\nexport { slice_util };\nexport { upcastType } from \"../types\";\nexport * from \"../ops/rotate_util\";\nexport * from \"../ops/array_ops_util\";\nexport * from \"../ops/gather_nd_util\";\nexport * from \"../ops/scatter_nd_util\";\nexport * from \"../ops/selu_util\";\nexport * from \"../ops/fused_util\";\nexport * from \"../ops/erf_util\";\nexport * from \"../log\";\nexport * from \"../backends/complex_util\";\nexport * from \"../ops/split_util\";\nimport * as segment_util from \"../ops/segment_util\";\nexport { segment_util };\nexport function castTensor(x, dtype, backend) {\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return x.clone();\n    }\n\n    var zerosTensor = zeros(x.shape);\n    var floatX = cast(x, 'float32');\n    var result = backend.complex(floatX, zerosTensor);\n    zerosTensor.dispose();\n    floatX.dispose();\n    return result;\n  }\n\n  if (!hasEncodingLoss(x.dtype, dtype)) {\n    return ENGINE.makeTensorFromDataId(x.dataId, x.shape, dtype);\n  }\n\n  if (x.dtype === 'complex64') {\n    var real = backend.real(x);\n\n    var _result = cast(real, dtype);\n\n    real.dispose();\n    return _result;\n  }\n\n  if (dtype === 'int32') {\n    return backend.int(x);\n  } else if (dtype === 'bool') {\n    var zero = scalar(0, x.dtype);\n\n    var _result2 = backend.notEqual(x, zero);\n\n    zero.dispose();\n    return _result2;\n  } else {\n    throw new Error(\"Error in Cast: failed to cast \" + x.dtype + \" to \" + dtype);\n  }\n}\nexport function reshapeTensor(x, shape) {\n  return ENGINE.makeTensorFromDataId(x.dataId, shape, x.dtype);\n}\nexport function fromUint8ToStringArray(vals) {\n  try {\n    return vals.map(function (val) {\n      return decodeString(val);\n    });\n  } catch (err) {\n    throw new Error(\"Failed to decode encoded string bytes into utf-8, error: \" + err);\n  }\n}\nexport function fromStringArrayToUint8(strings) {\n  return strings.map(function (s) {\n    return encodeString(s);\n  });\n}","map":{"version":3,"sources":["../../src/backends/backend_util.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AACH,SAAQ,MAAR;AACA,SAAQ,IAAR;AACA,SAAQ,MAAR;AACA,SAAQ,KAAR;AAIA,SAAQ,YAAR,EAAsB,YAAtB,EAAoC,eAApC;AAKA;AACA;AACA;AACA;AACA;AAEA;AAEA,OAAO,KAAK,UAAZ;AACA,SAAQ,UAAR;AAEA,SAAmC,UAAnC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,KAAK,YAAZ;AACA,SAAQ,YAAR;AAEA,OAAM,SAAU,UAAV,CACF,CADE,EACI,KADJ,EACqB,OADrB,EAC2C;EAC/C,IAAI,KAAK,KAAK,WAAd,EAA2B;IACzB,IAAI,CAAC,CAAC,KAAF,KAAY,WAAhB,EAA6B;MAC3B,OAAO,CAAC,CAAC,KAAF,EAAP;IACD;;IACD,IAAM,WAAW,GAAG,KAAK,CAAC,CAAC,CAAC,KAAH,CAAzB;IACA,IAAM,MAAM,GAAG,IAAI,CAAC,CAAD,EAAI,SAAJ,CAAnB;IACA,IAAM,MAAM,GAAG,OAAO,CAAC,OAAR,CAAgB,MAAhB,EAAwB,WAAxB,CAAf;IACA,WAAW,CAAC,OAAZ;IACA,MAAM,CAAC,OAAP;IACA,OAAO,MAAP;EACD;;EAED,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,KAAH,EAAU,KAAV,CAApB,EAAsC;IAGpC,OAAO,MAAM,CAAC,oBAAP,CAA4B,CAAC,CAAC,MAA9B,EAAsC,CAAC,CAAC,KAAxC,EAA+C,KAA/C,CAAP;EACD;;EACD,IAAI,CAAC,CAAC,KAAF,KAAY,WAAhB,EAA6B;IAC3B,IAAM,IAAI,GAAG,OAAO,CAAC,IAAR,CAAa,CAAb,CAAb;;IACA,IAAM,OAAM,GAAG,IAAI,CAAC,IAAD,EAAO,KAAP,CAAnB;;IACA,IAAI,CAAC,OAAL;IACA,OAAO,OAAP;EACD;;EACD,IAAI,KAAK,KAAK,OAAd,EAAuB;IACrB,OAAO,OAAO,CAAC,GAAR,CAAY,CAAZ,CAAP;EACD,CAFD,MAEO,IAAI,KAAK,KAAK,MAAd,EAAsB;IAC3B,IAAM,IAAI,GAAG,MAAM,CAAC,CAAD,EAAI,CAAC,CAAC,KAAN,CAAnB;;IACA,IAAM,QAAM,GAAG,OAAO,CAAC,QAAR,CAAiB,CAAjB,EAAoB,IAApB,CAAf;;IACA,IAAI,CAAC,OAAL;IACA,OAAO,QAAP;EACD,CALM,MAKA;IACL,MAAM,IAAI,KAAJ,oCAA2C,CAAC,CAAC,KAA7C,YAAyD,KAAzD,CAAN;EACD;AACF;AAED,OAAM,SAAU,aAAV,CACF,CADE,EACI,KADJ,EACsB;EAC1B,OAAO,MAAM,CAAC,oBAAP,CAA4B,CAAC,CAAC,MAA9B,EAAsC,KAAtC,EAA6C,CAAC,CAAC,KAA/C,CAAP;AACD;AAED,OAAM,SAAU,sBAAV,CAAiC,IAAjC,EAAmD;EACvD,IAAI;IAEF,OAAO,IAAI,CAAC,GAAL,CAAS,UAAA,GAAG;MAAA,OAAI,YAAY,CAAC,GAAD,CAAhB;IAAA,CAAZ,CAAP;EACD,CAHD,CAGE,OAAO,GAAP,EAAY;IACZ,MAAM,IAAI,KAAJ,+DAC0D,GAD1D,CAAN;EAED;AACF;AAED,OAAM,SAAU,sBAAV,CAAiC,OAAjC,EAAkD;EACtD,OAAO,OAAO,CAAC,GAAR,CAAY,UAAA,CAAC;IAAA,OAAI,YAAY,CAAC,CAAD,CAAhB;EAAA,CAAb,CAAP;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { cast } from '../ops/cast';\nimport { scalar } from '../ops/scalar';\nimport { zeros } from '../ops/zeros';\nimport { decodeString, encodeString, hasEncodingLoss } from '../util';\n// Utilities needed by backend consumers of tf-core.\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/reduce_util';\nimport * as slice_util from '../ops/slice_util';\nexport { slice_util };\nexport { upcastType } from '../types';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../ops/split_util';\nimport * as segment_util from '../ops/segment_util';\nexport { segment_util };\nexport function castTensor(x, dtype, backend) {\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return x.clone();\n        }\n        const zerosTensor = zeros(x.shape);\n        const floatX = cast(x, 'float32');\n        const result = backend.complex(floatX, zerosTensor);\n        zerosTensor.dispose();\n        floatX.dispose();\n        return result;\n    }\n    if (!hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        return ENGINE.makeTensorFromDataId(x.dataId, x.shape, dtype);\n    }\n    if (x.dtype === 'complex64') {\n        const real = backend.real(x);\n        const result = cast(real, dtype);\n        real.dispose();\n        return result;\n    }\n    if (dtype === 'int32') {\n        return backend.int(x);\n    }\n    else if (dtype === 'bool') {\n        const zero = scalar(0, x.dtype);\n        const result = backend.notEqual(x, zero);\n        zero.dispose();\n        return result;\n    }\n    else {\n        throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n    }\n}\nexport function reshapeTensor(x, shape) {\n    return ENGINE.makeTensorFromDataId(x.dataId, shape, x.dtype);\n}\nexport function fromUint8ToStringArray(vals) {\n    try {\n        // Decode the bytes into string.\n        return vals.map(val => decodeString(val));\n    }\n    catch (err) {\n        throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);\n    }\n}\nexport function fromStringArrayToUint8(strings) {\n    return strings.map(s => encodeString(s));\n}\n//# sourceMappingURL=backend_util.js.map"]},"metadata":{},"sourceType":"module"}