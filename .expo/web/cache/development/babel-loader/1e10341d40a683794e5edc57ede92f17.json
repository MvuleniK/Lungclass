{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from \"./errors\";\nimport { resolveScalarsInLogs } from \"./logs\";\nimport * as generic_utils from \"./utils/generic_utils\";\nexport var ModelLoggingVerbosity;\n\n(function (ModelLoggingVerbosity) {\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n\nexport var DEFAULT_YIELD_EVERY_MS = 125;\nexport var BaseCallback = function () {\n  function BaseCallback() {\n    _classCallCheck(this, BaseCallback);\n\n    this.validationData = null;\n  }\n\n  _createClass(BaseCallback, [{\n    key: \"setParams\",\n    value: function setParams(params) {\n      this.params = params;\n    }\n  }, {\n    key: \"onEpochBegin\",\n    value: function onEpochBegin(epoch, logs) {\n      return _regeneratorRuntime.async(function onEpochBegin$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"onEpochEnd\",\n    value: function onEpochEnd(epoch, logs) {\n      return _regeneratorRuntime.async(function onEpochEnd$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"onBatchBegin\",\n    value: function onBatchBegin(batch, logs) {\n      return _regeneratorRuntime.async(function onBatchBegin$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"onBatchEnd\",\n    value: function onBatchEnd(batch, logs) {\n      return _regeneratorRuntime.async(function onBatchEnd$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"onTrainBegin\",\n    value: function onTrainBegin(logs) {\n      return _regeneratorRuntime.async(function onTrainBegin$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"onTrainEnd\",\n    value: function onTrainEnd(logs) {\n      return _regeneratorRuntime.async(function onTrainEnd$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"setModel\",\n    value: function setModel(model) {}\n  }]);\n\n  return BaseCallback;\n}();\nexport var CallbackList = function () {\n  function CallbackList(callbacks) {\n    var queueLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n    _classCallCheck(this, CallbackList);\n\n    if (callbacks == null) {\n      callbacks = [];\n    }\n\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  _createClass(CallbackList, [{\n    key: \"append\",\n    value: function append(callback) {\n      this.callbacks.push(callback);\n    }\n  }, {\n    key: \"setParams\",\n    value: function setParams(params) {\n      for (var _iterator = _createForOfIteratorHelperLoose(this.callbacks), _step; !(_step = _iterator()).done;) {\n        var callback = _step.value;\n        callback.setParams(params);\n      }\n    }\n  }, {\n    key: \"setModel\",\n    value: function setModel(model) {\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.callbacks), _step2; !(_step2 = _iterator2()).done;) {\n        var callback = _step2.value;\n        callback.setModel(model);\n      }\n    }\n  }, {\n    key: \"onEpochBegin\",\n    value: function onEpochBegin(epoch, logs) {\n      var _iterator3, _step3, callback;\n\n      return _regeneratorRuntime.async(function onEpochBegin$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n\n              _iterator3 = _createForOfIteratorHelperLoose(this.callbacks);\n\n            case 2:\n              if ((_step3 = _iterator3()).done) {\n                _context7.next = 8;\n                break;\n              }\n\n              callback = _step3.value;\n              _context7.next = 6;\n              return _regeneratorRuntime.awrap(callback.onEpochBegin(epoch, logs));\n\n            case 6:\n              _context7.next = 2;\n              break;\n\n            case 8:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onEpochEnd\",\n    value: function onEpochEnd(epoch, logs) {\n      var _iterator4, _step4, callback;\n\n      return _regeneratorRuntime.async(function onEpochEnd$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n\n              _iterator4 = _createForOfIteratorHelperLoose(this.callbacks);\n\n            case 2:\n              if ((_step4 = _iterator4()).done) {\n                _context8.next = 8;\n                break;\n              }\n\n              callback = _step4.value;\n              _context8.next = 6;\n              return _regeneratorRuntime.awrap(callback.onEpochEnd(epoch, logs));\n\n            case 6:\n              _context8.next = 2;\n              break;\n\n            case 8:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onBatchBegin\",\n    value: function onBatchBegin(batch, logs) {\n      var _iterator5, _step5, callback;\n\n      return _regeneratorRuntime.async(function onBatchBegin$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n\n              _iterator5 = _createForOfIteratorHelperLoose(this.callbacks);\n\n            case 2:\n              if ((_step5 = _iterator5()).done) {\n                _context9.next = 8;\n                break;\n              }\n\n              callback = _step5.value;\n              _context9.next = 6;\n              return _regeneratorRuntime.awrap(callback.onBatchBegin(batch, logs));\n\n            case 6:\n              _context9.next = 2;\n              break;\n\n            case 8:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onBatchEnd\",\n    value: function onBatchEnd(batch, logs) {\n      var _iterator6, _step6, callback;\n\n      return _regeneratorRuntime.async(function onBatchEnd$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n\n              _iterator6 = _createForOfIteratorHelperLoose(this.callbacks);\n\n            case 2:\n              if ((_step6 = _iterator6()).done) {\n                _context10.next = 8;\n                break;\n              }\n\n              callback = _step6.value;\n              _context10.next = 6;\n              return _regeneratorRuntime.awrap(callback.onBatchEnd(batch, logs));\n\n            case 6:\n              _context10.next = 2;\n              break;\n\n            case 8:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onTrainBegin\",\n    value: function onTrainBegin(logs) {\n      var _iterator7, _step7, callback;\n\n      return _regeneratorRuntime.async(function onTrainBegin$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n\n              _iterator7 = _createForOfIteratorHelperLoose(this.callbacks);\n\n            case 2:\n              if ((_step7 = _iterator7()).done) {\n                _context11.next = 8;\n                break;\n              }\n\n              callback = _step7.value;\n              _context11.next = 6;\n              return _regeneratorRuntime.awrap(callback.onTrainBegin(logs));\n\n            case 6:\n              _context11.next = 2;\n              break;\n\n            case 8:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onTrainEnd\",\n    value: function onTrainEnd(logs) {\n      var _iterator8, _step8, callback;\n\n      return _regeneratorRuntime.async(function onTrainEnd$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n\n              _iterator8 = _createForOfIteratorHelperLoose(this.callbacks);\n\n            case 2:\n              if ((_step8 = _iterator8()).done) {\n                _context12.next = 8;\n                break;\n              }\n\n              callback = _step8.value;\n              _context12.next = 6;\n              return _regeneratorRuntime.awrap(callback.onTrainEnd(logs));\n\n            case 6:\n              _context12.next = 2;\n              break;\n\n            case 8:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return CallbackList;\n}();\nexport var BaseLogger = function (_BaseCallback) {\n  _inherits(BaseLogger, _BaseCallback);\n\n  var _super = _createSuper(BaseLogger);\n\n  function BaseLogger() {\n    _classCallCheck(this, BaseLogger);\n\n    return _super.call(this);\n  }\n\n  _createClass(BaseLogger, [{\n    key: \"onEpochBegin\",\n    value: function onEpochBegin(epoch) {\n      return _regeneratorRuntime.async(function onEpochBegin$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              this.seen = 0;\n              this.totals = {};\n\n            case 2:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onBatchEnd\",\n    value: function onBatchEnd(batch, logs) {\n      var _this = this;\n\n      var batchSize, _loop, key;\n\n      return _regeneratorRuntime.async(function onBatchEnd$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n\n              batchSize = logs['size'] == null ? 0 : logs['size'];\n              this.seen += batchSize;\n\n              _loop = function _loop(key) {\n                var value = logs[key];\n\n                if (typeof value === 'number') {\n                  if (!_this.totals.hasOwnProperty(key)) {\n                    _this.totals[key] = 0;\n                  }\n\n                  _this.totals[key] = _this.totals[key] + value * batchSize;\n                } else {\n                  var oldTotalsToDispose;\n\n                  if (key in _this.totals) {\n                    oldTotalsToDispose = _this.totals[key];\n                  } else {\n                    _this.totals[key] = 0;\n                  }\n\n                  var total = tidy(function () {\n                    return add(_this.totals[key], mul(value, batchSize));\n                  });\n                  _this.totals[key] = total;\n\n                  if (oldTotalsToDispose != null) {\n                    oldTotalsToDispose.dispose();\n                  }\n                }\n              };\n\n              for (key in logs) {\n                _loop(key);\n              }\n\n            case 5:\n            case \"end\":\n              return _context14.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onEpochEnd\",\n    value: function onEpochEnd(epoch, logs) {\n      var _this2 = this;\n\n      var _loop2, _iterator9, _step9, key, _ret;\n\n      return _regeneratorRuntime.async(function onEpochEnd$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              if (!(logs != null)) {\n                _context15.next = 10;\n                break;\n              }\n\n              _loop2 = function _loop2(key) {\n                if (_this2.totals[key] == null) {\n                  return \"continue\";\n                }\n\n                if (typeof _this2.totals[key] === 'number') {\n                  logs[key] = _this2.totals[key] / _this2.seen;\n                } else {\n                  tidy(function () {\n                    var log = mul(div(1, _this2.seen), _this2.totals[key]);\n                    logs[key] = log;\n\n                    _this2.totals[key].dispose();\n\n                    keep(logs[key]);\n                  });\n                }\n              };\n\n              _iterator9 = _createForOfIteratorHelperLoose(this.params['metrics']);\n\n            case 3:\n              if ((_step9 = _iterator9()).done) {\n                _context15.next = 10;\n                break;\n              }\n\n              key = _step9.value;\n              _ret = _loop2(key);\n\n              if (!(_ret === \"continue\")) {\n                _context15.next = 8;\n                break;\n              }\n\n              return _context15.abrupt(\"continue\", 8);\n\n            case 8:\n              _context15.next = 3;\n              break;\n\n            case 10:\n            case \"end\":\n              return _context15.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return BaseLogger;\n}(BaseCallback);\nexport var History = function (_BaseCallback2) {\n  _inherits(History, _BaseCallback2);\n\n  var _super2 = _createSuper(History);\n\n  function History() {\n    _classCallCheck(this, History);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(History, [{\n    key: \"onTrainBegin\",\n    value: function onTrainBegin(logs) {\n      return _regeneratorRuntime.async(function onTrainBegin$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              this.epoch = [];\n              this.history = {};\n\n            case 2:\n            case \"end\":\n              return _context16.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onEpochEnd\",\n    value: function onEpochEnd(epoch, logs) {\n      var key;\n      return _regeneratorRuntime.async(function onEpochEnd$(_context17) {\n        while (1) {\n          switch (_context17.prev = _context17.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n\n              this.epoch.push(epoch);\n\n              for (key in logs) {\n                if (this.history[key] == null) {\n                  this.history[key] = [];\n                }\n\n                this.history[key].push(logs[key]);\n              }\n\n            case 3:\n            case \"end\":\n              return _context17.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"syncData\",\n    value: function syncData() {\n      var promises, keys, indices, key, valueArray, i, valueScalar, values, n, tensorToDispose;\n      return _regeneratorRuntime.async(function syncData$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              promises = [];\n              keys = [];\n              indices = [];\n\n              for (key in this.history) {\n                valueArray = this.history[key];\n\n                for (i = 0; i < valueArray.length; ++i) {\n                  if (typeof valueArray[i] !== 'number') {\n                    valueScalar = valueArray[i];\n                    promises.push(valueScalar.data());\n                    keys.push(key);\n                    indices.push(i);\n                  }\n                }\n              }\n\n              _context18.next = 6;\n              return _regeneratorRuntime.awrap(Promise.all(promises));\n\n            case 6:\n              values = _context18.sent;\n\n              for (n = 0; n < values.length; ++n) {\n                tensorToDispose = this.history[keys[n]][indices[n]];\n                tensorToDispose.dispose();\n                this.history[keys[n]][indices[n]] = values[n][0];\n              }\n\n            case 8:\n            case \"end\":\n              return _context18.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return History;\n}(BaseCallback);\nexport var CustomCallback = function (_BaseCallback3) {\n  _inherits(CustomCallback, _BaseCallback3);\n\n  var _super3 = _createSuper(CustomCallback);\n\n  function CustomCallback(args, yieldEvery) {\n    var _this3;\n\n    _classCallCheck(this, CustomCallback);\n\n    _this3 = _super3.call(this);\n    _this3.currentEpoch = 0;\n    _this3.yieldEvery = yieldEvery || 'auto';\n\n    if (_this3.yieldEvery === 'auto') {\n      _this3.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n\n    if (_this3.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' + 'Either change `yieldEvery` or remove the callback');\n    }\n\n    if (util.isNumber(_this3.yieldEvery)) {\n      _this3.maybeWait = generic_utils.debounce(_this3.maybeWait.bind(_assertThisInitialized(_this3)), _this3.yieldEvery);\n    }\n\n    _this3.trainBegin = args.onTrainBegin;\n    _this3.trainEnd = args.onTrainEnd;\n    _this3.epochBegin = args.onEpochBegin;\n    _this3.epochEnd = args.onEpochEnd;\n    _this3.batchBegin = args.onBatchBegin;\n    _this3.batchEnd = args.onBatchEnd;\n    _this3.yield = args.onYield;\n    return _this3;\n  }\n\n  _createClass(CustomCallback, [{\n    key: \"maybeWait\",\n    value: function maybeWait(epoch, batch, logs) {\n      var ps;\n      return _regeneratorRuntime.async(function maybeWait$(_context19) {\n        while (1) {\n          switch (_context19.prev = _context19.next) {\n            case 0:\n              ps = [];\n\n              if (!(this.yield != null)) {\n                _context19.next = 5;\n                break;\n              }\n\n              _context19.next = 4;\n              return _regeneratorRuntime.awrap(resolveScalarsInLogs(logs));\n\n            case 4:\n              ps.push(this.yield(epoch, batch, logs));\n\n            case 5:\n              ps.push(nextFrame());\n              _context19.next = 8;\n              return _regeneratorRuntime.awrap(Promise.all(ps));\n\n            case 8:\n            case \"end\":\n              return _context19.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onEpochBegin\",\n    value: function onEpochBegin(epoch, logs) {\n      return _regeneratorRuntime.async(function onEpochBegin$(_context20) {\n        while (1) {\n          switch (_context20.prev = _context20.next) {\n            case 0:\n              this.currentEpoch = epoch;\n\n              if (!(this.epochBegin != null)) {\n                _context20.next = 6;\n                break;\n              }\n\n              _context20.next = 4;\n              return _regeneratorRuntime.awrap(resolveScalarsInLogs(logs));\n\n            case 4:\n              _context20.next = 6;\n              return _regeneratorRuntime.awrap(this.epochBegin(epoch, logs));\n\n            case 6:\n            case \"end\":\n              return _context20.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onEpochEnd\",\n    value: function onEpochEnd(epoch, logs) {\n      var ps;\n      return _regeneratorRuntime.async(function onEpochEnd$(_context21) {\n        while (1) {\n          switch (_context21.prev = _context21.next) {\n            case 0:\n              ps = [];\n\n              if (!(this.epochEnd != null)) {\n                _context21.next = 5;\n                break;\n              }\n\n              _context21.next = 4;\n              return _regeneratorRuntime.awrap(resolveScalarsInLogs(logs));\n\n            case 4:\n              ps.push(this.epochEnd(epoch, logs));\n\n            case 5:\n              if (this.yieldEvery === 'epoch') {\n                ps.push(nextFrame());\n              }\n\n              _context21.next = 8;\n              return _regeneratorRuntime.awrap(Promise.all(ps));\n\n            case 8:\n            case \"end\":\n              return _context21.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onBatchBegin\",\n    value: function onBatchBegin(batch, logs) {\n      return _regeneratorRuntime.async(function onBatchBegin$(_context22) {\n        while (1) {\n          switch (_context22.prev = _context22.next) {\n            case 0:\n              if (!(this.batchBegin != null)) {\n                _context22.next = 5;\n                break;\n              }\n\n              _context22.next = 3;\n              return _regeneratorRuntime.awrap(resolveScalarsInLogs(logs));\n\n            case 3:\n              _context22.next = 5;\n              return _regeneratorRuntime.awrap(this.batchBegin(batch, logs));\n\n            case 5:\n            case \"end\":\n              return _context22.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onBatchEnd\",\n    value: function onBatchEnd(batch, logs) {\n      var ps;\n      return _regeneratorRuntime.async(function onBatchEnd$(_context23) {\n        while (1) {\n          switch (_context23.prev = _context23.next) {\n            case 0:\n              ps = [];\n\n              if (!(this.batchEnd != null)) {\n                _context23.next = 5;\n                break;\n              }\n\n              _context23.next = 4;\n              return _regeneratorRuntime.awrap(resolveScalarsInLogs(logs));\n\n            case 4:\n              ps.push(this.batchEnd(batch, logs));\n\n            case 5:\n              if (this.yieldEvery === 'batch') {\n                ps.push(nextFrame());\n              } else if (util.isNumber(this.yieldEvery)) {\n                ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n              }\n\n              _context23.next = 8;\n              return _regeneratorRuntime.awrap(Promise.all(ps));\n\n            case 8:\n            case \"end\":\n              return _context23.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onTrainBegin\",\n    value: function onTrainBegin(logs) {\n      return _regeneratorRuntime.async(function onTrainBegin$(_context24) {\n        while (1) {\n          switch (_context24.prev = _context24.next) {\n            case 0:\n              if (!(this.trainBegin != null)) {\n                _context24.next = 5;\n                break;\n              }\n\n              _context24.next = 3;\n              return _regeneratorRuntime.awrap(resolveScalarsInLogs(logs));\n\n            case 3:\n              _context24.next = 5;\n              return _regeneratorRuntime.awrap(this.trainBegin(logs));\n\n            case 5:\n            case \"end\":\n              return _context24.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onTrainEnd\",\n    value: function onTrainEnd(logs) {\n      return _regeneratorRuntime.async(function onTrainEnd$(_context25) {\n        while (1) {\n          switch (_context25.prev = _context25.next) {\n            case 0:\n              if (!(this.trainEnd != null)) {\n                _context25.next = 5;\n                break;\n              }\n\n              _context25.next = 3;\n              return _regeneratorRuntime.awrap(resolveScalarsInLogs(logs));\n\n            case 3:\n              _context25.next = 5;\n              return _regeneratorRuntime.awrap(this.trainEnd(logs));\n\n            case 5:\n            case \"end\":\n              return _context25.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return CustomCallback;\n}(BaseCallback);\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n  if (callbacks == null) {\n    callbacks = {};\n  }\n\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks;\n  }\n\n  var callbackConfigs = generic_utils.toList(callbacks);\n  return callbackConfigs.map(function (callbackConfig) {\n    return new CustomCallback(callbackConfig, yieldEvery);\n  });\n}\nexport var CallbackConstructorRegistry = function () {\n  function CallbackConstructorRegistry() {\n    _classCallCheck(this, CallbackConstructorRegistry);\n  }\n\n  _createClass(CallbackConstructorRegistry, null, [{\n    key: \"registerCallbackConstructor\",\n    value: function registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n      util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), function () {\n        return \"Verbosity level is expected to be an integer >= 0, \" + (\"but got \" + verbosityLevel);\n      });\n      CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n\n      if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n        CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n      }\n\n      CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n  }, {\n    key: \"checkForDuplicate\",\n    value: function checkForDuplicate(callbackConstructor) {\n      for (var levelName in CallbackConstructorRegistry.constructors) {\n        var constructors = CallbackConstructorRegistry.constructors[+levelName];\n        constructors.forEach(function (ctor) {\n          if (ctor === callbackConstructor) {\n            throw new ValueError('Duplicate callback constructor.');\n          }\n        });\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      CallbackConstructorRegistry.constructors = {};\n    }\n  }, {\n    key: \"createCallbacks\",\n    value: function createCallbacks(verbosityLevel) {\n      var constructors = [];\n\n      for (var levelName in CallbackConstructorRegistry.constructors) {\n        var level = +levelName;\n\n        if (verbosityLevel >= level) {\n          constructors.push.apply(constructors, _toConsumableArray(CallbackConstructorRegistry.constructors[level]));\n        }\n      }\n\n      return constructors.map(function (ctor) {\n        return new ctor();\n      });\n    }\n  }]);\n\n  return CallbackConstructorRegistry;\n}();\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n  var history = new History();\n  var actualCallbacks = [new BaseLogger()].concat(_toConsumableArray(CallbackConstructorRegistry.createCallbacks(verbose)));\n\n  if (callbacks != null) {\n    actualCallbacks.push.apply(actualCallbacks, _toConsumableArray(callbacks));\n  }\n\n  actualCallbacks.push(history);\n  var callbackList = new CallbackList(actualCallbacks);\n  callbackList.setParams({\n    epochs: epochs,\n    initialEpoch: initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize: batchSize,\n    verbose: verbose,\n    doValidation: doValidation,\n    metrics: callbackMetrics\n  });\n  return {\n    callbackList: callbackList,\n    history: history\n  };\n}","map":{"version":3,"sources":["../src/base_callbacks.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\nexport var ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport class BaseCallback {\n    constructor() {\n        // TODO(michaelterry): This type is a best guess.\n        this.validationData = null;\n    }\n    setParams(params) {\n        this.params = params;\n    }\n    async onEpochBegin(epoch, logs) { }\n    async onEpochEnd(epoch, logs) { }\n    async onBatchBegin(batch, logs) { }\n    async onBatchEnd(batch, logs) { }\n    async onTrainBegin(logs) { }\n    async onTrainEnd(logs) { }\n    // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n    setModel(model) {\n        // Do nothing. Use Callback instead of BaseCallback to track the model.\n    }\n}\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n    // TODO(cais): When the need arises, uncomment the following lines and\n    // implement the queue for time values.\n    // private deltaTBatch: number;\n    // private deltaTsBatchBegin: Array<number>;\n    // private deltaTsBatchEnd: Array<number>;\n    /**\n     * Constructor of CallbackList.\n     * @param callbacks Array of `Callback` instances.\n     * @param queueLength Queue length for keeping running statistics over\n     *   callback execution time.\n     */\n    constructor(callbacks, queueLength = 10) {\n        // TODO(cais): Make use of queueLength when implementing the queue for time\n        // values.\n        if (callbacks == null) {\n            callbacks = [];\n        }\n        this.callbacks = callbacks;\n        this.queueLength = queueLength;\n    }\n    append(callback) {\n        this.callbacks.push(callback);\n    }\n    setParams(params) {\n        for (const callback of this.callbacks) {\n            callback.setParams(params);\n        }\n    }\n    setModel(model) {\n        for (const callback of this.callbacks) {\n            callback.setModel(model);\n        }\n    }\n    /**\n     * Called at the start of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochBegin(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochBegin(epoch, logs);\n        }\n    }\n    /**\n     * Called at the end of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochEnd(epoch, logs);\n        }\n    }\n    /**\n     * Called  right before processing a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchBegin(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchBegin(batch, logs);\n        }\n    }\n    /**\n     * Called at the end of a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchEnd(batch, logs);\n        }\n    }\n    /**\n     * Called at the beginning of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainBegin(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainBegin(logs);\n        }\n    }\n    /**\n     * Called at the end of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainEnd(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainEnd(logs);\n        }\n    }\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n    constructor() {\n        super();\n    }\n    async onEpochBegin(epoch) {\n        this.seen = 0;\n        this.totals = {};\n    }\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        const batchSize = logs['size'] == null ? 0 : logs['size'];\n        this.seen += batchSize;\n        for (const key in logs) {\n            const value = logs[key];\n            if (typeof value === 'number') {\n                if (!this.totals.hasOwnProperty(key)) {\n                    this.totals[key] = 0;\n                }\n                this.totals[key] = this.totals[key] + value * batchSize;\n            }\n            else {\n                let oldTotalsToDispose;\n                if (key in this.totals) {\n                    oldTotalsToDispose = this.totals[key];\n                }\n                else {\n                    this.totals[key] = 0;\n                }\n                const total = tidy(() => add((this.totals[key]), mul(value, batchSize)));\n                this.totals[key] = total;\n                if (oldTotalsToDispose != null) {\n                    oldTotalsToDispose.dispose();\n                }\n            }\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs != null) {\n            for (const key of this.params['metrics']) {\n                if (this.totals[key] == null) {\n                    continue;\n                }\n                if (typeof this.totals[key] === 'number') {\n                    logs[key] = this.totals[key] / this.seen;\n                }\n                else {\n                    tidy(() => {\n                        const log = mul(div(1, this.seen), this.totals[key]);\n                        logs[key] = log;\n                        this.totals[key].dispose();\n                        keep(logs[key]);\n                    });\n                }\n            }\n        }\n    }\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n    async onTrainBegin(logs) {\n        this.epoch = [];\n        this.history = {};\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        this.epoch.push(epoch);\n        for (const key in logs) {\n            if (this.history[key] == null) {\n                this.history[key] = [];\n            }\n            this.history[key].push(logs[key]);\n        }\n    }\n    /**\n     * Await the values of all losses and metrics.\n     */\n    async syncData() {\n        const promises = [];\n        const keys = [];\n        const indices = [];\n        for (const key in this.history) {\n            const valueArray = this.history[key];\n            for (let i = 0; i < valueArray.length; ++i) {\n                if (typeof valueArray[i] !== 'number') {\n                    const valueScalar = valueArray[i];\n                    promises.push(valueScalar.data());\n                    keys.push(key);\n                    indices.push(i);\n                }\n            }\n        }\n        const values = await Promise.all(promises);\n        for (let n = 0; n < values.length; ++n) {\n            const tensorToDispose = this.history[keys[n]][indices[n]];\n            tensorToDispose.dispose();\n            this.history[keys[n]][indices[n]] = values[n][0];\n        }\n    }\n}\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n    constructor(args, yieldEvery) {\n        super();\n        this.currentEpoch = 0;\n        this.yieldEvery = yieldEvery || 'auto';\n        if (this.yieldEvery === 'auto') {\n            this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n        }\n        if (this.yieldEvery === 'never' && args.onYield != null) {\n            throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' +\n                'Either change `yieldEvery` or remove the callback');\n        }\n        if (util.isNumber(this.yieldEvery)) {\n            // Decorate `maybeWait` so it will be called at most once every\n            // `yieldEvery` ms.\n            this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery);\n        }\n        this.trainBegin = args.onTrainBegin;\n        this.trainEnd = args.onTrainEnd;\n        this.epochBegin = args.onEpochBegin;\n        this.epochEnd = args.onEpochEnd;\n        this.batchBegin = args.onBatchBegin;\n        this.batchEnd = args.onBatchEnd;\n        this.yield = args.onYield;\n    }\n    async maybeWait(epoch, batch, logs) {\n        const ps = [];\n        if (this.yield != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.yield(epoch, batch, logs));\n        }\n        ps.push(nextFrame());\n        await Promise.all(ps);\n    }\n    async onEpochBegin(epoch, logs) {\n        this.currentEpoch = epoch;\n        if (this.epochBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.epochBegin(epoch, logs);\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        const ps = [];\n        if (this.epochEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.epochEnd(epoch, logs));\n        }\n        if (this.yieldEvery === 'epoch') {\n            ps.push(nextFrame());\n        }\n        await Promise.all(ps);\n    }\n    async onBatchBegin(batch, logs) {\n        if (this.batchBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.batchBegin(batch, logs);\n        }\n    }\n    async onBatchEnd(batch, logs) {\n        const ps = [];\n        if (this.batchEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.batchEnd(batch, logs));\n        }\n        if (this.yieldEvery === 'batch') {\n            ps.push(nextFrame());\n        }\n        else if (util.isNumber(this.yieldEvery)) {\n            ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n        }\n        await Promise.all(ps);\n    }\n    async onTrainBegin(logs) {\n        if (this.trainBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainBegin(logs);\n        }\n    }\n    async onTrainEnd(logs) {\n        if (this.trainEnd != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainEnd(logs);\n        }\n    }\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n    if (callbacks == null) {\n        callbacks = {};\n    }\n    if (callbacks instanceof BaseCallback) {\n        return [callbacks];\n    }\n    if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n        return callbacks;\n    }\n    // Convert custom callback configs to custom callback objects.\n    const callbackConfigs = generic_utils.toList(callbacks);\n    return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n    /**\n     * Blocks public access to constructor.\n     */\n    constructor() { }\n    /**\n     * Register a tf.LayersModel.fit() callback constructor.\n     *\n     * The registered callback constructor will be used to instantiate\n     * callbacks for every tf.LayersModel.fit() call afterwards.\n     *\n     * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n     *   is to be reigstered.\n     * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n     * @throws Error, if the same callbackConstructor has been registered before,\n     *   either at the same or a different `verbosityLevel`.\n     */\n    static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n        util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n        CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n        if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n            CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n        }\n        CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n    static checkForDuplicate(callbackConstructor) {\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const constructors = CallbackConstructorRegistry.constructors[+levelName];\n            constructors.forEach(ctor => {\n                if (ctor === callbackConstructor) {\n                    throw new ValueError('Duplicate callback constructor.');\n                }\n            });\n        }\n    }\n    /**\n     * Clear all registered callback constructors.\n     */\n    static clear() {\n        CallbackConstructorRegistry.constructors = {};\n    }\n    /**\n     * Create callbacks using the registered callback constructors.\n     *\n     * Given `verbosityLevel`, all constructors registered at that level or above\n     * will be called and the instantiated callbacks will be used.\n     *\n     * @param verbosityLevel: Level of verbosity.\n     */\n    static createCallbacks(verbosityLevel) {\n        const constructors = [];\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const level = +levelName;\n            if (verbosityLevel >= level) {\n                constructors.push(...CallbackConstructorRegistry.constructors[level]);\n            }\n        }\n        return constructors.map(ctor => new ctor());\n    }\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n    const history = new History();\n    const actualCallbacks = [\n        new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n    ];\n    if (callbacks != null) {\n        actualCallbacks.push(...callbacks);\n    }\n    actualCallbacks.push(history);\n    const callbackList = new CallbackList(actualCallbacks);\n    // TODO(cais): Figure out when this LayersModel instance can have a\n    // dynamically\n    //   set property called 'callback_model' as in PyKeras.\n    callbackList.setParams({\n        epochs,\n        initialEpoch,\n        samples: numTrainSamples,\n        steps: stepsPerEpoch,\n        batchSize,\n        verbose,\n        doValidation,\n        metrics: callbackMetrics,\n    });\n    return { callbackList, history };\n}\n//# sourceMappingURL=base_callbacks.js.map"]},"metadata":{},"sourceType":"module"}