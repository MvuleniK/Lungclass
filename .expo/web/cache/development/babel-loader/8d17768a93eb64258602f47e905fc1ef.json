{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var CropAndResizeProgram = _createClass(function CropAndResizeProgram(imageShape, boxShape, cropSize, method, extrapolationValue) {\n  _classCallCheck(this, CropAndResizeProgram);\n\n  this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n  this.outputShape = [];\n\n  var _imageShape = _slicedToArray(imageShape, 4),\n      batch = _imageShape[0],\n      imageHeight = _imageShape[1],\n      imageWidth = _imageShape[2],\n      depth = _imageShape[3];\n\n  var _boxShape = _slicedToArray(boxShape, 1),\n      numBoxes = _boxShape[0];\n\n  var _cropSize = _slicedToArray(cropSize, 2),\n      cropHeight = _cropSize[0],\n      cropWidth = _cropSize[1];\n\n  this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n  var methodId = method === 'bilinear' ? 1 : 0;\n  var inputHeightFloat = imageHeight - 1 + \".0\",\n      inputWidthFloat = imageWidth - 1 + \".0\";\n\n  var _ref = cropHeight > 1 ? [\"\" + (imageHeight - 1) / (cropHeight - 1), '(y2-y1) * height_ratio', \"y1*\" + inputHeightFloat + \" + float(y)*(height_scale)\"] : ['0.0', '0.0', \"0.5 * (y1+y2) * \" + inputHeightFloat],\n      _ref2 = _slicedToArray(_ref, 3),\n      heightRatio = _ref2[0],\n      heightScale = _ref2[1],\n      inY = _ref2[2];\n\n  var _ref3 = cropWidth > 1 ? [\"\" + (imageWidth - 1) / (cropWidth - 1), '(x2-x1) * width_ratio', \"x1*\" + inputWidthFloat + \" + float(x)*(width_scale)\"] : ['0.0', '0.0', \"0.5 * (x1+x2) * \" + inputWidthFloat],\n      _ref4 = _slicedToArray(_ref3, 3),\n      widthRatio = _ref4[0],\n      widthScale = _ref4[1],\n      inX = _ref4[2];\n\n  this.userCode = \"\\n      const float height_ratio = float(\" + heightRatio + \");\\n      const float width_ratio = float(\" + widthRatio + \");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \" + batch + \") {\\n          return;\\n        }\\n\\n        float height_scale = \" + heightScale + \";\\n        float width_scale = \" + widthScale + \";\\n\\n        float in_y = \" + inY + \";\\n        if( in_y < 0.0 || in_y > \" + inputHeightFloat + \" ) {\\n          setOutput(float(\" + extrapolationValue + \"));\\n          return;\\n        }\\n        float in_x = \" + inX + \";\\n        if( in_x < 0.0 || in_x > \" + inputWidthFloat + \" ) {\\n          setOutput(float(\" + extrapolationValue + \"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\\n        if(\" + methodId + \" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\\n\\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\\n\\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\\n\\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\\n          float newValue = top + (bottom - top) * fracCR.y;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestCR = ivec2(floor(\\n            sourceFracIndexCR + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \";\n});","map":{"version":3,"sources":["../src/crop_and_resize_gpu.ts"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;AAeG;AAIH,WAAa,oBAAb,gBAKE,8BACI,UADJ,EACkD,QADlD,EAEI,QAFJ,EAEgC,MAFhC,EAGI,kBAHJ,EAG8B;EAAA;;EAP9B,KAAA,aAAA,GAAgB,CAAC,OAAD,EAAU,OAAV,EAAmB,QAAnB,CAAhB;EACA,KAAA,WAAA,GAAwB,EAAxB;;EAOE,iCAAgD,UAAhD;EAAA,IAAO,KAAP;EAAA,IAAc,WAAd;EAAA,IAA2B,UAA3B;EAAA,IAAuC,KAAvC;;EACA,+BAAqB,QAArB;EAAA,IAAO,QAAP;;EACA,+BAAgC,QAAhC;EAAA,IAAO,UAAP;EAAA,IAAmB,SAAnB;;EACA,KAAK,WAAL,GAAmB,CAAC,QAAD,EAAW,UAAX,EAAuB,SAAvB,EAAkC,KAAlC,CAAnB;EACA,IAAM,QAAQ,GAAG,MAAM,KAAK,UAAX,GAAwB,CAAxB,GAA4B,CAA7C;EAEA,IAAO,gBAAP,GACQ,WAAW,GAAG,CADtB;EAAA,IAAyB,eAAzB,GACgC,UAAU,GAAG,CAD7C;;EAGA,WAAwC,UAAU,GAAG,CAAb,GACpC,MACK,CAAC,WAAW,GAAG,CAAf,KAAqB,UAAU,GAAG,CAAlC,CADL,EAEE,wBAFF,UAGQ,gBAHR,gCADoC,GAMpC,CACE,KADF,EAEE,KAFF,uBAGqB,gBAHrB,CANJ;EAAA;EAAA,IAAO,WAAP;EAAA,IAAoB,WAApB;EAAA,IAAiC,GAAjC;;EAWA,YAAsC,SAAS,GAAG,CAAZ,GAClC,MACK,CAAC,UAAU,GAAG,CAAd,KAAoB,SAAS,GAAG,CAAhC,CADL,EAEE,uBAFF,UAGQ,eAHR,+BADkC,GAMlC,CACE,KADF,EAEE,KAFF,uBAGqB,eAHrB,CANJ;EAAA;EAAA,IAAO,UAAP;EAAA,IAAmB,UAAnB;EAAA,IAA+B,GAA/B;;EAeA,KAAK,QAAL,iDACqC,WADrC,kDAEoC,UAFpC,kdAkB6B,KAlB7B,0EAsB2B,WAtB3B,uCAuB0B,UAvB1B,kCAyBmB,GAzBnB,4CA0B+B,gBA1B/B,wCA2BwB,kBA3BxB,gEA8BmB,GA9BnB,4CA+B+B,eA/B/B,wCAgCwB,kBAhCxB,2GAqCS,QArCT;AA8DD,CA1GH","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class CropAndResizeProgram {\n    constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {\n        this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n        this.outputShape = [];\n        const [batch, imageHeight, imageWidth, depth] = imageShape;\n        const [numBoxes,] = boxShape;\n        const [cropHeight, cropWidth] = cropSize;\n        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n        const methodId = method === 'bilinear' ? 1 : 0;\n        const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n        const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n            [\n                `${(imageHeight - 1) / (cropHeight - 1)}`,\n                '(y2-y1) * height_ratio',\n                `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (y1+y2) * ${inputHeightFloat}`,\n            ];\n        const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n            [\n                `${(imageWidth - 1) / (cropWidth - 1)}`,\n                '(x2-x1) * width_ratio',\n                `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (x1+x2) * ${inputWidthFloat}`,\n            ];\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n        this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=crop_and_resize_gpu.js.map"]},"metadata":{},"sourceType":"module"}