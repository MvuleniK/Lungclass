{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var MatMulPackedProgram = _createClass(function MatMulPackedProgram(aShape, bShape, outputShape) {\n  var transposeA = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var transposeB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var addBias = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var activation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var hasPreluActivation = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var hasLeakyreluActivation = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n\n  _classCallCheck(this, MatMulPackedProgram);\n\n  this.variableNames = ['matrixA', 'matrixB'];\n  this.packedInputs = true;\n  this.packedOutput = true;\n  this.outputShape = outputShape;\n  var sharedDim = transposeA ? aShape[1] : aShape[2];\n  var sharedDimensionPacked = Math.ceil(sharedDim / 2);\n  var aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n  var bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n  var aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n  var bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n  var activationSnippet = '',\n      applyActivationSnippet = '';\n\n  if (activation) {\n    if (hasPreluActivation) {\n      activationSnippet = \"vec4 activation(vec4 a) {\\n          vec4 b = getPreluActivationWeightsAtOutCoords();\\n          \" + activation + \"\\n        }\";\n    } else if (hasLeakyreluActivation) {\n      activationSnippet = \"vec4 activation(vec4 a) {\\n          vec4 b = getLeakyreluAlphaAtOutCoords();\\n          \" + activation + \"\\n        }\";\n    } else {\n      activationSnippet = \"vec4 activation(vec4 x) {\\n          \" + activation + \"\\n        }\";\n    }\n\n    applyActivationSnippet = \"result = activation(result);\";\n  }\n\n  var addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n\n  if (addBias) {\n    this.variableNames.push('bias');\n  }\n\n  if (hasPreluActivation) {\n    this.variableNames.push('preluActivationWeights');\n  }\n\n  if (hasLeakyreluActivation) {\n    this.variableNames.push('leakyreluAlpha');\n  }\n\n  var batchASnippet = 'rc.x';\n  var batchBSnippet = 'rc.x';\n\n  if (aShape[0] < bShape[0]) {\n    batchASnippet = \"int(min(float(rc.x), \" + (aShape[0] - 1) + \".))\";\n  } else if (bShape[0] < aShape[0]) {\n    batchBSnippet = \"int(min(float(rc.x), \" + (bShape[0] - 1) + \".))\";\n  }\n\n  this.userCode = \"\\n      \" + activationSnippet + \"\\n\\n      const float sharedDimension = \" + sharedDimensionPacked + \".0;\\n\\n      vec4 dot2x2ARowBCol(ivec3 rc) {\\n        vec4 result = vec4(0);\\n        for (int i = 0; i < \" + sharedDimensionPacked + \"; i++) {\\n          int batchA = \" + batchASnippet + \";\\n          int batchB = \" + batchBSnippet + \";\\n          vec4 a = getMatrixA(batchA, \" + aSample + \");\\n          vec4 b = getMatrixB(batchB, \" + bSample + \");\\n\\n          // These swizzled products need to be separately added.\\n          // See: https://github.com/tensorflow/tfjs/issues/1735\\n          result += (\" + aSwizzle[0] + \" * \" + bSwizzle[0] + \");\\n          result += (\" + aSwizzle[1] + \" * \" + bSwizzle[1] + \");\\n        }\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n        vec4 result = dot2x2ARowBCol(rc);\\n\\n        \" + addBiasSnippet + \"\\n\\n        \" + applyActivationSnippet + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n});","map":{"version":3,"sources":["../src/mulmat_packed_gpu.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;;;AAeG;AAIH,WAAa,mBAAb,gBAOE,6BACI,MADJ,EACsC,MADtC,EAEI,WAFJ,EAI8D;EAAA,IAFnB,UAEmB,uEAFN,KAEM;EAAA,IAD1D,UAC0D,uEAD7C,KAC6C;EAAA,IADtC,OACsC,uEAD5B,KAC4B;EAAA,IADrB,UACqB,uEADA,IACA;EAAA,IAA1D,kBAA0D,uEAArC,KAAqC;EAAA,IAA9B,sBAA8B,uEAAL,KAAK;;EAAA;;EAV9D,KAAA,aAAA,GAAgB,CAAC,SAAD,EAAY,SAAZ,CAAhB;EACA,KAAA,YAAA,GAAe,IAAf;EACA,KAAA,YAAA,GAAe,IAAf;EASE,KAAK,WAAL,GAAmB,WAAnB;EAEA,IAAM,SAAS,GAAG,UAAU,GAAG,MAAM,CAAC,CAAD,CAAT,GAAe,MAAM,CAAC,CAAD,CAAjD;EACA,IAAM,qBAAqB,GAAG,IAAI,CAAC,IAAL,CAAU,SAAS,GAAG,CAAtB,CAA9B;EAEA,IAAM,OAAO,GAAG,UAAU,GAAG,aAAH,GAAmB,aAA7C;EACA,IAAM,OAAO,GAAG,UAAU,GAAG,aAAH,GAAmB,aAA7C;EACA,IAAM,QAAQ,GAAG,UAAU,GAAG,CAAC,QAAD,EAAW,QAAX,CAAH,GAA0B,CAAC,QAAD,EAAW,QAAX,CAArD;EACA,IAAM,QAAQ,GAAG,UAAU,GAAG,CAAC,QAAD,EAAW,QAAX,CAAH,GAA0B,CAAC,QAAD,EAAW,QAAX,CAArD;EAEA,IAAI,iBAAiB,GAAG,EAAxB;EAAA,IAA4B,sBAAsB,GAAG,EAArD;;EACA,IAAI,UAAJ,EAAgB;IACd,IAAI,kBAAJ,EAAwB;MACtB,iBAAiB,yGAEb,UAFa,gBAAjB;IAID,CALD,MAKO,IAAI,sBAAJ,EAA4B;MACjC,iBAAiB,iGAEb,UAFa,gBAAjB;IAID,CALM,MAKA;MACL,iBAAiB,6CACb,UADa,gBAAjB;IAGD;;IAED,sBAAsB,iCAAtB;EACD;;EAED,IAAM,cAAc,GAAG,OAAO,GAAG,iCAAH,GAAuC,EAArE;;EACA,IAAI,OAAJ,EAAa;IACX,KAAK,aAAL,CAAmB,IAAnB,CAAwB,MAAxB;EACD;;EAED,IAAI,kBAAJ,EAAwB;IACtB,KAAK,aAAL,CAAmB,IAAnB,CAAwB,wBAAxB;EACD;;EAED,IAAI,sBAAJ,EAA4B;IAC1B,KAAK,aAAL,CAAmB,IAAnB,CAAwB,gBAAxB;EACD;;EAED,IAAI,aAAa,GAAG,MAApB;EACA,IAAI,aAAa,GAAG,MAApB;;EACA,IAAI,MAAM,CAAC,CAAD,CAAN,GAAY,MAAM,CAAC,CAAD,CAAtB,EAA2B;IACzB,aAAa,8BAA2B,MAAM,CAAC,CAAD,CAAN,GAAY,CAAvC,SAAb;EACD,CAFD,MAEO,IAAI,MAAM,CAAC,CAAD,CAAN,GAAY,MAAM,CAAC,CAAD,CAAtB,EAA2B;IAChC,aAAa,8BAA2B,MAAM,CAAC,CAAD,CAAN,GAAY,CAAvC,SAAb;EACD;;EAED,KAAK,QAAL,gBACI,iBADJ,gDAGkC,qBAHlC,kHAO0B,qBAP1B,yCAQqB,aARrB,kCASqB,aATrB,iDAUoC,OAVpC,kDAWoC,OAXpC,wKAemB,QAAQ,CAAC,CAAD,CAf3B,WAeoC,QAAQ,CAAC,CAAD,CAf5C,iCAgBmB,QAAQ,CAAC,CAAD,CAhB3B,WAgBoC,QAAQ,CAAC,CAAD,CAhB5C,2KAyBM,cAzBN,oBA2BM,sBA3BN;AAgCD,CAhGH","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class MatMulPackedProgram {\n    constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation = null, hasPreluActivation = false, hasLeakyreluActivation = false) {\n        this.variableNames = ['matrixA', 'matrixB'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        const sharedDim = transposeA ? aShape[1] : aShape[2];\n        const sharedDimensionPacked = Math.ceil(sharedDim / 2);\n        const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n        const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n        const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n        const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyreluActivation) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        let batchASnippet = 'rc.x';\n        let batchBSnippet = 'rc.x';\n        if (aShape[0] < bShape[0]) {\n            batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;\n        }\n        else if (bShape[0] < aShape[0]) {\n            batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const float sharedDimension = ${sharedDimensionPacked}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${sharedDimensionPacked}; i++) {\n          int batchA = ${batchASnippet};\n          int batchB = ${batchBSnippet};\n          vec4 a = getMatrixA(batchA, ${aSample});\n          vec4 b = getMatrixB(batchB, ${bSample});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${aSwizzle[0]} * ${bSwizzle[0]});\n          result += (${aSwizzle[1]} * ${bSwizzle[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${addBiasSnippet}\n\n        ${applyActivationSnippet}\n\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mulmat_packed_gpu.js.map"]},"metadata":{},"sourceType":"module"}