{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar PassthroughLoader = function () {\n  function PassthroughLoader(modelArtifacts) {\n    _classCallCheck(this, PassthroughLoader);\n\n    this.modelArtifacts = modelArtifacts;\n  }\n\n  _createClass(PassthroughLoader, [{\n    key: \"load\",\n    value: function load() {\n      return _regeneratorRuntime.async(function load$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.modelArtifacts);\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return PassthroughLoader;\n}();\n\nvar PassthroughSaver = function () {\n  function PassthroughSaver(saveHandler) {\n    _classCallCheck(this, PassthroughSaver);\n\n    this.saveHandler = saveHandler;\n  }\n\n  _createClass(PassthroughSaver, [{\n    key: \"save\",\n    value: function save(modelArtifacts) {\n      return _regeneratorRuntime.async(function save$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", this.saveHandler(modelArtifacts));\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return PassthroughSaver;\n}();\n\nexport function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n  if (arguments.length === 1) {\n    var isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;\n\n    if (isModelArtifacts) {\n      return new PassthroughLoader(modelArtifacts);\n    } else {\n      console.warn('Please call tf.io.fromMemory() with only one argument. ' + 'The argument should be of type ModelArtifacts. ' + 'The multi-argument signature of tf.io.fromMemory() has been ' + 'deprecated and will be removed in a future release.');\n      return new PassthroughLoader({\n        modelTopology: modelArtifacts\n      });\n    }\n  } else {\n    console.warn('Please call tf.io.fromMemory() with only one argument. ' + 'The argument should be of type ModelArtifacts. ' + 'The multi-argument signature of tf.io.fromMemory() has been ' + 'deprecated and will be removed in a future release.');\n    return new PassthroughLoader({\n      modelTopology: modelArtifacts,\n      weightSpecs: weightSpecs,\n      weightData: weightData,\n      trainingConfig: trainingConfig\n    });\n  }\n}\nexport function withSaveHandler(saveHandler) {\n  return new PassthroughSaver(saveHandler);\n}","map":{"version":3,"sources":["../../src/io/passthrough.ts"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;AAeG;IAQG,iB;EACJ,2BAA6B,cAA7B,EAA4D;IAAA;;IAA/B,KAAA,cAAA,GAAA,cAAA;EAAmC;;;;WAEhE;MAAA;QAAA;UAAA;YAAA;cAAA,iCACS,KAAK,cADd;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;;;;;;IAKI,gB;EACJ,0BACqB,WADrB,EAE0D;IAAA;;IADrC,KAAA,WAAA,GAAA,WAAA;EACyC;;;;WAE9D,cAAW,cAAX;MAAA;QAAA;UAAA;YAAA;cAAA,kCACS,KAAK,WAAL,CAAiB,cAAjB,CADT;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;;;;;;AA0BF,OAAM,SAAU,UAAV,CACF,cADE,EACiC,WADjC,EAEF,UAFE,EAEwB,cAFxB,EAEuD;EAC3D,IAAI,SAAS,CAAC,MAAV,KAAqB,CAAzB,EAA4B;IAC1B,IAAM,gBAAgB,GACjB,cAAiC,CAAC,aAAlC,IAAmD,IAAnD,IACA,cAAiC,CAAC,WAAlC,IAAiD,IAFtD;;IAGA,IAAI,gBAAJ,EAAsB;MACpB,OAAO,IAAI,iBAAJ,CAAsB,cAAtB,CAAP;IACD,CAFD,MAEO;MAGL,OAAO,CAAC,IAAR,CACI,4DACA,iDADA,GAEA,8DAFA,GAGA,qDAJJ;MAKA,OAAO,IAAI,iBAAJ,CAAsB;QAAC,aAAa,EAAE;MAAhB,CAAtB,CAAP;IACD;EACF,CAhBD,MAgBO;IAGL,OAAO,CAAC,IAAR,CACI,4DACA,iDADA,GAEA,8DAFA,GAGA,qDAJJ;IAKA,OAAO,IAAI,iBAAJ,CAAsB;MAC3B,aAAa,EAAE,cADY;MAE3B,WAAW,EAAX,WAF2B;MAG3B,UAAU,EAAV,UAH2B;MAI3B,cAAc,EAAd;IAJ2B,CAAtB,CAAP;EAMD;AACF;AAiBD,OAAM,SAAU,eAAV,CACF,WADE,EAEqB;EACzB,OAAO,IAAI,gBAAJ,CAAqB,WAArB,CAAP;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nclass PassthroughLoader {\n    constructor(modelArtifacts) {\n        this.modelArtifacts = modelArtifacts;\n    }\n    async load() {\n        return this.modelArtifacts;\n    }\n}\nclass PassthroughSaver {\n    constructor(saveHandler) {\n        this.saveHandler = saveHandler;\n    }\n    async save(modelArtifacts) {\n        return this.saveHandler(modelArtifacts);\n    }\n}\n/**\n * Creates an IOHandler that loads model artifacts from memory.\n *\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\n *     modelTopology, weightSpecs, weightData));\n * ```\n *\n * @param modelArtifacts a object containing model topology (i.e., parsed from\n *   the JSON format).\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\n *   names, shapes, types, and quantization of the weight data.\n * @param weightData A single `ArrayBuffer` containing the weight data,\n *   concatenated in the order described by the weightSpecs.\n * @param trainingConfig Model training configuration. Optional.\n *\n * @returns A passthrough `IOHandler` that simply loads the provided data.\n */\nexport function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n    if (arguments.length === 1) {\n        const isModelArtifacts = modelArtifacts.modelTopology != null ||\n            modelArtifacts.weightSpecs != null;\n        if (isModelArtifacts) {\n            return new PassthroughLoader(modelArtifacts);\n        }\n        else {\n            // Legacy support: with only modelTopology.\n            // TODO(cais): Remove this deprecated API.\n            console.warn('Please call tf.io.fromMemory() with only one argument. ' +\n                'The argument should be of type ModelArtifacts. ' +\n                'The multi-argument signature of tf.io.fromMemory() has been ' +\n                'deprecated and will be removed in a future release.');\n            return new PassthroughLoader({ modelTopology: modelArtifacts });\n        }\n    }\n    else {\n        // Legacy support.\n        // TODO(cais): Remove this deprecated API.\n        console.warn('Please call tf.io.fromMemory() with only one argument. ' +\n            'The argument should be of type ModelArtifacts. ' +\n            'The multi-argument signature of tf.io.fromMemory() has been ' +\n            'deprecated and will be removed in a future release.');\n        return new PassthroughLoader({\n            modelTopology: modelArtifacts,\n            weightSpecs,\n            weightData,\n            trainingConfig\n        });\n    }\n}\n/**\n * Creates an IOHandler that passes saved model artifacts to a callback.\n *\n * ```js\n * function handleSave(artifacts) {\n *   // ... do something with the artifacts ...\n *   return {modelArtifactsInfo: {...}, ...};\n * }\n *\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\n * ```\n *\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\n *     `SaveResult`.\n */\nexport function withSaveHandler(saveHandler) {\n    return new PassthroughSaver(saveHandler);\n}\n//# sourceMappingURL=passthrough.js.map"]},"metadata":{},"sourceType":"module"}