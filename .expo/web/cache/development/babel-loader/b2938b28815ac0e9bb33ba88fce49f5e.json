{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport { downloadTextureData, drawTexture, runResizeProgram, uploadTextureData } from \"./camera_webgl_util\";\nvar glCapabilities = {\n  canDownloadFromRGBTexture: new WeakMap(),\n  glCapabilitiesTested: new WeakMap()\n};\nexport function detectGLCapabilities(gl) {\n  var height, width, data, i, sourceDims, tex, targetDims, downloaded, downloadedData, matches;\n  return _regeneratorRuntime.async(function detectGLCapabilities$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!glCapabilities.glCapabilitiesTested.get(gl)) {\n            _context.next = 2;\n            break;\n          }\n\n          return _context.abrupt(\"return\");\n\n        case 2:\n          glCapabilities.canDownloadFromRGBTexture.set(gl, true);\n          _context.prev = 3;\n          height = 2;\n          width = 4;\n          data = new Uint8Array(height * width * 4);\n\n          for (i = 0; i < data.length; i++) {\n            data[i] = i;\n          }\n\n          sourceDims = {\n            height: height,\n            width: width,\n            depth: 4\n          };\n          tex = uploadTextureData(data, gl, sourceDims);\n          targetDims = {\n            height: height,\n            width: width,\n            depth: 3\n          };\n          downloaded = fromTexture(gl, tex, sourceDims, targetDims);\n          _context.next = 14;\n          return _regeneratorRuntime.awrap(downloaded.data());\n\n        case 14:\n          downloadedData = _context.sent;\n          tf.dispose(downloaded);\n          matches = tf.util.arraysEqual(downloadedData, [0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 20, 21, 22, 24, 25, 26, 28, 29, 30]);\n\n          if (matches) {\n            glCapabilities.canDownloadFromRGBTexture.set(gl, true);\n          } else {\n            glCapabilities.canDownloadFromRGBTexture.set(gl, false);\n          }\n\n          _context.next = 23;\n          break;\n\n        case 20:\n          _context.prev = 20;\n          _context.t0 = _context[\"catch\"](3);\n          glCapabilities.canDownloadFromRGBTexture.set(gl, false);\n\n        case 23:\n          _context.prev = 23;\n          glCapabilities.glCapabilitiesTested.set(gl, true);\n          return _context.finish(23);\n\n        case 26:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[3, 20, 23, 26]], Promise);\n}\nexport function toTexture(gl, imageTensor, texture) {\n  var imageData, dims;\n  return _regeneratorRuntime.async(function toTexture$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          tf.util.assert(imageTensor.dtype === 'int32', function () {\n            return 'imageTensor must be of type int32';\n          });\n          tf.util.assert(imageTensor.rank === 3, function () {\n            return 'imageTensor must be a Tensor3D';\n          });\n          _context2.t0 = Uint8Array;\n          _context2.next = 5;\n          return _regeneratorRuntime.awrap(imageTensor.data());\n\n        case 5:\n          _context2.t1 = _context2.sent;\n          imageData = _context2.t0.from.call(_context2.t0, _context2.t1);\n          dims = {\n            height: imageTensor.shape[0],\n            width: imageTensor.shape[1],\n            depth: imageTensor.shape[2]\n          };\n          return _context2.abrupt(\"return\", uploadTextureData(imageData, gl, dims, texture));\n\n        case 9:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function fromTexture(gl, texture, sourceDims, targetShape) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  tf.util.assert(targetShape.depth === 3 || targetShape.depth === 4, function () {\n    return 'fromTexture Error: target depth must be 3 or 4';\n  });\n\n  if (targetShape.depth === 3 && targetShape.width % 4 !== 0) {\n    if (glCapabilities.canDownloadFromRGBTexture.get(gl)) {\n      throw new Error('When using targetShape.depth=3, targetShape.width must be' + ' a multiple of 4. Alternatively do not call detectGLCapabilities()');\n    }\n  }\n\n  var originalTargetDepth = targetShape.depth;\n  var targetDepth = glCapabilities.canDownloadFromRGBTexture.get(gl) ? originalTargetDepth : 4;\n  sourceDims = {\n    height: Math.floor(sourceDims.height),\n    width: Math.floor(sourceDims.width),\n    depth: sourceDims.depth\n  };\n  targetShape = {\n    height: Math.floor(targetShape.height),\n    width: Math.floor(targetShape.width),\n    depth: targetDepth\n  };\n  var alignCorners = options.alignCorners != null ? options.alignCorners : false;\n  var interpolation = options.interpolation != null ? options.interpolation : 'bilinear';\n  tf.util.assert(interpolation === 'bilinear' || interpolation === 'nearest_neighbor', function () {\n    return 'fromTexture Error: interpolation must be one of' + ' \"bilinear\" or \"nearest_neighbor\"';\n  });\n  var resizedTexture = runResizeProgram(gl, texture, sourceDims, targetShape, alignCorners, interpolation);\n  var downloadedTextureData = downloadTextureData(gl, resizedTexture, targetShape);\n  var finalTexData;\n\n  if (originalTargetDepth !== targetDepth && originalTargetDepth === 3) {\n    var area = targetShape.height * targetShape.width;\n    finalTexData = new Uint8Array(area * originalTargetDepth);\n\n    for (var i = 0; i < area; i++) {\n      var flatIndexRGB = i * 3;\n      var flatIndexRGBA = i * 4;\n      finalTexData[flatIndexRGB] = downloadedTextureData[flatIndexRGBA];\n      finalTexData[flatIndexRGB + 1] = downloadedTextureData[flatIndexRGBA + 1];\n      finalTexData[flatIndexRGB + 2] = downloadedTextureData[flatIndexRGBA + 2];\n    }\n  } else {\n    finalTexData = downloadedTextureData;\n  }\n\n  return tf.tensor3d(finalTexData, [targetShape.height, targetShape.width, originalTargetDepth], 'int32');\n}\nexport function renderToGLView(gl, texture, size) {\n  var flipHorizontal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  size = {\n    width: Math.floor(size.width),\n    height: Math.floor(size.height)\n  };\n  drawTexture(gl, texture, size, flipHorizontal);\n}","map":{"version":3,"sources":["../../src/camera/camera.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport { downloadTextureData, drawTexture, runResizeProgram, uploadTextureData } from './camera_webgl_util';\nconst glCapabilities = {\n    canDownloadFromRGBTexture: new WeakMap(),\n    // Has detectGLCapabilities been run on a particular GL context;\n    glCapabilitiesTested: new WeakMap()\n};\n/**\n * Utility function that tests the GL context for capabilities to enable\n * optimizations.\n *\n * For best performance this should be be called once before using the other\n * camera related functions.\n *\n * @doc {heading: 'Media', subheading: 'Camera'}\n */\nexport async function detectGLCapabilities(gl) {\n    if (glCapabilities.glCapabilitiesTested.get(gl)) {\n        return;\n    }\n    // Test whether we can successfully download from an RGB texture.\n    // Notably this isn't supported on iOS, but we use this test rather than a\n    // platform check to be more robust on android devices we may not have\n    // directly tested.\n    // Set this to true temporarily so that fromTexture does not\n    // use its workaround.\n    glCapabilities.canDownloadFromRGBTexture.set(gl, true);\n    try {\n        const height = 2;\n        const width = 4; // This must be a multiple of 4.\n        const data = new Uint8Array(height * width * 4);\n        for (let i = 0; i < data.length; i++) {\n            data[i] = i;\n        }\n        const sourceDims = { height, width, depth: 4 };\n        const tex = uploadTextureData(data, gl, sourceDims);\n        const targetDims = { height, width, depth: 3 };\n        const downloaded = fromTexture(gl, tex, sourceDims, targetDims);\n        const downloadedData = await downloaded.data();\n        tf.dispose(downloaded);\n        const matches = tf.util.arraysEqual(downloadedData, [\n            0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14,\n            16, 17, 18, 20, 21, 22, 24, 25, 26, 28, 29, 30\n        ]);\n        if (matches) {\n            glCapabilities.canDownloadFromRGBTexture.set(gl, true);\n        }\n        else {\n            glCapabilities.canDownloadFromRGBTexture.set(gl, false);\n        }\n    }\n    catch (e) {\n        glCapabilities.canDownloadFromRGBTexture.set(gl, false);\n    }\n    finally {\n        glCapabilities.glCapabilitiesTested.set(gl, true);\n    }\n}\n/**\n * Transfers tensor data to an RGB(A) texture.\n *\n * @param gl the WebGL context that owns the texture.\n * @param imageTensor the tensor to upload\n * @param texture optional the target texture. If none is passed in a new\n *     texture will be created.\n *\n * @doc {heading: 'Media', subheading: 'Camera'}\n */\nexport async function toTexture(gl, imageTensor, texture) {\n    tf.util.assert(imageTensor.dtype === 'int32', () => 'imageTensor must be of type int32');\n    tf.util.assert(imageTensor.rank === 3, () => 'imageTensor must be a Tensor3D');\n    const imageData = Uint8Array.from(await imageTensor.data());\n    const dims = {\n        height: imageTensor.shape[0],\n        width: imageTensor.shape[1],\n        depth: imageTensor.shape[2],\n    };\n    return uploadTextureData(imageData, gl, dims, texture);\n}\n/**\n * Creates a tensor3D from a texture.\n *\n * Allows for resizing the image and dropping the alpha channel from the\n * resulting tensor.\n *\n * Note that if you the output depth is 3 then the output width should be a\n * multiple of 4.\n *\n * @param gl the WebGL context that owns the input texture\n * @param texture the texture to convert into a tensor\n * @param sourceDims source dimensions of input texture (width, height, depth)\n * @param targetShape desired shape of output tensor\n *\n * @doc {heading: 'Media', subheading: 'Camera'}\n */\nexport function fromTexture(gl, texture, sourceDims, targetShape, options = {}) {\n    tf.util.assert(targetShape.depth === 3 || targetShape.depth === 4, () => 'fromTexture Error: target depth must be 3 or 4');\n    if (targetShape.depth === 3 && targetShape.width % 4 !== 0) {\n        // We throw an error here rather than use the CPU workaround as the user is\n        // likely trying to get the maximum performance.\n        if (glCapabilities.canDownloadFromRGBTexture.get(gl)) {\n            // See\n            // https://www.khronos.org/opengl/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n            // for more details. At the moment gl.pixelStorei(gl.PACK_ALIGNMENT, 1);\n            // is not supported on expo. \"EXGL: gl.pixelStorei() doesn't support this\n            // parameter yet!\"\n            throw new Error('When using targetShape.depth=3, targetShape.width must be' +\n                ' a multiple of 4. Alternatively do not call detectGLCapabilities()');\n        }\n    }\n    const originalTargetDepth = targetShape.depth;\n    const targetDepth = glCapabilities.canDownloadFromRGBTexture.get(gl) ?\n        originalTargetDepth :\n        4;\n    sourceDims = {\n        height: Math.floor(sourceDims.height),\n        width: Math.floor(sourceDims.width),\n        depth: sourceDims.depth,\n    };\n    targetShape = {\n        height: Math.floor(targetShape.height),\n        width: Math.floor(targetShape.width),\n        depth: targetDepth\n    };\n    const alignCorners = options.alignCorners != null ? options.alignCorners : false;\n    const interpolation = options.interpolation != null ? options.interpolation : 'bilinear';\n    tf.util.assert(interpolation === 'bilinear' || interpolation === 'nearest_neighbor', () => 'fromTexture Error: interpolation must be one of' +\n        ' \"bilinear\" or \"nearest_neighbor\"');\n    const resizedTexture = runResizeProgram(gl, texture, sourceDims, targetShape, alignCorners, interpolation);\n    const downloadedTextureData = downloadTextureData(gl, resizedTexture, targetShape);\n    let finalTexData;\n    if (originalTargetDepth !== targetDepth && originalTargetDepth === 3) {\n        // We are on a device that does not support downloading from an RGB texture.\n        // Remove the alpha channel values on the CPU.\n        const area = targetShape.height * targetShape.width;\n        finalTexData = new Uint8Array(area * originalTargetDepth);\n        for (let i = 0; i < area; i++) {\n            const flatIndexRGB = i * 3;\n            const flatIndexRGBA = i * 4;\n            finalTexData[flatIndexRGB] = downloadedTextureData[flatIndexRGBA];\n            finalTexData[flatIndexRGB + 1] = downloadedTextureData[flatIndexRGBA + 1];\n            finalTexData[flatIndexRGB + 2] = downloadedTextureData[flatIndexRGBA + 2];\n        }\n    }\n    else {\n        finalTexData = downloadedTextureData;\n    }\n    return tf.tensor3d(finalTexData, [targetShape.height, targetShape.width, originalTargetDepth], 'int32');\n}\n/**\n * Render a texture to the GLView. This will use the default framebuffer\n * and present the contents of the texture on the screen.\n *\n * @param gl\n * @param texture\n * @param dims Dimensions of tensor\n *\n * @doc {heading: 'Media', subheading: 'Camera'}\n */\nexport function renderToGLView(gl, texture, size, flipHorizontal = true) {\n    size = {\n        width: Math.floor(size.width),\n        height: Math.floor(size.height),\n    };\n    drawTexture(gl, texture, size, flipHorizontal);\n}\n//# sourceMappingURL=camera.js.map"]},"metadata":{},"sourceType":"module"}