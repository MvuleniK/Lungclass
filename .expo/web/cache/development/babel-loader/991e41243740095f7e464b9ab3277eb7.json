{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { dispose, io, serialization, util } from '@tensorflow/tfjs-core';\nimport { getUid } from \"./backend/state\";\nimport { Input } from \"./engine/input_layer\";\nimport { getSourceInputs, Node } from \"./engine/topology\";\nimport { LayersModel } from \"./engine/training\";\nimport { NotImplementedError, RuntimeError, ValueError } from \"./errors\";\nimport { deserialize } from \"./layers/serialization\";\nimport * as generic_utils from \"./utils/generic_utils\";\nimport { convertPythonicToTs } from \"./utils/serialization_utils\";\nimport { getExactlyOneShape } from \"./utils/types_utils\";\nexport function modelFromJSON(modelAndWeightsConfig, customObjects) {\n  var modelTopology, tsConfig, model, weightValues, uniqueWeightValues, _iterator, _step, weight;\n\n  return _regeneratorRuntime.async(function modelFromJSON$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!('modelTopology' in modelAndWeightsConfig)) {\n            modelAndWeightsConfig = {\n              modelTopology: modelAndWeightsConfig\n            };\n          }\n\n          modelAndWeightsConfig = modelAndWeightsConfig;\n          modelTopology = modelAndWeightsConfig.modelTopology;\n\n          if (modelTopology['model_config'] != null) {\n            modelTopology = modelTopology['model_config'];\n          }\n\n          tsConfig = convertPythonicToTs(modelTopology);\n          model = deserialize(tsConfig, customObjects);\n\n          if (!(modelAndWeightsConfig.weightsManifest != null)) {\n            _context.next = 14;\n            break;\n          }\n\n          _context.next = 9;\n          return _regeneratorRuntime.awrap(io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(function (weight) {\n            return weight.originalName;\n          })));\n\n        case 9:\n          weightValues = _context.sent;\n          uniqueWeightValues = {};\n\n          for (_iterator = _createForOfIteratorHelperLoose(model.weights); !(_step = _iterator()).done;) {\n            weight = _step.value;\n            uniqueWeightValues[weight.originalName] = weightValues[weight.originalName];\n          }\n\n          model.loadWeights(uniqueWeightValues);\n          dispose(weightValues);\n\n        case 14:\n          return _context.abrupt(\"return\", model);\n\n        case 15:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function loadLayersModelInternal(pathOrIOHandler, options) {\n  var handlers;\n  return _regeneratorRuntime.async(function loadLayersModelInternal$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (options == null) {\n            options = {};\n          }\n\n          if (!(typeof pathOrIOHandler === 'string')) {\n            _context2.next = 10;\n            break;\n          }\n\n          handlers = io.getLoadHandlers(pathOrIOHandler, options);\n\n          if (!(handlers.length === 0)) {\n            _context2.next = 7;\n            break;\n          }\n\n          handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n          _context2.next = 9;\n          break;\n\n        case 7:\n          if (!(handlers.length > 1)) {\n            _context2.next = 9;\n            break;\n          }\n\n          throw new ValueError(\"Found more than one (\" + handlers.length + \") load handlers for \" + (\"URL '\" + pathOrIOHandler + \"'\"));\n\n        case 9:\n          pathOrIOHandler = handlers[0];\n\n        case 10:\n          return _context2.abrupt(\"return\", loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options));\n\n        case 11:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function loadLayersModelFromIOHandler(handler, customObjects, options) {\n  var artifacts, modelTopology, strict, fastWeightInit, model, trainingConfig, _decodeModelAndOptimi, modelWeights, optimizerWeights;\n\n  return _regeneratorRuntime.async(function loadLayersModelFromIOHandler$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          if (options == null) {\n            options = {};\n          }\n\n          if (!(handler.load == null)) {\n            _context3.next = 3;\n            break;\n          }\n\n          throw new ValueError('Cannot proceed with model loading because the IOHandler provided ' + 'does not have the `load` method implemented.');\n\n        case 3:\n          _context3.next = 5;\n          return _regeneratorRuntime.awrap(handler.load());\n\n        case 5:\n          artifacts = _context3.sent;\n          modelTopology = artifacts.modelTopology;\n\n          if (modelTopology['model_config'] != null) {\n            modelTopology = modelTopology['model_config'];\n          }\n\n          strict = options.strict == null ? true : options.strict;\n          fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n          model = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);\n          trainingConfig = artifacts.trainingConfig;\n\n          if (trainingConfig != null) {\n            model.loadTrainingConfig(trainingConfig);\n          }\n\n          if (artifacts.userDefinedMetadata != null) {\n            model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n          }\n\n          if (!(artifacts.weightData != null)) {\n            _context3.next = 24;\n            break;\n          }\n\n          if (!(artifacts.weightSpecs == null)) {\n            _context3.next = 17;\n            break;\n          }\n\n          throw new ValueError('LayersModel artifacts contains weight data, but not weight specs. ' + 'Therefore loading of weights cannot proceed.');\n\n        case 17:\n          _decodeModelAndOptimi = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs), modelWeights = _decodeModelAndOptimi.modelWeights, optimizerWeights = _decodeModelAndOptimi.optimizerWeights;\n          model.loadWeights(modelWeights, strict);\n\n          if (!(model.optimizer != null && optimizerWeights.length > 0)) {\n            _context3.next = 22;\n            break;\n          }\n\n          _context3.next = 22;\n          return _regeneratorRuntime.awrap(model.optimizer.setWeights(optimizerWeights));\n\n        case 22:\n          dispose(modelWeights);\n          dispose(optimizerWeights.map(function (w) {\n            return w.tensor;\n          }));\n\n        case 24:\n          return _context3.abrupt(\"return\", model);\n\n        case 25:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction decodeModelAndOptimizerWeights(buffer, specs) {\n  var name2Tensor = io.decodeWeights(buffer, specs);\n  var modelWeights = {};\n  var optimizerWeights = [];\n  specs.forEach(function (spec) {\n    if (spec.group === 'optimizer') {\n      optimizerWeights.push({\n        name: spec.name,\n        tensor: name2Tensor[spec.name]\n      });\n    } else {\n      modelWeights[spec.name] = name2Tensor[spec.name];\n    }\n  });\n  return {\n    modelWeights: modelWeights,\n    optimizerWeights: optimizerWeights\n  };\n}\n\nexport var Sequential = function (_LayersModel) {\n  _inherits(Sequential, _LayersModel);\n\n  var _super = _createSuper(Sequential);\n\n  function Sequential(args) {\n    var _this;\n\n    _classCallCheck(this, Sequential);\n\n    _this = _super.call(this, {\n      inputs: [],\n      outputs: []\n    });\n    args = args || {};\n    _this.trainable = true;\n    _this.built = false;\n    _this.name = args.name != null ? args.name : getUid('sequential_');\n\n    if (args.layers != null) {\n      for (var _iterator2 = _createForOfIteratorHelperLoose(args.layers), _step2; !(_step2 = _iterator2()).done;) {\n        var layer = _step2.value;\n\n        _this.add(layer);\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(Sequential, [{\n    key: \"checkShape\",\n    value: function checkShape(layer) {\n      var shape = layer.inboundNodes[0].outputTensors[0].shape;\n\n      if (shape.some(function (x) {\n        return x < 0;\n      })) {\n        throw new ValueError('Negative dimension size caused by adding layer ' + (layer.name + \" with input shape [\") + (layer.inboundNodes[0].inputTensors[0].shape + \"]\"));\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(layer) {\n      var isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;\n      var modelLayer;\n\n      if (isLayerModelInstance) {\n        modelLayer = layer;\n\n        if (modelLayer.outputs.length !== 1) {\n          throw new ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n        }\n\n        if (modelLayer.inputs.length !== 1) {\n          throw new ValueError('All layers in a Sequential model ' + 'should have a single input tensor. ' + 'For multi-input layers, ' + 'use the functional API.');\n        }\n      }\n\n      if (this.outputs.length === 0) {\n        if (layer.inboundNodes.length === 0) {\n          if (layer.batchInputShape == null) {\n            throw new ValueError('The first layer in a Sequential model must ' + 'get an `inputShape` or `batchInputShape` argument.');\n          }\n\n          var x = Input({\n            batchShape: layer.batchInputShape,\n            dtype: layer.dtype,\n            name: layer.name + '_input'\n          });\n          layer.apply(x);\n        }\n\n        if (isLayerModelInstance) {\n          this.outputs = modelLayer.outputs;\n          this.inputs = modelLayer.inputs;\n        } else {\n          if (layer.inboundNodes.length !== 1) {\n            throw new ValueError('A layer added to a Sequential model must not already be ' + (\"connected somewhere else. LayersModel received layer \" + layer.name + \" \") + (\"which has \" + layer.inboundNodes.length + \" pre-existing inbound \") + 'connections.');\n          }\n\n          if (layer.inboundNodes[0].outputTensors.length !== 1) {\n            throw new ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n          }\n\n          this.checkShape(layer);\n          this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n          this.inputs = getSourceInputs(this.outputs[0]);\n        }\n\n        this.inboundNodes = [];\n        new Node({\n          outboundLayer: this,\n          inboundLayers: [],\n          nodeIndices: [],\n          tensorIndices: [],\n          inputTensors: this.inputs,\n          outputTensors: this.outputs,\n          inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n          outputMasks: [null],\n          inputShapes: this.inputs.map(function (x) {\n            return x.shape;\n          }),\n          outputShapes: this.outputs[0].shape\n        });\n      } else {\n        var outputTensor = layer.apply(this.outputs[0]);\n\n        if (Array.isArray(outputTensor)) {\n          throw new TypeError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n        }\n\n        this.checkShape(layer);\n        this.outputs = [outputTensor];\n        this.inboundNodes[0].outputTensors = this.outputs;\n        this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n      }\n\n      this.layers.push(layer);\n      this.built = false;\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      if (this.layers.length === 0) {\n        throw new TypeError('There are no layers in the model.');\n      }\n\n      this.layers.pop();\n\n      if (this.layers.length === 0) {\n        this.outputs = [];\n        this.inboundNodes = [];\n        this.outboundNodes = [];\n      } else {\n        var lastLayerIndex = this.layers.length - 1;\n        this.layers[lastLayerIndex].outboundNodes = [];\n        this.outputs = [this.layers[lastLayerIndex].output];\n        this.inboundNodes[0].outputTensors = this.outputs;\n        this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n      }\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      if (this.model == null) {\n        this.build();\n      }\n\n      return this.model.call(inputs, kwargs);\n    }\n  }, {\n    key: \"build\",\n    value: function build(inputShape) {\n      getExactlyOneShape(inputShape);\n\n      if (this.inputs.length === 0 || this.outputs.length === 0) {\n        throw new TypeError('Sequential model cannot be built: model is empty.' + ' Add some layers first.');\n      }\n\n      this.model = new LayersModel({\n        inputs: this.inputs,\n        outputs: this.outputs[0],\n        name: this.name + '_model'\n      });\n      this.model.trainable = this.trainable;\n      this.supportsMasking = this.model.supportsMasking;\n      this.inputLayers = this.model.inputLayers;\n      this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n      this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n      this.outputLayers = this.model.outputLayers;\n      this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n      this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n      this.nodesByDepth = this.model.nodesByDepth;\n      this.containerNodes = this.model.containerNodes;\n      this.outputNames = this.model.outputNames;\n      this.inputNames = this.model.inputNames;\n      this.built = true;\n    }\n  }, {\n    key: \"countParams\",\n    value: function countParams() {\n      if (!this.built) {\n        this.build();\n      }\n\n      return _get(_getPrototypeOf(Sequential.prototype), \"countParams\", this).call(this);\n    }\n  }, {\n    key: \"summary\",\n    value: function summary(lineLength, positions) {\n      var printFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;\n\n      if (!this.built) {\n        this.build();\n      }\n\n      _get(_getPrototypeOf(Sequential.prototype), \"summary\", this).call(this, lineLength, positions, printFn);\n    }\n  }, {\n    key: \"setWeights\",\n    value: function setWeights(weights) {\n      if (this.model == null) {\n        this.build();\n      }\n\n      this.model.setWeights(weights);\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(x, y) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!this.built) {\n        throw new RuntimeError('The model needs to be compiled before being used.');\n      }\n\n      return this.model.evaluate(x, y, args);\n    }\n  }, {\n    key: \"evaluateDataset\",\n    value: function evaluateDataset(dataset, args) {\n      return _regeneratorRuntime.async(function evaluateDataset$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (this.built) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw new RuntimeError('The model needs to be compiled before being used.');\n\n            case 2:\n              return _context4.abrupt(\"return\", this.model.evaluateDataset(dataset, args));\n\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"predict\",\n    value: function predict(x) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.model == null) {\n        this.build();\n      }\n\n      return this.model.predict(x, args);\n    }\n  }, {\n    key: \"predictOnBatch\",\n    value: function predictOnBatch(x) {\n      if (this.model == null) {\n        this.build();\n      }\n\n      return this.model.predictOnBatch(x);\n    }\n  }, {\n    key: \"compile\",\n    value: function compile(args) {\n      this.build();\n      this.model.compile(args);\n      this.optimizer_ = this.model.optimizer;\n      this.isOptimizerOwned = this.model.isOptimizerOwned;\n      this.loss = this.model.loss;\n      this.metrics = this.model.metrics;\n      this.metricsTensors = this.model.metricsTensors;\n      this.metricsNames = this.model.metricsNames;\n    }\n  }, {\n    key: \"optimizer\",\n    get: function get() {\n      return this.model == null ? undefined : this.model.optimizer;\n    },\n    set: function set(optimizer) {\n      this.model.optimizer = optimizer;\n    }\n  }, {\n    key: \"fit\",\n    value: function fit(x, y) {\n      var args,\n          _args5 = arguments;\n      return _regeneratorRuntime.async(function fit$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              args = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};\n\n              if (this.built) {\n                _context5.next = 3;\n                break;\n              }\n\n              throw new RuntimeError('The model needs to be compiled before ' + 'being used.');\n\n            case 3:\n              return _context5.abrupt(\"return\", this.model.fit(x, y, args));\n\n            case 4:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"fitDataset\",\n    value: function fitDataset(dataset, args) {\n      return _regeneratorRuntime.async(function fitDataset$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (this.built) {\n                _context6.next = 2;\n                break;\n              }\n\n              throw new RuntimeError('The model needs to be compiled before ' + 'being used.');\n\n            case 2:\n              return _context6.abrupt(\"return\", this.model.fitDataset(dataset, args));\n\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"trainOnBatch\",\n    value: function trainOnBatch(x, y) {\n      return _regeneratorRuntime.async(function trainOnBatch$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              return _context7.abrupt(\"return\", this.model.trainOnBatch(x, y));\n\n            case 1:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"stopTraining\",\n    get: function get() {\n      if (this.model == null) {\n        throw new ValueError('Cannot get the stopTraining property of a sequential model before ' + 'it is compiled.');\n      }\n\n      return this.model.stopTraining;\n    },\n    set: function set(stop) {\n      if (this.model == null) {\n        throw new ValueError('Cannot set the stopTraining property of a sequential model before ' + 'it is compiled.');\n      }\n\n      this.model.stopTraining = stop;\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var layers = [];\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(this.layers), _step3; !(_step3 = _iterator3()).done;) {\n        var layer = _step3.value;\n        var dict = {};\n        dict['className'] = layer.getClassName();\n        dict['config'] = layer.getConfig();\n        layers.push(dict);\n      }\n\n      return {\n        name: this.name,\n        layers: layers\n      };\n    }\n  }], [{\n    key: \"fromConfig\",\n    value: function fromConfig(cls, config) {\n      var customObjects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fastWeightInit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var configArray;\n      var extraModelConfig = {};\n\n      if (config instanceof Array) {\n        if (!(config[0].className != null) || config[0]['className'] === 'Merge') {\n          throw new ValueError('Legacy serialization format not supported yet.');\n        }\n\n        configArray = config;\n      } else {\n        util.assert(config['layers'] != null, function () {\n          return \"When the config data for a Sequential model is not an Array, \" + \"it must be an Object that contains the 'layers' field.\";\n        });\n        configArray = config['layers'];\n        delete config['layers'];\n        extraModelConfig = config;\n      }\n\n      var model = new cls(extraModelConfig);\n\n      if (!(model instanceof Sequential)) {\n        throw new NotImplementedError(\"Sequential.fromConfig called on non-Sequential input: \" + model);\n      }\n\n      for (var _iterator4 = _createForOfIteratorHelperLoose(configArray), _step4; !(_step4 = _iterator4()).done;) {\n        var conf = _step4.value;\n        var _customObjects = undefined;\n        var layer = deserialize(conf, _customObjects, fastWeightInit);\n\n        if (fastWeightInit) {\n          layer.setFastWeightInitDuringBuild(true);\n        }\n\n        model.add(layer);\n      }\n\n      return model;\n    }\n  }]);\n\n  return Sequential;\n}(LayersModel);\nSequential.className = 'Sequential';\nserialization.registerClass(Sequential);","map":{"version":3,"sources":["../src/models.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source keras/models.py */\nimport { dispose, io, serialization, util } from '@tensorflow/tfjs-core';\nimport { getUid } from './backend/state';\nimport { Input } from './engine/input_layer';\nimport { getSourceInputs, Node } from './engine/topology';\nimport { LayersModel } from './engine/training';\nimport { NotImplementedError, RuntimeError, ValueError } from './errors';\nimport { deserialize } from './layers/serialization';\nimport * as generic_utils from './utils/generic_utils';\nimport { convertPythonicToTs } from './utils/serialization_utils';\nimport { getExactlyOneShape } from './utils/types_utils';\n/**\n * Parses a JSON model configuration file and returns a model instance.\n *\n * ```js\n * // This example shows how to serialize a model using `toJSON()` and\n * // deserialize it as another model using `tf.models.modelFromJSON()`.\n * // Note: this example serializes and deserializes only the topology\n * // of the model; the weights of the loaded model will be different\n * // from those of the the original model, due to random weight\n * // initialization.\n * // To load the topology and weights of a model, use `tf.loadLayersModel()`.\n * const model1 = tf.sequential();\n * model1.add(tf.layers.repeatVector({inputShape: [2], n: 4}));\n * // Serialize `model1` as a JSON object.\n * const model1JSON = model1.toJSON(null, false);\n * model1.summary();\n *\n * const model2 = await tf.models.modelFromJSON(model1JSON);\n * model2.summary();\n * ```\n *\n *  @param modelAndWeightsConfig JSON object or string encoding a model and\n *       weights configuration. It can also be only the topology JSON of the\n *       model, in which case the weights will not be loaded.\n *  @param custom_objects Optional dictionary mapping names\n *       (strings) to custom classes or functions to be\n *       considered during deserialization.\n * @returns A TensorFlow.js Layers `tf.LayersModel` instance (uncompiled).\n */\nexport async function modelFromJSON(modelAndWeightsConfig, customObjects) {\n    if (!('modelTopology' in modelAndWeightsConfig)) {\n        modelAndWeightsConfig = { modelTopology: modelAndWeightsConfig };\n    }\n    modelAndWeightsConfig = modelAndWeightsConfig;\n    let modelTopology = modelAndWeightsConfig.modelTopology;\n    if (modelTopology['model_config'] != null) {\n        // If the model-topology JSON contains a 'model_config' field, then it is\n        // a full model JSON (e.g., from `keras.Model.save()`), which contains\n        // not only the model's architecture in its 'model_config' field, but\n        // additional information such as the model's optimizer. We use only the\n        // 'model_config' field currently.\n        modelTopology = modelTopology['model_config'];\n    }\n    const tsConfig = convertPythonicToTs(modelTopology);\n    const model = deserialize(tsConfig, customObjects);\n    if (modelAndWeightsConfig.weightsManifest != null) {\n        // Load the weight values keyed by the original tensor names in the model\n        // file that was loaded.  These should match the keys of the weight\n        // manifest.\n        const weightValues = await io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(weight => weight.originalName));\n        // Map the weights to the unique tensor names generated during model loading\n        const uniqueWeightValues = {};\n        for (const weight of model.weights) {\n            uniqueWeightValues[weight.originalName] =\n                weightValues[weight.originalName];\n        }\n        model.loadWeights(uniqueWeightValues);\n        // Dispose temporary weight values.\n        dispose(weightValues);\n    }\n    return model;\n}\n/**\n * Load a model, including its topology and optionally weights.  See the\n * Tutorial named \"How to import a Keras Model\" for usage examples.\n *\n * Example 1: Save `model`'s topology and weights to browser [local\n * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('localstorage://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 2. Saving `model`'s topology and weights to browser\n * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('indexeddb://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 3. Load a model from user-selected files from HTML\n * [file input\n * elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n *\n * ```js\n * // Note: this code snippet will not work without the HTML elements in the\n * //   page\n * const jsonUpload = document.getElementById('json-upload');\n * const weightsUpload = document.getElementById('weights-upload');\n *\n * const model = await tf.loadLayersModel(\n *     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n * ```\n *\n * Example 4. Load a model from an HTTP server.\n *\n * ```js\n * const model = await\n *     tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\n * model.summary();\n * ```\n *\n * @param pathOrIOHandler Can be either of the two formats\n *   1. A string path to the `ModelAndWeightsConfig` JSON describing\n *      the model in the canonical TensorFlow.js format. This path will be\n *      interpreted as a relative HTTP path, to which `fetch` will be used to\n *      request the model topology and weight manifest JSON.\n *      The content of the JSON file is assumed to be a JSON object with the\n *      following fields and values:\n *      - 'modelTopology': A JSON object that can be either of:\n *        1. a model architecture JSON consistent with the format of the return\n *            value of `keras.Model.to_json()`\n *        2. a full model JSON in the format of `keras.models.save_model()`.\n *      - 'weightsManifest': A TensorFlow.js weights manifest.\n *      See the Python converter function `save_model()` for more details.\n *      It is also assumed that model weights can be accessed from relative\n *      paths described by the `paths` fields in weights manifest.\n *   2. An `tf.io.IOHandler` object that loads model artifacts with its `load`\n *      method.\n * @param options Optional configuration arguments for the model loading,\n *   including:\n *   - `strict`: Require that the provided weights exactly match those required\n *     by the layers.  Default true.  Passing false means that both extra\n *     weights and missing weights will be silently ignored.\n *   - `onProgress`: A progress callback of the form:\n *     `(fraction: number) => void`. This callback can be used to monitor the\n *     model-loading process.\n * @returns A `Promise` of `tf.LayersModel`, with the topology and weights\n *     loaded.\n */\nexport async function loadLayersModelInternal(pathOrIOHandler, options) {\n    if (options == null) {\n        options = {};\n    }\n    if (typeof pathOrIOHandler === 'string') {\n        const handlers = io.getLoadHandlers(pathOrIOHandler, options);\n        if (handlers.length === 0) {\n            // For backward compatibility: if no load handler can be found,\n            // assume it is a relative http path.\n            // TODO(cais): Reformat the args into a single `LoadOptions` once the core\n            // is refactored.\n            handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n        }\n        else if (handlers.length > 1) {\n            throw new ValueError(`Found more than one (${handlers.length}) load handlers for ` +\n                `URL '${pathOrIOHandler}'`);\n        }\n        pathOrIOHandler = handlers[0];\n    }\n    return loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options);\n}\n/**\n * Load a model and optionally its weights, using an IOHandler object.\n *\n * @param handler The instance of `IOHandler` to be used during the model\n *   loading.\n * @param customObjects Any optional custom objects to be used during model\n *   loading.\n * @param strict Whether the weight loading will be done in strict mode.\n *   Default: `true`.\n */\nexport async function loadLayersModelFromIOHandler(handler, customObjects, options) {\n    if (options == null) {\n        options = {};\n    }\n    if (handler.load == null) {\n        throw new ValueError('Cannot proceed with model loading because the IOHandler provided ' +\n            'does not have the `load` method implemented.');\n    }\n    const artifacts = await handler.load();\n    let modelTopology = artifacts.modelTopology;\n    if (modelTopology['model_config'] != null) {\n        modelTopology = modelTopology['model_config'];\n    }\n    const strict = options.strict == null ? true : options.strict;\n    // If weights are provided and the weight-loading mode is strict, use\n    // fast weight initialization. This skips costly initializers such as\n    // 'orthogonal' and saves unnecessary computation in cases where\n    // the initialized weight values will immediately be overwritten by\n    // loaded weight values.\n    const fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n    const model = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);\n    const trainingConfig = artifacts.trainingConfig;\n    if (trainingConfig != null) {\n        model.loadTrainingConfig(trainingConfig);\n    }\n    if (artifacts.userDefinedMetadata != null) {\n        model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n    }\n    // If weightData is present, load the weights into the model.\n    if (artifacts.weightData != null) {\n        // Loading weights requires weightSpecs.\n        if (artifacts.weightSpecs == null) {\n            throw new ValueError('LayersModel artifacts contains weight data, but not weight specs. ' +\n                'Therefore loading of weights cannot proceed.');\n        }\n        const { modelWeights, optimizerWeights } = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs);\n        model.loadWeights(modelWeights, strict);\n        if (model.optimizer != null && optimizerWeights.length > 0) {\n            await model.optimizer.setWeights(optimizerWeights);\n        }\n        // Dispose temporary weight values.\n        dispose(modelWeights);\n        dispose(optimizerWeights.map(w => w.tensor));\n    }\n    return model;\n}\nfunction decodeModelAndOptimizerWeights(buffer, specs) {\n    const name2Tensor = io.decodeWeights(buffer, specs);\n    const modelWeights = {};\n    const optimizerWeights = [];\n    specs.forEach(spec => {\n        if (spec.group === 'optimizer') {\n            optimizerWeights.push({ name: spec.name, tensor: name2Tensor[spec.name] });\n        }\n        else {\n            modelWeights[spec.name] = name2Tensor[spec.name];\n        }\n    });\n    return { modelWeights, optimizerWeights };\n}\n/**\n * A model with a stack of layers, feeding linearly from one to the next.\n *\n * `tf.sequential` is a factory function that creates an instance of\n * `tf.Sequential`.\n *\n * ```js\n *  // Define a model for linear regression.\n *  const model = tf.sequential();\n *  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n *\n *  // Prepare the model for training: Specify the loss and the optimizer.\n *  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *  // Generate some synthetic data for training.\n *  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n *  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n *\n *  // Train the model using the data then do inference on a data point the\n *  // model hasn't seen:\n *  await model.fit(xs, ys);\n *  model.predict(tf.tensor2d([5], [1, 1])).print();\n * ```\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\nexport class Sequential extends LayersModel {\n    constructor(args) {\n        super({ inputs: [], outputs: [] });\n        args = args || {};\n        this.trainable = true;\n        this.built = false;\n        // Set model name.\n        this.name = (args.name != null) ? args.name : getUid('sequential_');\n        // Add to the model any layers passed to the constructor.\n        if (args.layers != null) {\n            for (const layer of args.layers) {\n                this.add(layer);\n            }\n        }\n    }\n    // Helper function to Sequential.add  Throws if the new output shape will be\n    // invalid.\n    checkShape(layer) {\n        const shape = layer.inboundNodes[0].outputTensors[0].shape;\n        if (shape.some(x => x < 0)) {\n            throw new ValueError('Negative dimension size caused by adding layer ' +\n                `${layer.name} with input shape [` +\n                `${layer.inboundNodes[0].inputTensors[0].shape}]`);\n        }\n    }\n    /**\n     * Adds a layer instance on top of the layer stack.\n     *\n     * ```js\n     *  const model = tf.sequential();\n     *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n     *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n     *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n     *  // Note that the untrained model is random at this point.\n     *  model.predict(tf.randomNormal([10, 1])).print();\n     * ```\n     * @param layer Layer instance.\n     *\n     * @exception ValueError In case the `layer` argument does not know its\n     * input shape.\n     * @exception ValueError In case the `layer` argument has multiple output\n     *   tensors, or is already connected somewhere else (forbidden in\n     *   `Sequential` models).\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    add(layer) {\n        const isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;\n        let modelLayer;\n        if (isLayerModelInstance) {\n            modelLayer = layer;\n            if (modelLayer.outputs.length !== 1) {\n                throw new ValueError('All layers in a Sequential model ' +\n                    'should have a single output tensor. ' +\n                    'For multi-output layers, ' +\n                    'use the functional API.');\n            }\n            if (modelLayer.inputs.length !== 1) {\n                throw new ValueError('All layers in a Sequential model ' +\n                    'should have a single input tensor. ' +\n                    'For multi-input layers, ' +\n                    'use the functional API.');\n            }\n        }\n        if (this.outputs.length === 0) {\n            // first layer in model: check that it is an input layer\n            if (layer.inboundNodes.length === 0) {\n                // create an input layer\n                if (layer.batchInputShape == null) {\n                    throw new ValueError('The first layer in a Sequential model must ' +\n                        'get an `inputShape` or `batchInputShape` argument.');\n                }\n                // Instantiate the input layer.\n                const x = Input({\n                    batchShape: layer.batchInputShape,\n                    dtype: layer.dtype,\n                    name: layer.name + '_input'\n                });\n                // This will build the current layer and create the node connecting\n                // the current layer to the input layer we just created.\n                layer.apply(x);\n            }\n            if (isLayerModelInstance) {\n                this.outputs = modelLayer.outputs;\n                this.inputs = modelLayer.inputs;\n            }\n            else {\n                if (layer.inboundNodes.length !== 1) {\n                    throw new ValueError('A layer added to a Sequential model must not already be ' +\n                        `connected somewhere else. LayersModel received layer ${layer.name} ` +\n                        `which has ${layer.inboundNodes.length} pre-existing inbound ` +\n                        'connections.');\n                }\n                if (layer.inboundNodes[0].outputTensors.length !== 1) {\n                    throw new ValueError('All layers in a Sequential model ' +\n                        'should have a single output tensor. ' +\n                        'For multi-output layers, ' +\n                        'use the functional API.');\n                }\n                this.checkShape(layer);\n                this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n                this.inputs = getSourceInputs(this.outputs[0]);\n            }\n            this.inboundNodes = [];\n            // We create an input node, which we will keep updated\n            // as we add more layers.\n            // (This call has side effects.)\n            // tslint:disable-next-line:no-unused-expression\n            new Node({\n                outboundLayer: this,\n                inboundLayers: [],\n                nodeIndices: [],\n                tensorIndices: [],\n                inputTensors: this.inputs,\n                outputTensors: this.outputs,\n                // no model-level masking for now\n                inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n                outputMasks: [null],\n                inputShapes: this.inputs.map(x => x.shape),\n                outputShapes: this.outputs[0].shape\n            });\n        }\n        else {\n            const outputTensor = layer.apply(this.outputs[0]);\n            if (Array.isArray(outputTensor)) {\n                throw new TypeError('All layers in a Sequential model ' +\n                    'should have a single output tensor. ' +\n                    'For multi-output layers, ' +\n                    'use the functional API.');\n            }\n            this.checkShape(layer);\n            this.outputs = [outputTensor];\n            // update self.inbound_nodes\n            this.inboundNodes[0].outputTensors = this.outputs;\n            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n        }\n        this.layers.push(layer);\n        this.built = false;\n    }\n    /**\n     * Removes the last layer in the model.\n     *\n     * @exception TypeError if there are no layers in the model.\n     */\n    pop() {\n        if (this.layers.length === 0) {\n            throw new TypeError('There are no layers in the model.');\n        }\n        this.layers.pop();\n        if (this.layers.length === 0) {\n            this.outputs = [];\n            this.inboundNodes = [];\n            this.outboundNodes = [];\n        }\n        else {\n            const lastLayerIndex = this.layers.length - 1;\n            this.layers[lastLayerIndex].outboundNodes = [];\n            this.outputs = [this.layers[lastLayerIndex].output];\n            // update self.inbound_nodes\n            this.inboundNodes[0].outputTensors = this.outputs;\n            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n        }\n    }\n    call(inputs, kwargs) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.call(inputs, kwargs);\n    }\n    build(inputShape) {\n        // Call `getExactlyOneShape` without using its return value,\n        // to verify that exactly one input shape is provided.\n        getExactlyOneShape(inputShape);\n        if (this.inputs.length === 0 || this.outputs.length === 0) {\n            throw new TypeError('Sequential model cannot be built: model is empty.' +\n                ' Add some layers first.');\n        }\n        // actually create the model\n        this.model = new LayersModel({\n            inputs: this.inputs,\n            outputs: this.outputs[0],\n            name: this.name + '_model'\n        });\n        this.model.trainable = this.trainable;\n        // mirror model attributes\n        this.supportsMasking = this.model.supportsMasking;\n        // TODO(michaelterry): Add caches\n        this.inputLayers = this.model.inputLayers;\n        this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n        this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n        this.outputLayers = this.model.outputLayers;\n        this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n        this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n        this.nodesByDepth = this.model.nodesByDepth;\n        this.containerNodes = this.model.containerNodes;\n        this.outputNames = this.model.outputNames;\n        this.inputNames = this.model.inputNames;\n        // TODO(michaelterry): Add feedInputNames, feedInputs, if needed.\n        // TODO(michaelterry): Add callbackModel if needed.\n        this.built = true;\n    }\n    countParams() {\n        if (!this.built) {\n            this.build();\n        }\n        return super.countParams();\n    }\n    /**\n     * Print a text summary of the Sequential model's layers.\n     *\n     * The summary includes\n     * - Name and type of all layers that comprise the model.\n     * - Output shape(s) of the layers\n     * - Number of weight parameters of each layer\n     * - The total number of trainable and non-trainable parameters of the\n     * model.\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(\n     *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));\n     * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\n     *\n     * model.summary();\n     * ```\n     *\n     * @param lineLength Custom line length, in number of characters.\n     * @param positions Custom widths of each of the columns, as either\n     *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n     *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n     *   right-most (i.e., ending) position of a column.\n     * @param printFn Custom print function. Can be used to replace the default\n     *   `console.log`. For example, you can use `x => {}` to mute the printed\n     *   messages in the console.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    summary(lineLength, positions, printFn = console.log) {\n        if (!this.built) {\n            this.build();\n        }\n        super.summary(lineLength, positions, printFn);\n    }\n    /**\n     * Sets the weights of the model.\n     *\n     * @param weights Should be a list of Tensors with shapes and types matching\n     *   the output of `model.getWeights()`.\n     */\n    setWeights(weights) {\n        if (this.model == null) {\n            this.build();\n        }\n        this.model.setWeights(weights);\n    }\n    /**\n     * Returns the loss value & metrics values for the model in test mode.\n     *\n     * Loss and metrics are specified during `compile()`, which needs to happen\n     * before calls to `evaluate()`.\n     *\n     * Computation is done in batches.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     * });\n     * result.print();\n     * ```\n     *\n     * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple inputs.\n     * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple outputs.\n     * @param args A `ModelEvaluateConfig`, containing optional fields.\n     *\n     * @return `Scalar` test loss (if the model has a single output and no\n     *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n     *   and/or metrics). The attribute `model.metricsNames`\n     *   will give you the display labels for the scalar outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    evaluate(x, y, args = {}) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before being used.');\n        }\n        return this.model.evaluate(x, y, args);\n    }\n    // TODO(cais): Add code snippet below once real dataset objects are\n    //   available.\n    /**\n     * Evaluate model using a dataset object.\n     *\n     * Note: Unlike `evaluate()`, this method is asynchronous (`async`);\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected\n     *   to generate a dataset iterator object, the `next()` method of which\n     *   is expected to produce data batches for evaluation. The return value\n     *   of the `next()` call ought to contain a boolean `done` field and a\n     *   `value` field. The `value` field is expected to be an array of two\n     *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n     *   case is for models with exactly one input and one output (e.g..\n     *   a sequential model). The latter case is for models with multiple\n     *   inputs and/or multiple outputs. Of the two items in the array, the\n     *   first is the input feature(s) and the second is the output target(s).\n     * @param args A configuration object for the dataset-based evaluation.\n     * @returns Loss and metric values as an Array of `Scalar` objects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async evaluateDataset(dataset, args) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before being used.');\n        }\n        return this.model.evaluateDataset(dataset, args);\n    }\n    /**\n     * Generates output predictions for the input samples.\n     *\n     * Computation is done in batches.\n     *\n     * Note: the \"step\" mode of predict() is currently not supported.\n     *   This is because the TensorFow.js core backend is imperative only.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.predict(tf.ones([2, 10])).print();\n     * ```\n     *\n     * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n     *   the model has multiple inputs.\n     * @param conifg A `ModelPredictConfig` object containing optional fields.\n     *\n     * @return `tf.Tensor`(s) of predictions.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and the model's expectations, or in case a stateful model receives a\n     *   number of samples that is not a multiple of the batch size.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    predict(x, args = {}) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.predict(x, args);\n    }\n    /**\n     * Returns predictions for a single batch of samples.\n     *\n     * @param x: Input samples, as a Tensor, or list of Tensors (if the model\n     *   has multiple inputs).\n     * @return Tensor(s) of predictions\n     */\n    predictOnBatch(x) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.predictOnBatch(x);\n    }\n    /**\n     * See `LayersModel.compile`.\n     *\n     * @param args\n     */\n    compile(args) {\n        this.build();\n        this.model.compile(args);\n        this.optimizer_ = this.model.optimizer;\n        // tslint:disable-next-line:no-any\n        this.isOptimizerOwned = this.model.isOptimizerOwned;\n        this.loss = this.model.loss;\n        this.metrics = this.model.metrics;\n        // TODO(cais): Add this.lossWeights, this.sampleWeightMode,\n        //   this.weightedMetrics, this.targets.\n        this.metricsTensors = this.model.metricsTensors;\n        this.metricsNames = this.model.metricsNames;\n        // TODO(cais): Add sampleWeights.\n    }\n    get optimizer() {\n        return this.model == null ? undefined : this.model.optimizer;\n    }\n    set optimizer(optimizer) {\n        this.model.optimizer = optimizer;\n    }\n    /**\n     * Trains the model for a fixed number of epochs (iterations on a dataset).\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     *   epochs: 3\n     * });\n     * console.log(history.history.loss[0]);\n     * ```\n     *\n     * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n     * model has multiple inputs. If all inputs in the model are named, you can\n     * also pass a dictionary mapping input names to `tf.Tensor`s.\n     * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n     * the model has multiple outputs. If all outputs in the model are named, you\n     *  can also pass a dictionary mapping output names to `tf.Tensor`s.\n     * @param args  A `ModelFitConfig`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and what the model expects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async fit(x, y, args = {}) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before ' +\n                'being used.');\n        }\n        return this.model.fit(x, y, args);\n    }\n    /**\n     * Trains the model using a dataset object.\n     *\n     * ```js\n     * const xArray = [\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     * ];\n     * const yArray = [1, 1, 1, 1];\n     * // Create a dataset from the JavaScript array.\n     * const xDataset = tf.data.array(xArray);\n     * const yDataset = tf.data.array(yArray);\n     * // Zip combines the `x` and `y` Datasets into a single Dataset, the\n     * // iterator of which will return an object containing of two tensors,\n     * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle\n     * // four such samples into a single object, with the same keys now pointing\n     * // to tensors that hold 4 examples, organized along the batch dimension.\n     * // The call to `shuffle(4)` causes each iteration through the dataset to\n     * // happen in a different order.  The size of the shuffle window is 4.\n     * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})\n     *     .batch(4)\n     *     .shuffle(4);\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fitDataset(xyDataset, {\n     *   epochs: 4,\n     *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}\n     * });\n     * ```\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected to\n     *   generate a dataset iterator object, the `next()` method of which is\n     *   expected to produce data batches for evaluation. The return value of the\n     *   `next()` call ought to contain a boolean `done` field and a `value`\n     *   field.\n     *\n     *   The `value` field is expected to be an object of with fields\n     *   `xs` and `ys`, which point to the feature tensor and the target tensor,\n     *   respectively. This case is for models with exactly one input and one\n     *   output (e.g.. a sequential model). For example:\n     *   ```js\n     *   {value: {xs: xsTensor, ys: ysTensor}, done: false}\n     *   ```\n     *\n     *   If the model has multiple inputs, the `xs` field of `value` should\n     *   be an object mapping input names to their respective feature tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: {\n     *         input_1: xsTensor1,\n     *         input_2: xsTensor2\n     *       },\n     *       ys: ysTensor\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     *   If the model has multiple outputs, the `ys` field of `value` should\n     *   be an object mapping output names to their respective target tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: xsTensor,\n     *       ys: {\n     *         output_1: ysTensor1,\n     *         output_2: ysTensor2\n     *       },\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     * @param args A `ModelFitDatasetArgs`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n     */\n    async fitDataset(dataset, args) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before ' +\n                'being used.');\n        }\n        return this.model.fitDataset(dataset, args);\n    }\n    /**\n     * Runs a single gradient update on a single batch of data.\n     *\n     * This method differs from `fit()` and `fitDataset()` in the following\n     * regards:\n     *   - It operates on exactly one batch of data.\n     *   - It returns only the loss and matric values, instead of\n     *     returning the batch-by-batch loss and metric values.\n     *   - It doesn't support fine-grained options such as verbosity and\n     *     callbacks.\n     *\n     * @param x Input data. It could be one of the following:\n     *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n     *     multiple inputs).\n     *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n     *     model has named inputs).\n     * @param y Target darta. It could be either a `tf.Tensor` a multiple\n     *   `tf.Tensor`s. It should be consistent with `x`.\n     * @returns Training loss or losses (in case the model has\n     *   multiple outputs), along with metrics (if any), as numbers.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async trainOnBatch(x, y) {\n        return this.model.trainOnBatch(x, y);\n    }\n    /* See parent class for JsDoc */\n    /** @nocollapse */\n    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {\n        let configArray;\n        let extraModelConfig = {};\n        if (config instanceof Array) {\n            if (!(config[0].className != null) ||\n                config[0]['className'] === 'Merge') {\n                throw new ValueError('Legacy serialization format not supported yet.');\n            }\n            configArray = config;\n        }\n        else {\n            util.assert(config['layers'] != null, () => `When the config data for a Sequential model is not an Array, ` +\n                `it must be an Object that contains the 'layers' field.`);\n            configArray = config['layers'];\n            delete config['layers'];\n            extraModelConfig = config;\n        }\n        const model = new cls(extraModelConfig);\n        if (!(model instanceof Sequential)) {\n            throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model}`);\n        }\n        for (const conf of configArray) {\n            const customObjects = undefined;\n            const layer = deserialize(conf, customObjects, fastWeightInit);\n            if (fastWeightInit) {\n                layer.setFastWeightInitDuringBuild(true);\n            }\n            model.add(layer);\n        }\n        return model;\n    }\n    /**\n     * Setter used for force stopping of LayersModel.fit() (i.e., training).\n     *\n     * Example:\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(tf.layers.dense({units: 1, inputShape: [10]}));\n     * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n     * const xs = tf.ones([8, 10]);\n     * const ys = tf.zeros([8, 1]);\n     *\n     * const history = await model.fit(xs, ys, {\n     *   epochs: 10,\n     *   callbacks: {\n     *     onEpochEnd: async (epoch, logs) => {\n     *       if (epoch === 2) {\n     *         model.stopTraining = true;\n     *       }\n     *     }\n     *   }\n     * });\n     *\n     * // There should be only 3 values in the loss array, instead of 10 values,\n     * // due to the stopping after 3 epochs.\n     * console.log(history.history.loss);\n     * ```\n     */\n    set stopTraining(stop) {\n        // TODO(cais): When refactoring to remove the composition pattern happens,\n        // remove this method overriding.\n        if (this.model == null) {\n            throw new ValueError('Cannot set the stopTraining property of a sequential model before ' +\n                'it is compiled.');\n        }\n        this.model.stopTraining = stop;\n    }\n    get stopTraining() {\n        if (this.model == null) {\n            throw new ValueError('Cannot get the stopTraining property of a sequential model before ' +\n                'it is compiled.');\n        }\n        return this.model.stopTraining;\n    }\n    // TODO(cais): Override get trainableWeights() here\n    // tslint:disable-next-line:no-any\n    getConfig() {\n        // NOTE(cais): We override the return type of getConfig() to `any` here,\n        //   because the `Sequential` class is a special case among `Container`\n        //   subtypes in that its getConfig() method returns an Array (not a\n        //   dict).\n        const layers = [];\n        for (const layer of this.layers) {\n            const dict = {};\n            dict['className'] = layer.getClassName();\n            dict['config'] = layer.getConfig();\n            layers.push(dict);\n        }\n        return { name: this.name, layers };\n    }\n}\n/** @nocollapse */\nSequential.className = 'Sequential';\nserialization.registerClass(Sequential);\n//# sourceMappingURL=models.js.map"]},"metadata":{},"sourceType":"module"}