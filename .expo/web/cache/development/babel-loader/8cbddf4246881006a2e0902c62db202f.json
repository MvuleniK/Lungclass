{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, util } from '@tensorflow/tfjs-core';\nvar whereImpl = kernel_impls.whereImpl;\nimport { assertNotComplex } from \"./cpu_util\";\nexport var MathBackendCPU = function (_KernelBackend) {\n  _inherits(MathBackendCPU, _KernelBackend);\n\n  var _super = _createSuper(MathBackendCPU);\n\n  function MathBackendCPU() {\n    var _this;\n\n    _classCallCheck(this, MathBackendCPU);\n\n    _this = _super.call(this);\n    _this.blockSize = 48;\n    _this.firstUse = true;\n    _this.data = new DataStorage(_assertThisInitialized(_this), engine());\n    return _this;\n  }\n\n  _createClass(MathBackendCPU, [{\n    key: \"write\",\n    value: function write(values, shape, dtype) {\n      if (this.firstUse) {\n        this.firstUse = false;\n\n        if (env().get('IS_NODE')) {\n          backend_util.warn('\\n============================\\n' + 'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' + 'Node.js. To speed things up dramatically, install our node ' + 'backend, which binds to TensorFlow C++, by running ' + 'npm i @tensorflow/tfjs-node, ' + 'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' + 'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' + 'suffix for CUDA) at the start of your program. ' + 'Visit https://github.com/tensorflow/tfjs-node for more details.' + '\\n============================');\n        }\n      }\n\n      var dataId = {};\n      this.data.set(dataId, {\n        values: values,\n        dtype: dtype,\n        refCount: 1\n      });\n      return dataId;\n    }\n  }, {\n    key: \"makeTensorInfo\",\n    value: function makeTensorInfo(shape, dtype, values) {\n      var outId;\n\n      if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n        var encodedValues = values.map(function (d) {\n          return util.encodeString(d);\n        });\n        outId = this.write(encodedValues, shape, dtype);\n      } else {\n        outId = this.write(values, shape, dtype);\n      }\n\n      return {\n        dataId: outId,\n        shape: shape,\n        dtype: dtype\n      };\n    }\n  }, {\n    key: \"incRef\",\n    value: function incRef(dataId) {\n      var tensorData = this.data.get(dataId);\n      tensorData.refCount++;\n    }\n  }, {\n    key: \"decRef\",\n    value: function decRef(dataId) {\n      if (this.data.has(dataId)) {\n        var tensorData = this.data.get(dataId);\n        tensorData.refCount--;\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(dataId, values, shape, dtype) {\n      this.data.set(dataId, {\n        values: values,\n        dtype: dtype,\n        refCount: 1\n      });\n    }\n  }, {\n    key: \"numDataIds\",\n    value: function numDataIds() {\n      return this.data.numDataIds();\n    }\n  }, {\n    key: \"read\",\n    value: function read(dataId) {\n      return _regeneratorRuntime.async(function read$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.readSync(dataId));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"readSync\",\n    value: function readSync(dataId) {\n      var _this$data$get = this.data.get(dataId),\n          dtype = _this$data$get.dtype,\n          complexTensorInfos = _this$data$get.complexTensorInfos;\n\n      if (dtype === 'complex64') {\n        var realValues = this.readSync(complexTensorInfos.real.dataId);\n        var imagValues = this.readSync(complexTensorInfos.imag.dataId);\n        return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n      }\n\n      return this.data.get(dataId).values;\n    }\n  }, {\n    key: \"bufferSync\",\n    value: function bufferSync(t) {\n      var data = this.readSync(t.dataId);\n      var decodedData = data;\n\n      if (t.dtype === 'string') {\n        try {\n          decodedData = data.map(function (d) {\n            return util.decodeString(d);\n          });\n        } catch (_a) {\n          throw new Error('Failed to decode encoded string bytes into utf-8');\n        }\n      }\n\n      return buffer(t.shape, t.dtype, decodedData);\n    }\n  }, {\n    key: \"makeOutput\",\n    value: function makeOutput(values, shape, dtype) {\n      var dataId = this.write(values, shape, dtype);\n      return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n  }, {\n    key: \"disposeData\",\n    value: function disposeData(dataId) {\n      if (this.data.has(dataId)) {\n        var _this$data$get2 = this.data.get(dataId),\n            complexTensorInfos = _this$data$get2.complexTensorInfos;\n\n        if (complexTensorInfos != null) {\n          this.disposeData(complexTensorInfos.real.dataId);\n          this.disposeData(complexTensorInfos.imag.dataId);\n        }\n\n        this.data.delete(dataId);\n      }\n    }\n  }, {\n    key: \"disposeIntermediateTensorInfo\",\n    value: function disposeIntermediateTensorInfo(tensorInfo) {\n      var dataId = tensorInfo.dataId;\n\n      if (this.data.has(dataId)) {\n        var tensorData = this.data.get(dataId);\n        tensorData.refCount--;\n\n        if (tensorData.refCount < 1) {\n          this.disposeData(dataId);\n        }\n      }\n    }\n  }, {\n    key: \"time\",\n    value: function time(f) {\n      var start, kernelMs;\n      return _regeneratorRuntime.async(function time$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              start = util.now();\n              f();\n              kernelMs = util.now() - start;\n              return _context2.abrupt(\"return\", {\n                kernelMs: kernelMs\n              });\n\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"memory\",\n    value: function memory() {\n      return {\n        unreliable: true,\n        reasons: ['The reported memory is an upper bound. Due to automatic garbage ' + 'collection, the true allocated memory may be less.']\n      };\n    }\n  }, {\n    key: \"where\",\n    value: function where(condition) {\n      assertNotComplex([condition], 'where');\n      var condVals = this.readSync(condition.dataId);\n      return whereImpl(condition.shape, condVals);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {}\n  }, {\n    key: \"floatPrecision\",\n    value: function floatPrecision() {\n      return 32;\n    }\n  }, {\n    key: \"epsilon\",\n    value: function epsilon() {\n      return _get(_getPrototypeOf(MathBackendCPU.prototype), \"epsilon\", this).call(this);\n    }\n  }]);\n\n  return MathBackendCPU;\n}(KernelBackend);","map":{"version":3,"sources":["../src/backend_cpu.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,YAAR,EAAyC,MAAzC,EAAiD,WAAjD,EAAoF,MAApF,EAA4F,GAA5F,EAAiG,YAAjG,EAA+G,aAA/G,EAAsM,IAAtM,QAAiN,uBAAjN;AAEA,IAAM,SAAS,GAAG,YAAY,CAAC,SAA/B;AACA,SAAQ,gBAAR;AAgBA,WAAa,cAAb;EAAA;;EAAA;;EAME,0BAAA;IAAA;;IAAA;;IACE;IANK,MAAA,SAAA,GAAY,EAAZ;IAGC,MAAA,QAAA,GAAW,IAAX;IAIN,MAAK,IAAL,GAAY,IAAI,WAAJ,gCAAsB,MAAM,EAA5B,CAAZ;IAFF;EAGC;;EATH;IAAA;IAAA,OAWE,eAAM,MAAN,EAA0C,KAA1C,EAA2D,KAA3D,EAA0E;MAExE,IAAI,KAAK,QAAT,EAAmB;QACjB,KAAK,QAAL,GAAgB,KAAhB;;QACA,IAAI,GAAG,GAAG,GAAN,CAAU,SAAV,CAAJ,EAA0B;UACxB,YAAY,CAAC,IAAb,CACI,qCACA,2DADA,GAEA,6DAFA,GAGA,qDAHA,GAIA,+BAJA,GAKA,uDALA,GAMA,sDANA,GAOA,iDAPA,GAQA,iEARA,GASA,gCAVJ;QAWD;MACF;;MACD,IAAM,MAAM,GAAG,EAAf;MAEA,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,EAAsB;QAAC,MAAM,EAAN,MAAD;QAAS,KAAK,EAAL,KAAT;QAAgB,QAAQ,EAAE;MAA1B,CAAtB;MAEA,OAAO,MAAP;IACD;EAlCH;IAAA;IAAA,OA0CE,wBACI,KADJ,EACqB,KADrB,EAEI,MAFJ,EAEgD;MAC9C,IAAI,KAAJ;;MACA,IAAI,KAAK,KAAK,QAAV,IAAsB,MAAM,IAAI,IAAhC,IAAwC,MAAM,CAAC,MAAP,GAAgB,CAAxD,IACA,IAAI,CAAC,QAAL,CAAc,MAAM,CAAC,CAAD,CAApB,CADJ,EAC8B;QAC5B,IAAM,aAAa,GACd,MAAyB,CAAC,GAA1B,CAA8B,UAAA,CAAC;UAAA,OAAI,IAAI,CAAC,YAAL,CAAkB,CAAlB,CAAJ;QAAA,CAA/B,CADL;QAGA,KAAK,GAAG,KAAK,KAAL,CAAW,aAAX,EAA0B,KAA1B,EAAiC,KAAjC,CAAR;MACD,CAND,MAMO;QACL,KAAK,GAAG,KAAK,KAAL,CAAW,MAAX,EAAiC,KAAjC,EAAwC,KAAxC,CAAR;MACD;;MAED,OAAO;QAAC,MAAM,EAAE,KAAT;QAAgB,KAAK,EAAL,KAAhB;QAAuB,KAAK,EAAL;MAAvB,CAAP;IACD;EAzDH;IAAA;IAAA,OA4DE,gBAAO,MAAP,EAAqB;MACnB,IAAM,UAAU,GAAG,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,CAAnB;MACA,UAAU,CAAC,QAAX;IACD;EA/DH;IAAA;IAAA,OAkEE,gBAAO,MAAP,EAAqB;MACnB,IAAI,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,CAAJ,EAA2B;QACzB,IAAM,UAAU,GAAG,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,CAAnB;QACA,UAAU,CAAC,QAAX;MACD;IACF;EAvEH;IAAA;IAAA,OAyEE,cACI,MADJ,EACoB,MADpB,EACwD,KADxD,EAEI,KAFJ,EAEmB;MACjB,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,EAAsB;QAAC,MAAM,EAAN,MAAD;QAAS,KAAK,EAAL,KAAT;QAAgB,QAAQ,EAAE;MAA1B,CAAtB;IACD;EA7EH;IAAA;IAAA,OA+EE,sBAAU;MACR,OAAO,KAAK,IAAL,CAAU,UAAV,EAAP;IACD;EAjFH;IAAA;IAAA,OAmFE,cAAW,MAAX;MAAA;QAAA;UAAA;YAAA;cAAA,iCACS,KAAK,QAAL,CAAc,MAAd,CADT;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;EAnFF;IAAA;IAAA,OAsFE,kBAAS,MAAT,EAAuB;MACrB,qBAAoC,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,CAApC;MAAA,IAAO,KAAP,kBAAO,KAAP;MAAA,IAAc,kBAAd,kBAAc,kBAAd;;MAEA,IAAI,KAAK,KAAK,WAAd,EAA2B;QACzB,IAAM,UAAU,GACZ,KAAK,QAAL,CAAc,kBAAkB,CAAC,IAAnB,CAAwB,MAAtC,CADJ;QAEA,IAAM,UAAU,GACZ,KAAK,QAAL,CAAc,kBAAkB,CAAC,IAAnB,CAAwB,MAAtC,CADJ;QAEA,OAAO,YAAY,CAAC,sBAAb,CAAoC,UAApC,EAAgD,UAAhD,CAAP;MACD;;MAED,OAAO,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,EAAsB,MAA7B;IACD;EAlGH;IAAA;IAAA,OAoGE,oBAA2B,CAA3B,EAAwC;MACtC,IAAM,IAAI,GAAG,KAAK,QAAL,CAAc,CAAC,CAAC,MAAhB,CAAb;MACA,IAAI,WAAW,GAAG,IAAlB;;MACA,IAAI,CAAC,CAAC,KAAF,KAAY,QAAhB,EAA0B;QACxB,IAAI;UAEF,WAAW,GAAI,IAAqB,CAAC,GAAtB,CAA0B,UAAA,CAAC;YAAA,OAAI,IAAI,CAAC,YAAL,CAAkB,CAAlB,CAAJ;UAAA,CAA3B,CAAf;QACD,CAHD,CAGE,OAAA,EAAA,EAAM;UACN,MAAM,IAAI,KAAJ,CAAU,kDAAV,CAAN;QACD;MACF;;MACD,OAAO,MAAM,CAAC,CAAC,CAAC,KAAH,EAAyB,CAAC,CAAC,KAA3B,EAAkC,WAAlC,CAAb;IAED;EAjHH;IAAA;IAAA,OAmHE,oBACI,MADJ,EACwC,KADxC,EACyD,KADzD,EACwE;MACtE,IAAM,MAAM,GAAG,KAAK,KAAL,CAAW,MAAX,EAAmB,KAAnB,EAA0B,KAA1B,CAAf;MACA,OAAO,MAAM,GAAG,oBAAT,CAA8B,MAA9B,EAAsC,KAAtC,EAA6C,KAA7C,EAAoD,IAApD,CAAP;IACD;EAvHH;IAAA;IAAA,OAyHE,qBAAY,MAAZ,EAA0B;MACxB,IAAI,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,CAAJ,EAA2B;QACzB,sBAA6B,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,CAA7B;QAAA,IAAO,kBAAP,mBAAO,kBAAP;;QAEA,IAAI,kBAAkB,IAAI,IAA1B,EAAgC;UAC9B,KAAK,WAAL,CAAiB,kBAAkB,CAAC,IAAnB,CAAwB,MAAzC;UACA,KAAK,WAAL,CAAiB,kBAAkB,CAAC,IAAnB,CAAwB,MAAzC;QACD;;QAED,KAAK,IAAL,CAAU,MAAV,CAAiB,MAAjB;MACD;IACF;EApIH;IAAA;IAAA,OAsIE,uCAA8B,UAA9B,EAAoD;MAClD,IAAM,MAAM,GAAG,UAAU,CAAC,MAA1B;;MAEA,IAAI,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,CAAJ,EAA2B;QACzB,IAAM,UAAU,GAAG,KAAK,IAAL,CAAU,GAAV,CAAc,MAAd,CAAnB;QAEA,UAAU,CAAC,QAAX;;QAEA,IAAI,UAAU,CAAC,QAAX,GAAsB,CAA1B,EAA6B;UAC3B,KAAK,WAAL,CAAiB,MAAjB;QACD;MACF;IACF;EAlJH;IAAA;IAAA,OAoJE,cAAW,CAAX;MAAA;MAAA;QAAA;UAAA;YAAA;cACQ,KADR,GACgB,IAAI,CAAC,GAAL,EADhB;cAEE,CAAC;cACK,QAHR,GAGmB,IAAI,CAAC,GAAL,KAAa,KAHhC;cAAA,kCAIS;gBAAC,QAAQ,EAAR;cAAD,CAJT;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;EApJF;IAAA;IAAA,OA2JE,kBAAM;MACJ,OAAO;QAEL,UAAU,EAAE,IAFP;QAGL,OAAO,EACH,CAAC,qEACA,oDADD;MAJC,CAAP;IAOD;EAnKH;IAAA;IAAA,OAqKE,eAAM,SAAN,EAAuB;MACrB,gBAAgB,CAAC,CAAC,SAAD,CAAD,EAAc,OAAd,CAAhB;MAEA,IAAM,QAAQ,GAAG,KAAK,QAAL,CAAc,SAAS,CAAC,MAAxB,CAAjB;MACA,OAAO,SAAS,CAAC,SAAS,CAAC,KAAX,EAAkB,QAAlB,CAAhB;IACD;EA1KH;IAAA;IAAA,OA4KE,mBAAO,CAAK;EA5Kd;IAAA;IAAA,OA8KE,0BAAc;MACZ,OAAO,EAAP;IACD;EAhLH;IAAA;IAAA,OAmLE,mBAAO;MACL;IACD;EArLH;;EAAA;AAAA,EAAoC,aAApC","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, util } from '@tensorflow/tfjs-core';\nconst whereImpl = kernel_impls.whereImpl;\nimport { assertNotComplex } from './cpu_util';\nexport class MathBackendCPU extends KernelBackend {\n    constructor() {\n        super();\n        this.blockSize = 48;\n        this.firstUse = true;\n        this.data = new DataStorage(this, engine());\n    }\n    write(values, shape, dtype) {\n        if (this.firstUse) {\n            this.firstUse = false;\n            if (env().get('IS_NODE')) {\n                backend_util.warn('\\n============================\\n' +\n                    'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' +\n                    'Node.js. To speed things up dramatically, install our node ' +\n                    'backend, which binds to TensorFlow C++, by running ' +\n                    'npm i @tensorflow/tfjs-node, ' +\n                    'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' +\n                    'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' +\n                    'suffix for CUDA) at the start of your program. ' +\n                    'Visit https://github.com/tensorflow/tfjs-node for more details.' +\n                    '\\n============================');\n            }\n        }\n        const dataId = {};\n        this.data.set(dataId, { values, dtype, refCount: 1 });\n        return dataId;\n    }\n    /**\n     * Create a data bucket in cpu backend.\n     * @param shape Shape of the `TensorInfo`.\n     * @param dtype DType of the `TensorInfo`.\n     * @param values The value of the `TensorInfo` stored as a flattened array.\n     */\n    makeTensorInfo(shape, dtype, values) {\n        let outId;\n        if (dtype === 'string' && values != null && values.length > 0 &&\n            util.isString(values[0])) {\n            const encodedValues = values.map(d => util.encodeString(d));\n            outId = this.write(encodedValues, shape, dtype);\n        }\n        else {\n            outId = this.write(values, shape, dtype);\n        }\n        return { dataId: outId, shape, dtype };\n    }\n    /** Increase refCount of a `TensorData`. */\n    incRef(dataId) {\n        const tensorData = this.data.get(dataId);\n        tensorData.refCount++;\n    }\n    /** Decrease refCount of a `TensorData`. */\n    decRef(dataId) {\n        if (this.data.has(dataId)) {\n            const tensorData = this.data.get(dataId);\n            tensorData.refCount--;\n        }\n    }\n    move(dataId, values, shape, dtype) {\n        this.data.set(dataId, { values, dtype, refCount: 1 });\n    }\n    numDataIds() {\n        return this.data.numDataIds();\n    }\n    async read(dataId) {\n        return this.readSync(dataId);\n    }\n    readSync(dataId) {\n        const { dtype, complexTensorInfos } = this.data.get(dataId);\n        if (dtype === 'complex64') {\n            const realValues = this.readSync(complexTensorInfos.real.dataId);\n            const imagValues = this.readSync(complexTensorInfos.imag.dataId);\n            return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        return this.data.get(dataId).values;\n    }\n    bufferSync(t) {\n        const data = this.readSync(t.dataId);\n        let decodedData = data;\n        if (t.dtype === 'string') {\n            try {\n                // Decode the bytes into string.\n                decodedData = data.map(d => util.decodeString(d));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode encoded string bytes into utf-8');\n            }\n        }\n        return buffer(t.shape, t.dtype, decodedData);\n    }\n    makeOutput(values, shape, dtype) {\n        const dataId = this.write(values, shape, dtype);\n        return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n    disposeData(dataId) {\n        if (this.data.has(dataId)) {\n            const { complexTensorInfos } = this.data.get(dataId);\n            if (complexTensorInfos != null) {\n                this.disposeData(complexTensorInfos.real.dataId);\n                this.disposeData(complexTensorInfos.imag.dataId);\n            }\n            this.data.delete(dataId);\n        }\n    }\n    disposeIntermediateTensorInfo(tensorInfo) {\n        const dataId = tensorInfo.dataId;\n        if (this.data.has(dataId)) {\n            const tensorData = this.data.get(dataId);\n            tensorData.refCount--;\n            if (tensorData.refCount < 1) {\n                this.disposeData(dataId);\n            }\n        }\n    }\n    async time(f) {\n        const start = util.now();\n        f();\n        const kernelMs = util.now() - start;\n        return { kernelMs };\n    }\n    memory() {\n        return {\n            // Unreliable due to automatic gc. The numbers above are cumulative.\n            unreliable: true,\n            reasons: ['The reported memory is an upper bound. Due to automatic garbage ' +\n                    'collection, the true allocated memory may be less.']\n        };\n    }\n    where(condition) {\n        assertNotComplex([condition], 'where');\n        const condVals = this.readSync(condition.dataId);\n        return whereImpl(condition.shape, condVals);\n    }\n    dispose() { }\n    floatPrecision() {\n        return 32;\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return super.epsilon();\n    }\n}\n//# sourceMappingURL=backend_cpu.js.map"]},"metadata":{},"sourceType":"module"}