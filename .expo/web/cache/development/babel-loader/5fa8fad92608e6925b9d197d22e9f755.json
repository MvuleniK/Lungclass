{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from \"../cpu_util\";\nimport { cast } from \"./Cast\";\nimport { equal } from \"./Equal\";\nimport { expandDims } from \"./ExpandDims\";\nimport { multiply } from \"./Multiply\";\nimport { pack } from \"./Pack\";\nimport { sum } from \"./Sum\";\nexport function unsortedSegmentSum(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x,\n      segmentIds = inputs.segmentIds;\n  var numSegments = attrs.numSegments;\n  assertNotComplex(x, 'unsortedSegmentSum');\n  var xRank = x.shape.length;\n  var segmentIdsRank = segmentIds.shape.length;\n  var res = [];\n  var intermediates = [];\n  var numIters = xRank - segmentIdsRank;\n  var $segmentIds = segmentIds;\n\n  for (var i = 0; i < numIters; ++i) {\n    var expanded = expandDims({\n      inputs: {\n        input: $segmentIds\n      },\n      backend: backend,\n      attrs: {\n        dim: i + 1\n      }\n    });\n    $segmentIds = expanded;\n    intermediates.push(expanded);\n  }\n\n  for (var _i = 0; _i < numSegments; ++_i) {\n    var scalarValue = util.createScalarValue(_i, 'int32');\n    var segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n    var mask = equal({\n      inputs: {\n        a: segmentId,\n        b: $segmentIds\n      },\n      backend: backend\n    });\n    var maskCasted = cast({\n      inputs: {\n        x: mask\n      },\n      backend: backend,\n      attrs: {\n        dtype: 'float32'\n      }\n    });\n    var mul = multiply({\n      inputs: {\n        a: maskCasted,\n        b: x\n      },\n      backend: backend\n    });\n    var sumTensorInfo = sum({\n      inputs: {\n        x: mul\n      },\n      backend: backend,\n      attrs: {\n        axis: 0,\n        keepDims: false\n      }\n    });\n    res.push(sumTensorInfo);\n    intermediates.push(segmentId);\n    intermediates.push(mask);\n    intermediates.push(maskCasted);\n    intermediates.push(mul);\n    intermediates.push(sumTensorInfo);\n  }\n\n  var result = pack({\n    inputs: res,\n    backend: backend,\n    attrs: {\n      axis: 0\n    }\n  });\n  intermediates.forEach(function (t) {\n    return backend.disposeIntermediateTensorInfo(t);\n  });\n  return result;\n}\nexport var unsortedSegmentSumConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'cpu',\n  kernelFunc: unsortedSegmentSum\n};","map":{"version":3,"sources":["../../src/kernels/UnsortedSegmentSum.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAA8C,kBAA9C,EAAqH,IAArH,QAAgI,uBAAhI;AAGA,SAAQ,gBAAR;AACA,SAAQ,IAAR;AACA,SAAQ,KAAR;AACA,SAAQ,UAAR;AACA,SAAQ,QAAR;AACA,SAAQ,IAAR;AACA,SAAQ,GAAR;AAEA,OAAM,SAAU,kBAAV,CAA6B,IAA7B,EAIL;EACC,IAAO,MAAP,GAAiC,IAAjC,CAAO,MAAP;EAAA,IAAe,OAAf,GAAiC,IAAjC,CAAe,OAAf;EAAA,IAAwB,KAAxB,GAAiC,IAAjC,CAAwB,KAAxB;EACA,IAAO,CAAP,GAAwB,MAAxB,CAAO,CAAP;EAAA,IAAU,UAAV,GAAwB,MAAxB,CAAU,UAAV;EACA,IAAO,WAAP,GAAsB,KAAtB,CAAO,WAAP;EAEA,gBAAgB,CAAC,CAAD,EAAI,oBAAJ,CAAhB;EAEA,IAAM,KAAK,GAAG,CAAC,CAAC,KAAF,CAAQ,MAAtB;EACA,IAAM,cAAc,GAAG,UAAU,CAAC,KAAX,CAAiB,MAAxC;EACA,IAAM,GAAG,GAAG,EAAZ;EACA,IAAM,aAAa,GAAiB,EAApC;EAIA,IAAM,QAAQ,GAAG,KAAK,GAAG,cAAzB;EACA,IAAI,WAAW,GAAG,UAAlB;;EAEA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAApB,EAA8B,EAAE,CAAhC,EAAmC;IACjC,IAAM,QAAQ,GAAG,UAAU,CACvB;MAAC,MAAM,EAAE;QAAC,KAAK,EAAE;MAAR,CAAT;MAA+B,OAAO,EAAP,OAA/B;MAAwC,KAAK,EAAE;QAAC,GAAG,EAAE,CAAC,GAAG;MAAV;IAA/C,CADuB,CAA3B;IAEA,WAAW,GAAG,QAAd;IACA,aAAa,CAAC,IAAd,CAAmB,QAAnB;EACD;;EAED,KAAK,IAAI,EAAC,GAAG,CAAb,EAAgB,EAAC,GAAG,WAApB,EAAiC,EAAE,EAAnC,EAAsC;IACpC,IAAM,WAAW,GAAG,IAAI,CAAC,iBAAL,CAAuB,EAAvB,EAA2C,OAA3C,CAApB;IACA,IAAM,SAAS,GAAG,OAAO,CAAC,cAAR,CAAuB,EAAvB,EAA2B,OAA3B,EAAoC,WAApC,CAAlB;IACA,IAAM,IAAI,GACN,KAAK,CAAC;MAAC,MAAM,EAAE;QAAC,CAAC,EAAE,SAAJ;QAAe,CAAC,EAAE;MAAlB,CAAT;MAAyC,OAAO,EAAP;IAAzC,CAAD,CADT;IAEA,IAAM,UAAU,GACZ,IAAI,CAAC;MAAC,MAAM,EAAE;QAAC,CAAC,EAAE;MAAJ,CAAT;MAAoB,OAAO,EAAP,OAApB;MAA6B,KAAK,EAAE;QAAC,KAAK,EAAE;MAAR;IAApC,CAAD,CADR;IAEA,IAAM,GAAG,GACL,QAAQ,CAAC;MAAC,MAAM,EAAE;QAAC,CAAC,EAAE,UAAJ;QAAgB,CAAC,EAAE;MAAnB,CAAT;MAAgC,OAAO,EAAP;IAAhC,CAAD,CADZ;IAEA,IAAM,aAAa,GACf,GAAG,CAAC;MAAC,MAAM,EAAE;QAAC,CAAC,EAAE;MAAJ,CAAT;MAAmB,OAAO,EAAP,OAAnB;MAA4B,KAAK,EAAE;QAAC,IAAI,EAAE,CAAP;QAAU,QAAQ,EAAE;MAApB;IAAnC,CAAD,CADP;IAEA,GAAG,CAAC,IAAJ,CAAS,aAAT;IACA,aAAa,CAAC,IAAd,CAAmB,SAAnB;IACA,aAAa,CAAC,IAAd,CAAmB,IAAnB;IACA,aAAa,CAAC,IAAd,CAAmB,UAAnB;IACA,aAAa,CAAC,IAAd,CAAmB,GAAnB;IACA,aAAa,CAAC,IAAd,CAAmB,aAAnB;EACD;;EAED,IAAM,MAAM,GAAG,IAAI,CAAC;IAAC,MAAM,EAAE,GAAT;IAAc,OAAO,EAAP,OAAd;IAAuB,KAAK,EAAE;MAAC,IAAI,EAAE;IAAP;EAA9B,CAAD,CAAnB;EAEA,aAAa,CAAC,OAAd,CAAsB,UAAA,CAAC;IAAA,OAAI,OAAO,CAAC,6BAAR,CAAsC,CAAtC,CAAJ;EAAA,CAAvB;EAEA,OAAO,MAAP;AACD;AAED,OAAO,IAAM,wBAAwB,GAAiB;EACpD,UAAU,EAAE,kBADwC;EAEpD,WAAW,EAAE,KAFuC;EAGpD,UAAU,EAAE;AAHwC,CAA/C","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from './Cast';\nimport { equal } from './Equal';\nimport { expandDims } from './ExpandDims';\nimport { multiply } from './Multiply';\nimport { pack } from './Pack';\nimport { sum } from './Sum';\nexport function unsortedSegmentSum(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, segmentIds } = inputs;\n    const { numSegments } = attrs;\n    assertNotComplex(x, 'unsortedSegmentSum');\n    const xRank = x.shape.length;\n    const segmentIdsRank = segmentIds.shape.length;\n    const res = [];\n    const intermediates = [];\n    // Reshape the segment id's so that they can be broadcast with\n    // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n    const numIters = xRank - segmentIdsRank;\n    let $segmentIds = segmentIds;\n    for (let i = 0; i < numIters; ++i) {\n        const expanded = expandDims({ inputs: { input: $segmentIds }, backend, attrs: { dim: i + 1 } });\n        $segmentIds = expanded;\n        intermediates.push(expanded);\n    }\n    for (let i = 0; i < numSegments; ++i) {\n        const scalarValue = util.createScalarValue(i, 'int32');\n        const segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n        const mask = equal({ inputs: { a: segmentId, b: $segmentIds }, backend });\n        const maskCasted = cast({ inputs: { x: mask }, backend, attrs: { dtype: 'float32' } });\n        const mul = multiply({ inputs: { a: maskCasted, b: x }, backend });\n        const sumTensorInfo = sum({ inputs: { x: mul }, backend, attrs: { axis: 0, keepDims: false } });\n        res.push(sumTensorInfo);\n        intermediates.push(segmentId);\n        intermediates.push(mask);\n        intermediates.push(maskCasted);\n        intermediates.push(mul);\n        intermediates.push(sumTensorInfo);\n    }\n    const result = pack({ inputs: res, backend, attrs: { axis: 0 } });\n    intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return result;\n}\nexport const unsortedSegmentSumConfig = {\n    kernelName: UnsortedSegmentSum,\n    backendName: 'cpu',\n    kernelFunc: unsortedSegmentSum\n};\n//# sourceMappingURL=UnsortedSegmentSum.js.map"]},"metadata":{},"sourceType":"module"}