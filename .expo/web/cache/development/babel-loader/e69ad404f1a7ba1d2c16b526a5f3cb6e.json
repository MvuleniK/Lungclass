{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nexport var RingBuffer = function () {\n  function RingBuffer(capacity) {\n    _classCallCheck(this, RingBuffer);\n\n    this.capacity = capacity;\n    this.begin = 0;\n    this.end = 0;\n\n    if (capacity == null) {\n      throw new RangeError('Can\\'t create a ring buffer of unknown capacity.');\n    }\n\n    if (capacity < 1) {\n      throw new RangeError('Can\\'t create ring buffer of capacity < 1.');\n    }\n\n    this.data = new Array(capacity);\n    this.doubledCapacity = 2 * capacity;\n  }\n\n  _createClass(RingBuffer, [{\n    key: \"wrap\",\n    value: function wrap(index) {\n      while (index < 0) {\n        index += this.doubledCapacity;\n      }\n\n      return index % this.doubledCapacity;\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      if (index < 0) {\n        throw new RangeError('Can\\'t get item at a negative index.');\n      }\n\n      return this.data[index % this.capacity];\n    }\n  }, {\n    key: \"set\",\n    value: function set(index, value) {\n      if (index < 0) {\n        throw new RangeError('Can\\'t set item at a negative index.');\n      }\n\n      this.data[index % this.capacity] = value;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var length = this.end - this.begin;\n\n      if (length < 0) {\n        length = this.doubledCapacity + length;\n      }\n\n      return length;\n    }\n  }, {\n    key: \"isFull\",\n    value: function isFull() {\n      return this.length() === this.capacity;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.length() === 0;\n    }\n  }, {\n    key: \"push\",\n    value: function push(value) {\n      if (this.isFull()) {\n        throw new RangeError('Ring buffer is full.');\n      }\n\n      this.set(this.end, value);\n      this.end = this.wrap(this.end + 1);\n    }\n  }, {\n    key: \"pushAll\",\n    value: function pushAll(values) {\n      for (var _iterator = _createForOfIteratorHelperLoose(values), _step; !(_step = _iterator()).done;) {\n        var value = _step.value;\n        this.push(value);\n      }\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      if (this.isEmpty()) {\n        throw new RangeError('Ring buffer is empty.');\n      }\n\n      this.end = this.wrap(this.end - 1);\n      var result = this.get(this.end);\n      this.set(this.end, undefined);\n      return result;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(value) {\n      if (this.isFull()) {\n        throw new RangeError('Ring buffer is full.');\n      }\n\n      this.begin = this.wrap(this.begin - 1);\n      this.set(this.begin, value);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.isEmpty()) {\n        throw new RangeError('Ring buffer is empty.');\n      }\n\n      var result = this.get(this.begin);\n      this.set(this.begin, undefined);\n      this.begin = this.wrap(this.begin + 1);\n      return result;\n    }\n  }, {\n    key: \"shuffleExcise\",\n    value: function shuffleExcise(relativeIndex) {\n      if (this.isEmpty()) {\n        throw new RangeError('Ring buffer is empty.');\n      }\n\n      var index = this.wrap(this.begin + relativeIndex);\n      var result = this.get(index);\n      this.set(index, this.pop());\n      return result;\n    }\n  }]);\n\n  return RingBuffer;\n}();","map":{"version":3,"sources":["../../src/util/ring_buffer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n/**\n * A ring buffer, providing O(1) FIFO, LIFO, and related operations.\n */\nexport class RingBuffer {\n    /**\n     * Constructs a `RingBuffer`.\n     * @param capacity The number of items that the buffer can accomodate.\n     */\n    constructor(capacity) {\n        this.capacity = capacity;\n        // Note we store the indices in the range 0 <= index < 2*capacity.\n        // This allows us to distinguish the full from the empty case.\n        // See https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/\n        this.begin = 0; // inclusive\n        this.end = 0; // exclusive\n        if (capacity == null) {\n            throw new RangeError('Can\\'t create a ring buffer of unknown capacity.');\n        }\n        if (capacity < 1) {\n            throw new RangeError('Can\\'t create ring buffer of capacity < 1.');\n        }\n        this.data = new Array(capacity);\n        this.doubledCapacity = 2 * capacity;\n    }\n    /**\n     * Map any index into the range 0 <= index < 2*capacity.\n     */\n    wrap(index) {\n        // don't trust % on negative numbers\n        while (index < 0) {\n            index += this.doubledCapacity;\n        }\n        return index % this.doubledCapacity;\n    }\n    get(index) {\n        if (index < 0) {\n            throw new RangeError('Can\\'t get item at a negative index.');\n        }\n        return this.data[index % this.capacity];\n    }\n    set(index, value) {\n        if (index < 0) {\n            throw new RangeError('Can\\'t set item at a negative index.');\n        }\n        this.data[index % this.capacity] = value;\n    }\n    /**\n     * Returns the current number of items in the buffer.\n     */\n    length() {\n        let length = this.end - this.begin;\n        if (length < 0) {\n            length = this.doubledCapacity + length;\n        }\n        return length;\n    }\n    /**\n     * Reports whether the buffer is full.\n     * @returns true if the number of items in the buffer equals its capacity, and\n     *   false otherwise.\n     */\n    isFull() {\n        return this.length() === this.capacity;\n    }\n    /**\n     * Reports whether the buffer is empty.\n     * @returns true if the number of items in the buffer equals zero, and\n     *   false otherwise.\n     */\n    isEmpty() {\n        return this.length() === 0;\n    }\n    /**\n     * Adds an item to the end of the buffer.\n     */\n    push(value) {\n        if (this.isFull()) {\n            throw new RangeError('Ring buffer is full.');\n        }\n        this.set(this.end, value);\n        this.end = this.wrap(this.end + 1);\n    }\n    /**\n     * Adds many items to the end of the buffer, in order.\n     */\n    pushAll(values) {\n        for (const value of values) {\n            this.push(value);\n        }\n    }\n    /**\n     * Removes and returns the last item in the buffer.\n     */\n    pop() {\n        if (this.isEmpty()) {\n            throw new RangeError('Ring buffer is empty.');\n        }\n        this.end = this.wrap(this.end - 1);\n        const result = this.get(this.end);\n        this.set(this.end, undefined);\n        return result;\n    }\n    /**\n     * Adds an item to the beginning of the buffer.\n     */\n    unshift(value) {\n        if (this.isFull()) {\n            throw new RangeError('Ring buffer is full.');\n        }\n        this.begin = this.wrap(this.begin - 1);\n        this.set(this.begin, value);\n    }\n    /**\n     * Removes and returns the first item in the buffer.\n     */\n    shift() {\n        if (this.isEmpty()) {\n            throw new RangeError('Ring buffer is empty.');\n        }\n        const result = this.get(this.begin);\n        this.set(this.begin, undefined);\n        this.begin = this.wrap(this.begin + 1);\n        return result;\n    }\n    /**\n     * Removes and returns a specific item in the buffer, and moves the last item\n     * to the vacated slot.  This is useful for implementing a shuffling stream.\n     * Note that this operation necessarily scrambles the original order.\n     *\n     * @param relativeIndex: the index of the item to remove, relative to the\n     *   first item in the buffer (e.g., hiding the ring nature of the underlying\n     *   storage).\n     */\n    shuffleExcise(relativeIndex) {\n        if (this.isEmpty()) {\n            throw new RangeError('Ring buffer is empty.');\n        }\n        const index = this.wrap(this.begin + relativeIndex);\n        const result = this.get(index);\n        this.set(index, this.pop());\n        return result;\n    }\n}\n//# sourceMappingURL=ring_buffer.js.map"]},"metadata":{},"sourceType":"module"}