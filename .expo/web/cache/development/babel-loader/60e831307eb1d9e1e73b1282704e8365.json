{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from \"./packing_util\";\nimport { getCoordsDataType } from \"./shader_compiler\";\nexport var ReversePackedProgram = _createClass(function ReversePackedProgram(xShape, axis) {\n  _classCallCheck(this, ReversePackedProgram);\n\n  this.variableNames = ['x'];\n  this.packedInputs = true;\n  this.packedOutput = true;\n  var rank = xShape.length;\n\n  if (rank > 4) {\n    throw new Error(\"WebGL backend: Reverse of rank-\" + rank + \" tensor is not yet supported\");\n  }\n\n  this.outputShape = xShape;\n  var channels = getChannels('rc', rank);\n  var nextColumn = channels[rank - 1] + \" + 1 < \" + this.outputShape[rank - 1];\n  var nextRow = channels[rank - 2] + \" + 1 < \" + this.outputShape[rank - 2];\n  var type = getCoordsDataType(rank);\n\n  if (rank === 1) {\n    this.userCode = \"\\n        void main(){\\n          int rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = getChannel(getX(\" + xShape[0] + \" - rc - 1),\\n            \" + xShape[0] + \" - rc - 1);\\n          if(\" + nextColumn + \"){\\n              result.g = getChannel(getX(\" + xShape[0] + \" - (rc  + 1) - 1),\\n                \" + xShape[0] + \" - (rc  + 1) - 1);\\n          }\\n          setOutput(result);\\n        }\\n      \";\n  } else {\n    this.userCode = \"\\n        void main() {\\n          \" + type + \" rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = \" + getR(channels.slice()) + \";\\n          if(\" + nextColumn + \"){\\n            result.g = \" + getG(channels.slice()) + \";\\n          }\\n          if(\" + nextRow + \") {\\n            result.b = \" + getB(channels.slice()) + \";\\n            if(\" + nextColumn + \") {\\n              result.a = \" + getA(channels.slice()) + \";\\n            }\\n          }\\n          setOutput(result);\\n        }\\n    \";\n  }\n\n  function getR(channels) {\n    return getChannel(channels);\n  }\n\n  function getG(channels) {\n    channels[rank - 1] = '(' + channels[rank - 1] + \" + 1)\";\n    return getChannel(channels);\n  }\n\n  function getB(channels) {\n    channels[rank - 2] = '(' + channels[rank - 2] + \" + 1)\";\n    return getChannel(channels);\n  }\n\n  function getA(channels) {\n    channels[rank - 1] = '(' + channels[rank - 1] + \" + 1)\";\n    channels[rank - 2] = '(' + channels[rank - 2] + \" + 1)\";\n    return getChannel(channels);\n  }\n\n  function getChannel(channels) {\n    var inCoordsArray = xShape.map(function (_, i) {\n      return getInCoord(i, channels);\n    });\n    var inCoords = inCoordsArray.join(',');\n    var innerDims = inCoordsArray.slice(-2).join(',');\n    return \"getChannel(getX(\" + inCoords + \"), vec2(\" + innerDims + \"))\";\n  }\n\n  function getInCoord(i, channels1) {\n    if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n      return xShape[i] + \" - \" + channels1[i] + \" - 1\";\n    } else {\n      return \"\" + channels1[i];\n    }\n  }\n});","map":{"version":3,"sources":["../src/reverse_packed_gpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ReversePackedProgram {\n    constructor(xShape, axis) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        const rank = xShape.length;\n        if (rank > 4) {\n            throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n        }\n        this.outputShape = xShape;\n        const channels = getChannels('rc', rank);\n        const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n        const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n        const type = getCoordsDataType(rank);\n        if (rank === 1) {\n            this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n        }\n        else {\n            this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n        }\n        function getR(channels) {\n            return getChannel(channels);\n        }\n        function getG(channels) {\n            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getB(channels) {\n            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getA(channels) {\n            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getChannel(channels) {\n            const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n            const inCoords = inCoordsArray.join(',');\n            const innerDims = inCoordsArray.slice(-2).join(',');\n            return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n        }\n        function getInCoord(i, channels1) {\n            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n                return `${xShape[i]} - ${channels1[i]} - 1`;\n            }\n            else {\n                return `${channels1[i]}`;\n            }\n        }\n    }\n}\n//# sourceMappingURL=reverse_packed_gpu.js.map"]},"metadata":{},"sourceType":"module"}