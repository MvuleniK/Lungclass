{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from \"../cpu_util\";\nexport function lRNGrad(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x,\n      y = inputs.y,\n      dy = inputs.dy;\n  var depthRadius = attrs.depthRadius,\n      bias = attrs.bias,\n      alpha = attrs.alpha,\n      beta = attrs.beta;\n  assertNotComplex(dy, 'LRNGrad');\n  var dySize = util.sizeFromShape(dy.shape);\n  var channels = dy.shape[3];\n  var dyValues = backend.data.get(dy.dataId).values;\n  var xValues = backend.data.get(x.dataId).values;\n  var yValues = backend.data.get(y.dataId).values;\n  var result = new Float32Array(dySize);\n  var size = dySize;\n\n  for (var offset = 0; offset < size; offset++) {\n    var currentChannel = offset % channels;\n    var depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n    var depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);\n    var norm = 0;\n\n    for (var k = depthBegin; k < depthEnd; k++) {\n      norm += Math.pow(xValues[k], 2);\n    }\n\n    norm = alpha * norm + bias;\n\n    for (var _k = depthBegin; _k < depthEnd; _k++) {\n      var dyi = -2 * alpha * beta * xValues[_k] * yValues[offset] / norm;\n\n      if (offset === _k) {\n        dyi += Math.pow(norm, -beta);\n      }\n\n      dyi *= dyValues[offset];\n      result[_k] += dyi;\n    }\n  }\n\n  return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\nexport var lRNGradConfig = {\n  kernelName: LRNGrad,\n  backendName: 'cpu',\n  kernelFunc: lRNGrad\n};","map":{"version":3,"sources":["../../src/kernels/LRNGrad.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function lRNGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, y, dy } = inputs;\n    const { depthRadius, bias, alpha, beta } = attrs;\n    assertNotComplex(dy, 'LRNGrad');\n    const dySize = util.sizeFromShape(dy.shape);\n    const channels = dy.shape[3];\n    const dyValues = backend.data.get(dy.dataId).values;\n    const xValues = backend.data.get(x.dataId).values;\n    const yValues = backend.data.get(y.dataId).values;\n    const result = new Float32Array(dySize);\n    const size = dySize;\n    for (let offset = 0; offset < size; offset++) {\n        const currentChannel = offset % channels;\n        const depthBegin = (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);\n        const depthEnd = (offset - currentChannel) +\n            Math.min(channels, currentChannel + depthRadius + 1);\n        let norm = 0;\n        for (let k = depthBegin; k < depthEnd; k++) {\n            norm += Math.pow(xValues[k], 2);\n        }\n        norm = alpha * norm + bias;\n        for (let k = depthBegin; k < depthEnd; k++) {\n            let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm;\n            if (offset === k) {\n                dyi += Math.pow(norm, -beta);\n            }\n            dyi *= dyValues[offset];\n            result[k] += dyi;\n        }\n    }\n    return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\nexport const lRNGradConfig = {\n    kernelName: LRNGrad,\n    backendName: 'cpu',\n    kernelFunc: lRNGrad\n};\n//# sourceMappingURL=LRNGrad.js.map"]},"metadata":{},"sourceType":"module"}