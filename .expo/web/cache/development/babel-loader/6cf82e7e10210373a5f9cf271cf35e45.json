{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from \"../operations/executors/utils\";\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  var usedNodes = new Set();\n  var missingInputs = [];\n  var dynamicNode = null;\n  var syncInputs = null;\n  var seen = new Set();\n  var inputNodeNames = Object.keys(inputs).map(function (name) {\n    return parseNodeName(name)[0];\n  });\n  var initNodeNames = [];\n\n  if (initNodes != null) {\n    initNodeNames = initNodes.map(function (node) {\n      return parseNodeName(node.name)[0];\n    });\n  }\n\n  var frontier = _toConsumableArray(outputs);\n\n  while (frontier.length > 0) {\n    var node = frontier.pop();\n\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(function (child) {\n          return child.name;\n        }).filter(function (name) {\n          return usedNodes.has(name);\n        });\n      }\n    }\n\n    usedNodes.add(node.name);\n\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n\n    if (initNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n\n    node.inputs.forEach(function (input) {\n      if (seen.has(input.name)) {\n        return;\n      }\n\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n\n  return {\n    inputs: inputs,\n    outputs: outputs,\n    usedNodes: usedNodes,\n    missingInputs: missingInputs,\n    dynamicNode: dynamicNode,\n    syncInputs: syncInputs\n  };\n}\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n  var usedNodes = executionInfo.usedNodes,\n      inputs = executionInfo.inputs;\n  var frontier = [];\n  var inputNodes = Object.keys(inputs).map(function (name) {\n    return parseNodeName(name)[0];\n  }).map(function (name) {\n    return graph.nodes[name];\n  });\n  var initNodes = graph.initNodes;\n  inputNodes.forEach(function (input) {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(function (weight) {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n\n  if (initNodes != null) {\n    initNodes.forEach(function (node) {\n      if (usedNodes.has(node.name)) {\n        frontier.push(node);\n      }\n    });\n  }\n\n  var seen = new Set();\n  var orderedNodes = [];\n\n  while (frontier.length > 0) {\n    var node = frontier.pop();\n    seen.add(node.name);\n\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n\n    node.children.forEach(function (child) {\n      if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every(function (input) {\n        return seen.has(input.name);\n      })) {\n        frontier.push(child);\n      }\n    });\n  }\n\n  return orderedNodes;\n}\nvar CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While'];\nvar DYNAMIC_SHAPE_OPS = ['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'];\nvar HASH_TABLE_OPS = ['HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2', 'LookupTableFind', 'LookupTableFindV2'];\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\nexport function isHashTable(node) {\n  return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}","map":{"version":3,"sources":["../../src/executor/model_analysis.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n    const usedNodes = new Set();\n    const missingInputs = [];\n    let dynamicNode = null;\n    let syncInputs = null;\n    // Start with the outputs, going backwards and find all the nodes that are\n    // needed to compute those outputs.\n    const seen = new Set();\n    const inputNodeNames = Object.keys(inputs).map(name => parseNodeName(name)[0]);\n    let initNodeNames = [];\n    if (initNodes != null) {\n        initNodeNames = initNodes.map(node => parseNodeName(node.name)[0]);\n    }\n    const frontier = [...outputs];\n    while (frontier.length > 0) {\n        const node = frontier.pop();\n        if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n            if (dynamicNode == null) {\n                dynamicNode = node;\n                syncInputs = dynamicNode.children.map(child => child.name)\n                    .filter(name => usedNodes.has(name));\n            }\n        }\n        usedNodes.add(node.name);\n        // Weights are dead end since we already have their values.\n        if (weightMap[node.name] != null) {\n            continue;\n        }\n        // This node is a dead end since it's one of the user-provided inputs.\n        if (inputNodeNames.indexOf(node.name) !== -1) {\n            continue;\n        }\n        // This node is a dead end since it doesn't have any inputs.\n        if (initNodeNames.indexOf(node.name) !== -1) {\n            continue;\n        }\n        if (node.inputs.length === 0) {\n            missingInputs.push(node.name);\n            continue;\n        }\n        node.inputs.forEach(input => {\n            // Don't add to the frontier if it is already there.\n            if (seen.has(input.name)) {\n                return;\n            }\n            seen.add(input.name);\n            frontier.push(input);\n        });\n    }\n    return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n    const { usedNodes, inputs } = executionInfo;\n    const frontier = [];\n    const inputNodes = Object.keys(inputs)\n        .map(name => parseNodeName(name)[0])\n        .map(name => graph.nodes[name]);\n    const initNodes = graph.initNodes;\n    inputNodes.forEach(input => {\n        if (usedNodes.has(input.name)) {\n            frontier.push(input);\n        }\n    });\n    graph.weights.forEach(weight => {\n        if (usedNodes.has(weight.name)) {\n            frontier.push(weight);\n        }\n    });\n    if (initNodes != null) {\n        initNodes.forEach(node => {\n            if (usedNodes.has(node.name)) {\n                frontier.push(node);\n            }\n        });\n    }\n    const seen = new Set();\n    const orderedNodes = [];\n    while (frontier.length > 0) {\n        const node = frontier.pop();\n        seen.add(node.name);\n        if (!weightMap[node.name]) {\n            orderedNodes.push(node);\n        }\n        node.children.forEach(child => {\n            if (!seen.has(child.name) && usedNodes.has(child.name) &&\n                child.inputs.every(input => seen.has(input.name))) {\n                frontier.push(child);\n            }\n        });\n    }\n    return orderedNodes;\n}\nconst CONTROL_FLOW_OPS = [\n    'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n    'StatelessWhile', 'if', 'While'\n];\nconst DYNAMIC_SHAPE_OPS = [\n    'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n];\nconst HASH_TABLE_OPS = [\n    'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',\n    'LookupTableFind', 'LookupTableFindV2'\n];\nexport function isControlFlow(node) {\n    return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n    return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\nexport function isHashTable(node) {\n    return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}\n//# sourceMappingURL=model_analysis.js.map"]},"metadata":{},"sourceType":"module"}