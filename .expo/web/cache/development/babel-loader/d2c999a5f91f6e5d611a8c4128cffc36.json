{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { fromByteArray, toByteArray } from 'base64-js';\nvar PATH_SEPARATOR = '/';\nvar PATH_PREFIX = 'tensorflowjs_models';\nvar INFO_SUFFIX = 'info';\nvar MODEL_SUFFIX = 'model_without_weight';\nvar WEIGHT_DATA_SUFFIX = 'weight_data';\n\nfunction getModelKeys(path) {\n  return {\n    info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),\n    modelArtifactsWithoutWeights: [PATH_PREFIX, path, MODEL_SUFFIX].join(PATH_SEPARATOR),\n    weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR)\n  };\n}\n\nfunction getModelArtifactsInfoForJSON(modelArtifacts) {\n  if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n    throw new Error('Expected JSON model topology, received ArrayBuffer.');\n  }\n\n  return {\n    dateSaved: new Date(),\n    modelTopologyType: 'JSON',\n    weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength\n  };\n}\n\nvar AsyncStorageHandler = function () {\n  function AsyncStorageHandler(modelPath) {\n    _classCallCheck(this, AsyncStorageHandler);\n\n    this.modelPath = modelPath;\n\n    if (modelPath == null || !modelPath) {\n      throw new Error('modelPath must not be null, undefined or empty.');\n    }\n\n    this.keys = getModelKeys(this.modelPath);\n    this.asyncStorage = require('@react-native-community/async-storage').default;\n  }\n\n  _createClass(AsyncStorageHandler, [{\n    key: \"save\",\n    value: function save(modelArtifacts) {\n      var modelArtifactsInfo, weightData, modelArtifactsWithoutWeights;\n      return _regeneratorRuntime.async(function save$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(modelArtifacts.modelTopology instanceof ArrayBuffer)) {\n                _context.next = 4;\n                break;\n              }\n\n              throw new Error('AsyncStorageHandler.save() does not support saving model topology ' + 'in binary format.');\n\n            case 4:\n              modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);\n              weightData = modelArtifacts.weightData, modelArtifactsWithoutWeights = __rest(modelArtifacts, [\"weightData\"]);\n              _context.prev = 6;\n              this.asyncStorage.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));\n              this.asyncStorage.setItem(this.keys.modelArtifactsWithoutWeights, JSON.stringify(modelArtifactsWithoutWeights));\n              this.asyncStorage.setItem(this.keys.weightData, fromByteArray(new Uint8Array(weightData)));\n              return _context.abrupt(\"return\", {\n                modelArtifactsInfo: modelArtifactsInfo\n              });\n\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](6);\n              this.asyncStorage.removeItem(this.keys.info);\n              this.asyncStorage.removeItem(this.keys.weightData);\n              this.asyncStorage.removeItem(this.keys.modelArtifactsWithoutWeights);\n              throw new Error(\"Failed to save model '\" + this.modelPath + \"' to AsyncStorage.\\n            Error info \" + _context.t0);\n\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, [[6, 13]], Promise);\n    }\n  }, {\n    key: \"load\",\n    value: function load() {\n      var info, modelArtifacts, weightDataBase64;\n      return _regeneratorRuntime.async(function load$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.t0 = JSON;\n              _context2.next = 3;\n              return _regeneratorRuntime.awrap(this.asyncStorage.getItem(this.keys.info));\n\n            case 3:\n              _context2.t1 = _context2.sent;\n              info = _context2.t0.parse.call(_context2.t0, _context2.t1);\n\n              if (!(info == null)) {\n                _context2.next = 7;\n                break;\n              }\n\n              throw new Error(\"In local storage, there is no model with name '\" + this.modelPath + \"'\");\n\n            case 7:\n              if (!(info.modelTopologyType !== 'JSON')) {\n                _context2.next = 9;\n                break;\n              }\n\n              throw new Error('BrowserLocalStorage does not support loading non-JSON model ' + 'topology yet.');\n\n            case 9:\n              _context2.t2 = JSON;\n              _context2.next = 12;\n              return _regeneratorRuntime.awrap(this.asyncStorage.getItem(this.keys.modelArtifactsWithoutWeights));\n\n            case 12:\n              _context2.t3 = _context2.sent;\n              modelArtifacts = _context2.t2.parse.call(_context2.t2, _context2.t3);\n              _context2.next = 16;\n              return _regeneratorRuntime.awrap(this.asyncStorage.getItem(this.keys.weightData));\n\n            case 16:\n              weightDataBase64 = _context2.sent;\n\n              if (!(weightDataBase64 == null)) {\n                _context2.next = 19;\n                break;\n              }\n\n              throw new Error(\"In local storage, the binary weight values of model \" + (\"'\" + this.modelPath + \"' are missing.\"));\n\n            case 19:\n              modelArtifacts.weightData = toByteArray(weightDataBase64).buffer;\n              return _context2.abrupt(\"return\", modelArtifacts);\n\n            case 21:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return AsyncStorageHandler;\n}();\n\nexport function asyncStorageIO(modelPath) {\n  return new AsyncStorageHandler(modelPath);\n}","map":{"version":3,"sources":["../src/async_storage_io.ts"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;AAeG;;;;;;;;;;;;;;AAIH,SAAQ,aAAR,EAAuB,WAAvB,QAAyC,WAAzC;AAQA,IAAM,cAAc,GAAG,GAAvB;AACA,IAAM,WAAW,GAAG,qBAApB;AACA,IAAM,WAAW,GAAG,MAApB;AACA,IAAM,YAAY,GAAG,sBAArB;AACA,IAAM,kBAAkB,GAAG,aAA3B;;AAEA,SAAS,YAAT,CAAsB,IAAtB,EAAkC;EAChC,OAAO;IACL,IAAI,EAAE,CAAC,WAAD,EAAc,IAAd,EAAoB,WAApB,EAAiC,IAAjC,CAAsC,cAAtC,CADD;IAEL,4BAA4B,EACxB,CAAC,WAAD,EAAc,IAAd,EAAoB,YAApB,EAAkC,IAAlC,CAAuC,cAAvC,CAHC;IAIL,UAAU,EAAE,CAAC,WAAD,EAAc,IAAd,EAAoB,kBAApB,EAAwC,IAAxC,CAA6C,cAA7C;EAJP,CAAP;AAMD;;AAMD,SAAS,4BAAT,CAAsC,cAAtC,EAAuE;EAErE,IAAI,cAAc,CAAC,aAAf,YAAwC,WAA5C,EAAyD;IACvD,MAAM,IAAI,KAAJ,CAAU,qDAAV,CAAN;EACD;;EAED,OAAO;IACL,SAAS,EAAE,IAAI,IAAJ,EADN;IAGL,iBAAiB,EAAE,MAHd;IAIL,eAAe,EAAE,cAAc,CAAC,UAAf,IAA6B,IAA7B,GACb,CADa,GAEb,cAAc,CAAC,UAAf,CAA0B;EANzB,CAAP;AAQD;;IAEK,mB;EAIJ,6BAA+B,SAA/B,EAAgD;IAAA;;IAAjB,KAAA,SAAA,GAAA,SAAA;;IAC7B,IAAI,SAAS,IAAI,IAAb,IAAqB,CAAC,SAA1B,EAAqC;MACnC,MAAM,IAAI,KAAJ,CAAU,iDAAV,CAAN;IACD;;IACD,KAAK,IAAL,GAAY,YAAY,CAAC,KAAK,SAAN,CAAxB;IAMA,KAAK,YAAL,GAEI,OAAO,CAAC,uCAAD,CAAP,CAAiD,OAFrD;EAGD;;;;WAQD,cAAW,cAAX;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA,MACM,cAAc,CAAC,aAAf,YAAwC,WAD9C;gBAAA;gBAAA;cAAA;;cAAA,MAEU,IAAI,KAAJ,CACF,uEACA,mBAFE,CAFV;;YAAA;cASU,kBATV,GAUQ,4BAA4B,CAAC,cAAD,CAVpC;cAWW,UAXX,GAW0D,cAX1D,CAWW,UAXX,EAWuB,4BAXvB,GAWuB,MAAA,CAAA,cAAA,EAAA,CAAA,YAAA,CAAA,CAXvB;cAAA;cAcM,KAAK,YAAL,CAAkB,OAAlB,CACI,KAAK,IAAL,CAAU,IADd,EACoB,IAAI,CAAC,SAAL,CAAe,kBAAf,CADpB;cAEA,KAAK,YAAL,CAAkB,OAAlB,CACI,KAAK,IAAL,CAAU,4BADd,EAEI,IAAI,CAAC,SAAL,CAAe,4BAAf,CAFJ;cAGA,KAAK,YAAL,CAAkB,OAAlB,CACI,KAAK,IAAL,CAAU,UADd,EAC0B,aAAa,CAAC,IAAI,UAAJ,CAAe,UAAf,CAAD,CADvC;cAnBN,iCAqBa;gBAAC,kBAAkB,EAAlB;cAAD,CArBb;;YAAA;cAAA;cAAA;cAwBM,KAAK,YAAL,CAAkB,UAAlB,CAA6B,KAAK,IAAL,CAAU,IAAvC;cACA,KAAK,YAAL,CAAkB,UAAlB,CAA6B,KAAK,IAAL,CAAU,UAAvC;cACA,KAAK,YAAL,CAAkB,UAAlB,CAA6B,KAAK,IAAL,CAAU,4BAAvC;cA1BN,MA4BY,IAAI,KAAJ,4BACuB,KAAK,SAD5B,+DA5BZ;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;;;WA2CA;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA,eACe,IADf;cAAA;cAAA,iCACgC,KAAK,YAAL,CAAkB,OAAlB,CAA0B,KAAK,IAAL,CAAU,IAApC,CADhC;;YAAA;cAAA;cACQ,IADR,gBACoB,KADpB;;cAAA,MAGM,IAAI,IAAI,IAHd;gBAAA;gBAAA;cAAA;;cAAA,MAIU,IAAI,KAAJ,qDACgD,KAAK,SADrD,OAJV;;YAAA;cAAA,MAQM,IAAI,CAAC,iBAAL,KAA2B,MARjC;gBAAA;gBAAA;cAAA;;cAAA,MASU,IAAI,KAAJ,CACF,iEACA,eAFE,CATV;;YAAA;cAAA,eAeM,IAfN;cAAA;cAAA,iCAeuB,KAAK,YAAL,CAAkB,OAAlB,CACb,KAAK,IAAL,CAAU,4BADG,CAfvB;;YAAA;cAAA;cAcQ,cAdR,gBAeW,KAfX;cAAA;cAAA,iCAoBY,KAAK,YAAL,CAAkB,OAAlB,CAA0B,KAAK,IAAL,CAAU,UAApC,CApBZ;;YAAA;cAmBQ,gBAnBR;;cAAA,MAqBM,gBAAgB,IAAI,IArB1B;gBAAA;gBAAA;cAAA;;cAAA,MAsBU,IAAI,KAAJ,CACF,gEACI,KAAK,SADT,oBADE,CAtBV;;YAAA;cA0BE,cAAc,CAAC,UAAf,GAA4B,WAAW,CAAC,gBAAD,CAAX,CAA8B,MAA1D;cA1BF,kCA4BS,cA5BT;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;;;;;;AAmEF,OAAM,SAAU,cAAV,CAAyB,SAAzB,EAA0C;EAC9C,OAAO,IAAI,mBAAJ,CAAwB,SAAxB,CAAP;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { fromByteArray, toByteArray } from 'base64-js';\nconst PATH_SEPARATOR = '/';\nconst PATH_PREFIX = 'tensorflowjs_models';\nconst INFO_SUFFIX = 'info';\nconst MODEL_SUFFIX = 'model_without_weight';\nconst WEIGHT_DATA_SUFFIX = 'weight_data';\nfunction getModelKeys(path) {\n    return {\n        info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),\n        modelArtifactsWithoutWeights: [PATH_PREFIX, path, MODEL_SUFFIX].join(PATH_SEPARATOR),\n        weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),\n    };\n}\n/**\n * Populate ModelArtifactsInfo fields for a model with JSON topology.\n * @param modelArtifacts\n * @returns A ModelArtifactsInfo object.\n */\nfunction getModelArtifactsInfoForJSON(modelArtifacts) {\n    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n        throw new Error('Expected JSON model topology, received ArrayBuffer.');\n    }\n    return {\n        dateSaved: new Date(),\n        // TODO followup on removing this from the the interface\n        modelTopologyType: 'JSON',\n        weightDataBytes: modelArtifacts.weightData == null ?\n            0 :\n            modelArtifacts.weightData.byteLength,\n    };\n}\nclass AsyncStorageHandler {\n    constructor(modelPath) {\n        this.modelPath = modelPath;\n        if (modelPath == null || !modelPath) {\n            throw new Error('modelPath must not be null, undefined or empty.');\n        }\n        this.keys = getModelKeys(this.modelPath);\n        // We import this dynamically because it binds to a native library that\n        // needs to be installed by the user if they use this handler. We don't\n        // want users who are not using AsyncStorage to have to install this\n        // library.\n        this.asyncStorage =\n            // tslint:disable-next-line:no-require-imports\n            require('@react-native-community/async-storage').default;\n    }\n    /**\n     * Save model artifacts to AsyncStorage\n     *\n     * @param modelArtifacts The model artifacts to be stored.\n     * @returns An instance of SaveResult.\n     */\n    async save(modelArtifacts) {\n        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n            throw new Error('AsyncStorageHandler.save() does not support saving model topology ' +\n                'in binary format.');\n        }\n        else {\n            // We save three items separately for each model,\n            // a ModelArtifactsInfo, a ModelArtifacts without weights\n            // and the model weights.\n            const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);\n            const { weightData } = modelArtifacts, modelArtifactsWithoutWeights = __rest(modelArtifacts, [\"weightData\"]);\n            try {\n                this.asyncStorage.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));\n                this.asyncStorage.setItem(this.keys.modelArtifactsWithoutWeights, JSON.stringify(modelArtifactsWithoutWeights));\n                this.asyncStorage.setItem(this.keys.weightData, fromByteArray(new Uint8Array(weightData)));\n                return { modelArtifactsInfo };\n            }\n            catch (err) {\n                // If saving failed, clean up all items saved so far.\n                this.asyncStorage.removeItem(this.keys.info);\n                this.asyncStorage.removeItem(this.keys.weightData);\n                this.asyncStorage.removeItem(this.keys.modelArtifactsWithoutWeights);\n                throw new Error(`Failed to save model '${this.modelPath}' to AsyncStorage.\n            Error info ${err}`);\n            }\n        }\n    }\n    /**\n     * Load a model from local storage.\n     *\n     * See the documentation to `browserLocalStorage` for details on the saved\n     * artifacts.\n     *\n     * @returns The loaded model (if loading succeeds).\n     */\n    async load() {\n        const info = JSON.parse(await this.asyncStorage.getItem(this.keys.info));\n        if (info == null) {\n            throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);\n        }\n        if (info.modelTopologyType !== 'JSON') {\n            throw new Error('BrowserLocalStorage does not support loading non-JSON model ' +\n                'topology yet.');\n        }\n        const modelArtifacts = JSON.parse(await this.asyncStorage.getItem(this.keys.modelArtifactsWithoutWeights));\n        // Load weight data.\n        const weightDataBase64 = await this.asyncStorage.getItem(this.keys.weightData);\n        if (weightDataBase64 == null) {\n            throw new Error(`In local storage, the binary weight values of model ` +\n                `'${this.modelPath}' are missing.`);\n        }\n        modelArtifacts.weightData = toByteArray(weightDataBase64).buffer;\n        return modelArtifacts;\n    }\n}\n/**\n * Factory function for AsyncStorage IOHandler.\n *\n * This `IOHandler` supports both `save` and `load`.\n *\n * For each model's saved artifacts, three items are saved to async storage.\n *   - `tensorflowjs_models/${modelPath}/info`: Contains meta-info about the\n *     model, such as date saved, type of the topology, size in bytes, etc.\n *   - `tensorflowjs_models/${modelPath}/model_without_weight`: The topology,\n *     weights_specs and all other information about the model except for the\n *     weights.\n *   - `tensorflowjs_models/${modelPath}/weight_data`: Concatenated binary\n *     weight values, stored as a base64-encoded string.\n *\n * ```js\n *  async function asyncStorageExample() {\n *    // Define a model\n *    const model = tf.sequential();\n *    model.add(tf.layers.dense({units: 5, inputShape: [1]}));\n *    model.add(tf.layers.dense({units: 1}));\n *    model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *    // Save the model to async storage\n *    await model.save(asyncStorageIO('custom-model-test'));\n *    // Load the model from async storage\n *    await tf.loadLayersModel(asyncStorageIO('custom-model-test'));\n * }\n * ```\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `IOHandler`\n *\n * @doc {heading: 'Models', subheading: 'IOHandlers'}\n */\nexport function asyncStorageIO(modelPath) {\n    return new AsyncStorageHandler(modelPath);\n}\n//# sourceMappingURL=async_storage_io.js.map"]},"metadata":{},"sourceType":"module"}