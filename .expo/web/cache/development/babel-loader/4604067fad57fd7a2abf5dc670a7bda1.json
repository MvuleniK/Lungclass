{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from \"./util\";\nvar FORMAT_LIMIT_NUM_VALS = 20;\nvar FORMAT_NUM_FIRST_LAST_VALS = 3;\nvar FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n  var strides = computeStrides(shape);\n  var padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  var rank = shape.length;\n  var valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  var lines = ['Tensor'];\n\n  if (verbose) {\n    lines.push(\"  dtype: \" + dtype);\n    lines.push(\"  rank: \" + rank);\n    lines.push(\"  shape: [\" + shape + \"]\");\n    lines.push(\"  values:\");\n  }\n\n  lines.push(valsLines.map(function (l) {\n    return '    ' + l;\n  }).join('\\n'));\n  return lines.join('\\n');\n}\n\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n  var n = sizeFromShape(shape);\n  var numCols = strides[strides.length - 1];\n  var padPerCol = new Array(numCols).fill(0);\n  var rank = shape.length;\n  var valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n\n  if (rank > 1) {\n    for (var row = 0; row < n / numCols; row++) {\n      var offset = row * numCols;\n\n      for (var j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n\n  return padPerCol;\n}\n\nfunction valToString(val, pad, dtype) {\n  var valStr;\n\n  if (Array.isArray(val)) {\n    valStr = parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS)) + \" + \" + (parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS)) + \"j\");\n  } else if (isString(val)) {\n    valStr = \"'\" + val + \"'\";\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n\n  return rightPad(valStr, pad);\n}\n\nfunction boolNumToString(v) {\n  return v === 0 ? 'false' : 'true';\n}\n\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol) {\n  var isLast = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var storagePerElement = dtype === 'complex64' ? 2 : 1;\n  var size = shape[0];\n  var rank = shape.length;\n\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      var complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0])];\n    }\n\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      var firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n      var firstVals = Array.from(vals.slice(0, firstValsSize));\n      var lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n\n      return ['[' + firstVals.map(function (x, i) {\n        return valToString(x, padPerCol[i], dtype);\n      }).join(', ') + ', ..., ' + lastVals.map(function (x, i) {\n        return valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype);\n      }).join(', ') + ']'];\n    }\n\n    var displayVals = dtype === 'complex64' ? createComplexTuples(vals) : Array.from(vals);\n    return ['[' + displayVals.map(function (x, i) {\n      return valToString(x, padPerCol[i], dtype);\n    }).join(', ') + ']'];\n  }\n\n  var subshape = shape.slice(1);\n  var substrides = strides.slice(1);\n  var stride = strides[0] * storagePerElement;\n  var lines = [];\n\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      var start = i * stride;\n      var end = start + stride;\n      lines.push.apply(lines, _toConsumableArray(subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false)));\n    }\n\n    lines.push('...');\n\n    for (var _i = size - FORMAT_NUM_FIRST_LAST_VALS; _i < size; _i++) {\n      var _start = _i * stride;\n\n      var _end = _start + stride;\n\n      lines.push.apply(lines, _toConsumableArray(subTensorToString(vals.slice(_start, _end), subshape, dtype, substrides, padPerCol, _i === size - 1)));\n    }\n  } else {\n    for (var _i2 = 0; _i2 < size; _i2++) {\n      var _start2 = _i2 * stride;\n\n      var _end2 = _start2 + stride;\n\n      lines.push.apply(lines, _toConsumableArray(subTensorToString(vals.slice(_start2, _end2), subshape, dtype, substrides, padPerCol, _i2 === size - 1)));\n    }\n  }\n\n  var sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + lines[0] + sep;\n\n  for (var _i3 = 1; _i3 < lines.length - 1; _i3++) {\n    lines[_i3] = ' ' + lines[_i3] + sep;\n  }\n\n  var newLineSep = ',\\n';\n\n  for (var _i4 = 2; _i4 < rank; _i4++) {\n    newLineSep += '\\n';\n  }\n\n  lines[lines.length - 1] = ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\n\nfunction createComplexTuples(vals) {\n  var complexTuples = [];\n\n  for (var i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]]);\n  }\n\n  return complexTuples;\n}","map":{"version":3,"sources":["../src/tensor_format.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util';\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n    const strides = computeStrides(shape);\n    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n    const rank = shape.length;\n    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n    const lines = ['Tensor'];\n    if (verbose) {\n        lines.push(`  dtype: ${dtype}`);\n        lines.push(`  rank: ${rank}`);\n        lines.push(`  shape: [${shape}]`);\n        lines.push(`  values:`);\n    }\n    lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n    return lines.join('\\n');\n}\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n    const n = sizeFromShape(shape);\n    const numCols = strides[strides.length - 1];\n    const padPerCol = new Array(numCols).fill(0);\n    const rank = shape.length;\n    const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n    if (rank > 1) {\n        for (let row = 0; row < n / numCols; row++) {\n            const offset = row * numCols;\n            for (let j = 0; j < numCols; j++) {\n                padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n            }\n        }\n    }\n    return padPerCol;\n}\nfunction valToString(val, pad, dtype) {\n    let valStr;\n    if (Array.isArray(val)) {\n        valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n            `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n    }\n    else if (isString(val)) {\n        valStr = `'${val}'`;\n    }\n    else if (dtype === 'bool') {\n        valStr = boolNumToString(val);\n    }\n    else {\n        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n    }\n    return rightPad(valStr, pad);\n}\nfunction boolNumToString(v) {\n    return v === 0 ? 'false' : 'true';\n}\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n    const storagePerElement = dtype === 'complex64' ? 2 : 1;\n    const size = shape[0];\n    const rank = shape.length;\n    if (rank === 0) {\n        if (dtype === 'complex64') {\n            const complexTuple = createComplexTuples(vals);\n            return [valToString(complexTuple[0], 0, dtype)];\n        }\n        if (dtype === 'bool') {\n            return [boolNumToString(vals[0])];\n        }\n        return [vals[0].toString()];\n    }\n    if (rank === 1) {\n        if (size > FORMAT_LIMIT_NUM_VALS) {\n            const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n            let firstVals = Array.from(vals.slice(0, firstValsSize));\n            let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n            if (dtype === 'complex64') {\n                firstVals = createComplexTuples(firstVals);\n                lastVals = createComplexTuples(lastVals);\n            }\n            return [\n                '[' +\n                    firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                        .join(', ') +\n                    ', ..., ' +\n                    lastVals\n                        .map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n                        .join(', ') +\n                    ']'\n            ];\n        }\n        const displayVals = dtype === 'complex64' ? createComplexTuples(vals) :\n            Array.from(vals);\n        return [\n            '[' +\n                displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                    .join(', ') +\n                ']'\n        ];\n    }\n    // The array is rank 2 or more.\n    const subshape = shape.slice(1);\n    const substrides = strides.slice(1);\n    const stride = strides[0] * storagePerElement;\n    const lines = [];\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n        for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */));\n        }\n        lines.push('...');\n        for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    else {\n        for (let i = 0; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    const sep = rank === 2 ? ',' : '';\n    lines[0] = '[' + lines[0] + sep;\n    for (let i = 1; i < lines.length - 1; i++) {\n        lines[i] = ' ' + lines[i] + sep;\n    }\n    let newLineSep = ',\\n';\n    for (let i = 2; i < rank; i++) {\n        newLineSep += '\\n';\n    }\n    lines[lines.length - 1] =\n        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n    return lines;\n}\nfunction createComplexTuples(vals) {\n    const complexTuples = [];\n    for (let i = 0; i < vals.length; i += 2) {\n        complexTuples.push([vals[i], vals[i + 1]]);\n    }\n    return complexTuples;\n}\n//# sourceMappingURL=tensor_format.js.map"]},"metadata":{},"sourceType":"module"}