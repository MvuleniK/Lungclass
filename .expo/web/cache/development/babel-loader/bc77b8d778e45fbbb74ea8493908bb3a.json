{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { computeStrides, sizeFromShape } from \"../util\";\nexport function prepareAndValidate(tensor, indices) {\n  var tensorRank = tensor.shape.length;\n  var indicesRank = indices.shape.length;\n\n  if (tensorRank < 1) {\n    throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' + (\" but the rank was \" + tensorRank + \".\"));\n  }\n\n  if (indicesRank < 1) {\n    throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' + (\" but the rank was \" + indicesRank + \".\"));\n  }\n\n  if (indices.dtype !== 'int32') {\n    throw new Error('tf.gatherND() expects the indices to be int32 type,' + (\" but the dtype was \" + indices.dtype + \".\"));\n  }\n\n  if (indices.shape[indicesRank - 1] > tensorRank) {\n    throw new Error('index innermost dimension length must be <= tensor rank; saw: ' + (indices.shape[indicesRank - 1] + \" vs. \" + tensorRank));\n  }\n\n  if (sizeFromShape(tensor.shape) === 0) {\n    throw new Error('Requested more than 0 entries, but input is empty.' + (\" Input shape: \" + tensor.shape + \".\"));\n  }\n\n  var indicesShape = indices.shape;\n  var sliceRank = indicesShape[indicesShape.length - 1];\n  var nResult = 1;\n\n  for (var i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  var inputShape = tensor.shape;\n  var resultShape = indicesShape.slice();\n  resultShape.pop();\n  var sliceSize = 1;\n\n  for (var _i = sliceRank; _i < tensorRank; ++_i) {\n    sliceSize *= inputShape[_i];\n    resultShape.push(inputShape[_i]);\n  }\n\n  var strides = [].concat(_toConsumableArray(computeStrides(tensor.shape).map(function (stride) {\n    return stride / sliceSize;\n  })), [1]).slice(0, sliceRank);\n  return [resultShape, nResult, sliceSize, strides];\n}","map":{"version":3,"sources":["../../src/ops/gather_nd_util.ts"],"names":[],"mappings":";AAiBA,SAAQ,cAAR,EAAwB,aAAxB;AAUA,OAAM,SAAU,kBAAV,CAA6B,MAA7B,EAAiD,OAAjD,EAAoE;EAExE,IAAM,UAAU,GAAG,MAAM,CAAC,KAAP,CAAa,MAAhC;EACA,IAAM,WAAW,GAAG,OAAO,CAAC,KAAR,CAAc,MAAlC;;EACA,IAAI,UAAU,GAAG,CAAjB,EAAoB;IAClB,MAAM,IAAI,KAAJ,CACF,oFACqB,UADrB,OADE,CAAN;EAGD;;EACD,IAAI,WAAW,GAAG,CAAlB,EAAqB;IACnB,MAAM,IAAI,KAAJ,CACF,sFACqB,WADrB,OADE,CAAN;EAGD;;EACD,IAAI,OAAO,CAAC,KAAR,KAAkB,OAAtB,EAA+B;IAC7B,MAAM,IAAI,KAAJ,CACF,iFACsB,OAAO,CAAC,KAD9B,OADE,CAAN;EAGD;;EACD,IAAI,OAAO,CAAC,KAAR,CAAc,WAAW,GAAG,CAA5B,IAAiC,UAArC,EAAiD;IAC/C,MAAM,IAAI,KAAJ,CACF,oEACG,OAAO,CAAC,KAAR,CAAc,WAAW,GAAG,CAA5B,CADH,aACyC,UADzC,CADE,CAAN;EAGD;;EAED,IAAI,aAAa,CAAC,MAAM,CAAC,KAAR,CAAb,KAAgC,CAApC,EAAuC;IACrC,MAAM,IAAI,KAAJ,CACF,2EACiB,MAAM,CAAC,KADxB,OADE,CAAN;EAGD;;EAED,IAAM,YAAY,GAAG,OAAO,CAAC,KAA7B;EACA,IAAM,SAAS,GAAG,YAAY,CAAC,YAAY,CAAC,MAAb,GAAsB,CAAvB,CAA9B;EAIA,IAAI,OAAO,GAAG,CAAd;;EACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,MAAb,GAAsB,CAA1C,EAA6C,EAAE,CAA/C,EAAkD;IAChD,OAAO,IAAI,YAAY,CAAC,CAAD,CAAvB;EACD;;EAED,IAAM,UAAU,GAAG,MAAM,CAAC,KAA1B;EAEA,IAAM,WAAW,GAAG,YAAY,CAAC,KAAb,EAApB;EACA,WAAW,CAAC,GAAZ;EAEA,IAAI,SAAS,GAAG,CAAhB;;EACA,KAAK,IAAI,EAAC,GAAG,SAAb,EAAwB,EAAC,GAAG,UAA5B,EAAwC,EAAE,EAA1C,EAA6C;IAC3C,SAAS,IAAI,UAAU,CAAC,EAAD,CAAvB;IACA,WAAW,CAAC,IAAZ,CAAiB,UAAU,CAAC,EAAD,CAA3B;EACD;;EAED,IAAM,OAAO,GACT,6BAAI,cAAc,CAAC,MAAM,CAAC,KAAR,CAAd,CAA6B,GAA7B,CAAiC,UAAA,MAAM;IAAA,OAAI,MAAM,GAAG,SAAb;EAAA,CAAvC,CAAJ,IACC,CADD,GACI,KADJ,CACU,CADV,EACa,SADb,CADJ;EAIA,OAAO,CAAC,WAAD,EAAc,OAAd,EAAuB,SAAvB,EAAkC,OAAlC,CAAP;AACD","sourceRoot":"","sourcesContent":["import { computeStrides, sizeFromShape } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor, indices) {\n    const tensorRank = tensor.shape.length;\n    const indicesRank = indices.shape.length;\n    if (tensorRank < 1) {\n        throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' +\n            ` but the rank was ${tensorRank}.`);\n    }\n    if (indicesRank < 1) {\n        throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indicesRank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error('tf.gatherND() expects the indices to be int32 type,' +\n            ` but the dtype was ${indices.dtype}.`);\n    }\n    if (indices.shape[indicesRank - 1] > tensorRank) {\n        throw new Error('index innermost dimension length must be <= tensor rank; saw: ' +\n            `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n    }\n    if (sizeFromShape(tensor.shape) === 0) {\n        throw new Error('Requested more than 0 entries, but input is empty.' +\n            ` Input shape: ${tensor.shape}.`);\n    }\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n    // The result shape is\n    //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n    let nResult = 1;\n    for (let i = 0; i < indicesShape.length - 1; ++i) {\n        nResult *= indicesShape[i];\n    }\n    const inputShape = tensor.shape;\n    const resultShape = indicesShape.slice();\n    resultShape.pop();\n    let sliceSize = 1;\n    for (let i = sliceRank; i < tensorRank; ++i) {\n        sliceSize *= inputShape[i];\n        resultShape.push(inputShape[i]);\n    }\n    const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n        1].slice(0, sliceRank);\n    return [resultShape, nResult, sliceSize, strides];\n}\n//# sourceMappingURL=gather_nd_util.js.map"]},"metadata":{},"sourceType":"module"}