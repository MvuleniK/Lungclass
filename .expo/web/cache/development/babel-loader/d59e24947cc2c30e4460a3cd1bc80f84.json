{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nexport var ExecutionContext = function () {\n  function ExecutionContext() {\n    var weightMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var tensorArrayMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var tensorListMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var functionMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, ExecutionContext);\n\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n\n  _createClass(ExecutionContext, [{\n    key: \"newFrame\",\n    value: function newFrame(id, frameName) {\n      return {\n        id: id,\n        frameName: frameName,\n        iterationId: 0\n      };\n    }\n  }, {\n    key: \"currentContext\",\n    get: function get() {\n      return this.contexts;\n    },\n    set: function set(contexts) {\n      if (this.contexts !== contexts) {\n        this.contexts = contexts;\n        this.generateCurrentContextIds();\n      }\n    }\n  }, {\n    key: \"currentContextId\",\n    get: function get() {\n      return this._currentContextIds[0];\n    }\n  }, {\n    key: \"currentContextIds\",\n    get: function get() {\n      return this._currentContextIds;\n    }\n  }, {\n    key: \"generateCurrentContextIds\",\n    value: function generateCurrentContextIds() {\n      var names = [];\n\n      for (var i = 0; i < this.contexts.length - 1; i++) {\n        var contexts = this.contexts.slice(0, this.contexts.length - i);\n        names.push(this.contextIdforContexts(contexts));\n      }\n\n      names.push('');\n      this._currentContextIds = names;\n    }\n  }, {\n    key: \"contextIdforContexts\",\n    value: function contextIdforContexts(contexts) {\n      return contexts ? contexts.map(function (context) {\n        return context.id === 0 && context.iterationId === 0 ? '' : context.frameName + \"-\" + context.iterationId;\n      }).join('/') : '';\n    }\n  }, {\n    key: \"enterFrame\",\n    value: function enterFrame(frameId) {\n      if (this.contexts) {\n        this.lastId++;\n        this.contexts = this.contexts.slice();\n        this.contexts.push(this.newFrame(this.lastId, frameId));\n\n        this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n      }\n    }\n  }, {\n    key: \"exitFrame\",\n    value: function exitFrame() {\n      if (this.contexts && this.contexts.length > 1) {\n        this.contexts = this.contexts.slice();\n        this.contexts.splice(-1);\n        this.currentContextIds.shift();\n      } else {\n        throw new Error('Cannot exit frame, the context is empty');\n      }\n    }\n  }, {\n    key: \"nextIteration\",\n    value: function nextIteration() {\n      if (this.contexts && this.contexts.length > 0) {\n        this.contexts = this.contexts.slice();\n        this.lastId++;\n\n        var context = _extends({}, this.contexts[this.contexts.length - 1]);\n\n        context.iterationId += 1;\n        context.id = this.lastId;\n        this.contexts.splice(-1, 1, context);\n\n        this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n      } else {\n        throw new Error('Cannot increase frame iteration, the context is empty');\n      }\n    }\n  }, {\n    key: \"getWeight\",\n    value: function getWeight(name) {\n      return this.weightMap[name];\n    }\n  }, {\n    key: \"addTensorArray\",\n    value: function addTensorArray(tensorArray) {\n      this.tensorArrayMap[tensorArray.id] = tensorArray;\n    }\n  }, {\n    key: \"getTensorArray\",\n    value: function getTensorArray(id) {\n      return this.tensorArrayMap[id];\n    }\n  }, {\n    key: \"addTensorList\",\n    value: function addTensorList(tensorList) {\n      this.tensorListMap[tensorList.id] = tensorList;\n    }\n  }, {\n    key: \"getTensorList\",\n    value: function getTensorList(id) {\n      return this.tensorListMap[id];\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose(keepIds) {\n      for (var key in this.tensorArrayMap) {\n        this.tensorArrayMap[key].clearAndClose(keepIds);\n      }\n\n      for (var _key in this.tensorListMap) {\n        this.tensorListMap[_key].clearAndClose(keepIds);\n      }\n    }\n  }]);\n\n  return ExecutionContext;\n}();","map":{"version":3,"sources":["../../src/executor/execution_context.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n    constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {\n        this.weightMap = weightMap;\n        this.tensorArrayMap = tensorArrayMap;\n        this.tensorListMap = tensorListMap;\n        this.functionMap = functionMap;\n        this.rootContext = { id: 0, frameName: '', iterationId: 0 };\n        this.contexts = [this.rootContext];\n        this.lastId = 0;\n        this.generateCurrentContextIds();\n    }\n    newFrame(id, frameName) {\n        return { id, frameName, iterationId: 0 };\n    }\n    /**\n     * Set the current context\n     * @param contexts: ExecutionContextInfo[] the current path of execution\n     * frames\n     */\n    set currentContext(contexts) {\n        if (this.contexts !== contexts) {\n            this.contexts = contexts;\n            this.generateCurrentContextIds();\n        }\n    }\n    get currentContext() {\n        return this.contexts;\n    }\n    /**\n     * Returns the current context in string format.\n     */\n    get currentContextId() {\n        return this._currentContextIds[0];\n    }\n    /**\n     * Returns the current context and all parent contexts in string format.\n     * This allow access to the nodes in the current and parent frames.\n     */\n    get currentContextIds() {\n        return this._currentContextIds;\n    }\n    generateCurrentContextIds() {\n        const names = [];\n        for (let i = 0; i < this.contexts.length - 1; i++) {\n            const contexts = this.contexts.slice(0, this.contexts.length - i);\n            names.push(this.contextIdforContexts(contexts));\n        }\n        names.push('');\n        this._currentContextIds = names;\n    }\n    contextIdforContexts(contexts) {\n        return contexts ?\n            contexts\n                .map(context => (context.id === 0 && context.iterationId === 0) ?\n                '' :\n                `${context.frameName}-${context.iterationId}`)\n                .join('/') :\n            '';\n    }\n    /**\n     * Enter a new frame, a new context is pushed on the current context list.\n     * @param frameId new frame id\n     */\n    enterFrame(frameId) {\n        if (this.contexts) {\n            this.lastId++;\n            this.contexts = this.contexts.slice();\n            this.contexts.push(this.newFrame(this.lastId, frameId));\n            this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n        }\n    }\n    /**\n     * Exit the current frame, the last context is removed from the current\n     * context list.\n     */\n    exitFrame() {\n        if (this.contexts && this.contexts.length > 1) {\n            this.contexts = this.contexts.slice();\n            this.contexts.splice(-1);\n            this.currentContextIds.shift();\n        }\n        else {\n            throw new Error('Cannot exit frame, the context is empty');\n        }\n    }\n    /**\n     * Enter the next iteration of a loop, the iteration id of last context is\n     * increased.\n     */\n    nextIteration() {\n        if (this.contexts && this.contexts.length > 0) {\n            this.contexts = this.contexts.slice();\n            this.lastId++;\n            const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n            context.iterationId += 1;\n            context.id = this.lastId;\n            this.contexts.splice(-1, 1, context);\n            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n        }\n        else {\n            throw new Error('Cannot increase frame iteration, the context is empty');\n        }\n    }\n    getWeight(name) {\n        return this.weightMap[name];\n    }\n    addTensorArray(tensorArray) {\n        this.tensorArrayMap[tensorArray.id] = tensorArray;\n    }\n    getTensorArray(id) {\n        return this.tensorArrayMap[id];\n    }\n    addTensorList(tensorList) {\n        this.tensorListMap[tensorList.id] = tensorList;\n    }\n    getTensorList(id) {\n        return this.tensorListMap[id];\n    }\n    dispose(keepIds) {\n        for (const key in this.tensorArrayMap) {\n            this.tensorArrayMap[key].clearAndClose(keepIds);\n        }\n        for (const key in this.tensorListMap) {\n            this.tensorListMap[key].clearAndClose(keepIds);\n        }\n    }\n}\n//# sourceMappingURL=execution_context.js.map"]},"metadata":{},"sourceType":"module"}