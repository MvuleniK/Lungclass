{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from \"../tensor_util_env\";\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from \"../util\";\nimport { tensor } from \"./tensor\";\n\nfunction inTopKAsync_(predictions, targets) {\n  var k,\n      $predictions,\n      $targets,\n      lastDim,\n      predictionsVals,\n      targetsVals,\n      batch,\n      size,\n      precision,\n      b,\n      offset,\n      vals,\n      valAndInd,\n      i,\n      _i,\n      _args = arguments;\n\n  return _regeneratorRuntime.async(function inTopKAsync_$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          k = _args.length > 2 && _args[2] !== undefined ? _args[2] : 1;\n          $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n          $targets = convertToTensor(targets, 'targets', 'inTopK');\n          assert($predictions.rank > 1, function () {\n            return 'inTopK() expects the predictions to be of rank 2 or higher, ' + (\"but got \" + $predictions.rank);\n          });\n          assert($predictions.rank - 1 === $targets.rank, function () {\n            return \"predictions rank should be 1 larger than \" + \"targets rank, but got predictions rank \" + ($predictions.rank + \" and targets rank \" + $targets.rank);\n          });\n          assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, \"predictions's shape should be align with the targets' shape, \" + 'except the last dimension.');\n          lastDim = $predictions.shape[$predictions.shape.length - 1];\n          assert(k > 0 && k <= lastDim, function () {\n            return \"'k' passed to inTopK() must be > 0 && <= the predictions last \" + (\"dimension (\" + lastDim + \"), but got \" + k);\n          });\n          _context.next = 10;\n          return _regeneratorRuntime.awrap($predictions.data());\n\n        case 10:\n          predictionsVals = _context.sent;\n          _context.next = 13;\n          return _regeneratorRuntime.awrap($targets.data());\n\n        case 13:\n          targetsVals = _context.sent;\n          batch = predictionsVals.length / lastDim, size = lastDim;\n          precision = getTypedArrayFromDType('bool', batch);\n          b = 0;\n\n        case 17:\n          if (!(b < batch)) {\n            _context.next = 35;\n            break;\n          }\n\n          offset = b * size;\n          vals = predictionsVals.subarray(offset, offset + size);\n          valAndInd = [];\n\n          for (i = 0; i < vals.length; i++) {\n            valAndInd.push({\n              value: vals[i],\n              index: i\n            });\n          }\n\n          valAndInd.sort(function (a, b) {\n            return b.value - a.value;\n          });\n          precision[b] = 0;\n          _i = 0;\n\n        case 25:\n          if (!(_i < k)) {\n            _context.next = 32;\n            break;\n          }\n\n          if (!(valAndInd[_i].index === targetsVals[b])) {\n            _context.next = 29;\n            break;\n          }\n\n          precision[b] = 1;\n          return _context.abrupt(\"break\", 32);\n\n        case 29:\n          _i++;\n          _context.next = 25;\n          break;\n\n        case 32:\n          b++;\n          _context.next = 17;\n          break;\n\n        case 35:\n          if (predictions !== $predictions) {\n            $predictions.dispose();\n          }\n\n          if (targets !== $targets) {\n            $targets.dispose();\n          }\n\n          return _context.abrupt(\"return\", tensor(precision, $targets.shape, 'bool'));\n\n        case 38:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexport var inTopKAsync = inTopKAsync_;","map":{"version":3,"sources":["../../src/ops/in_top_k.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\nimport { tensor } from './tensor';\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nasync function inTopKAsync_(predictions, targets, k = 1) {\n    const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n    const $targets = convertToTensor(targets, 'targets', 'inTopK');\n    assert($predictions.rank > 1, () => 'inTopK() expects the predictions to be of rank 2 or higher, ' +\n        `but got ${$predictions.rank}`);\n    assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than ` +\n        `targets rank, but got predictions rank ` +\n        `${$predictions.rank} and targets rank ${$targets.rank}`);\n    assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, ` +\n        'except the last dimension.');\n    const lastDim = $predictions.shape[$predictions.shape.length - 1];\n    assert(k > 0 && k <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` +\n        `dimension (${lastDim}), but got ${k}`);\n    const predictionsVals = await $predictions.data();\n    const targetsVals = await $targets.data();\n    // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n    // and look up topK along lastDim.\n    const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n    const precision = getTypedArrayFromDType('bool', batch);\n    for (let b = 0; b < batch; b++) {\n        const offset = b * size;\n        const vals = predictionsVals.subarray(offset, offset + size);\n        const valAndInd = [];\n        for (let i = 0; i < vals.length; i++) {\n            valAndInd.push({ value: vals[i], index: i });\n        }\n        valAndInd.sort((a, b) => b.value - a.value);\n        precision[b] = 0;\n        for (let i = 0; i < k; i++) {\n            if (valAndInd[i].index === targetsVals[b]) {\n                precision[b] = 1;\n                break;\n            }\n        }\n    }\n    if (predictions !== $predictions) {\n        $predictions.dispose();\n    }\n    if (targets !== $targets) {\n        $targets.dispose();\n    }\n    // Output precision has the same shape as targets.\n    return tensor(precision, $targets.shape, 'bool');\n}\nexport const inTopKAsync = inTopKAsync_;\n//# sourceMappingURL=in_top_k.js.map"]},"metadata":{},"sourceType":"module"}