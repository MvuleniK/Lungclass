{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from \"../../engine\";\nimport { CropAndResize } from \"../../kernel_names\";\nimport { convertToTensor } from \"../../tensor_util_env\";\nimport * as util from \"../../util\";\nimport { op } from \"../operation\";\n\nfunction cropAndResize_(image, boxes, boxInd, cropSize) {\n  var method = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'bilinear';\n  var extrapolationValue = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var $image = convertToTensor(image, 'image', 'cropAndResize');\n  var $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n  var $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n  var numBoxes = $boxes.shape[0];\n  util.assert($image.rank === 4, function () {\n    return 'Error in cropAndResize: image must be rank 4,' + (\"but got rank \" + $image.rank + \".\");\n  });\n  util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, function () {\n    return \"Error in cropAndResize: boxes must be have size [\" + numBoxes + \",4] \" + (\"but had shape \" + $boxes.shape + \".\");\n  });\n  util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, function () {\n    return \"Error in cropAndResize: boxInd must be have size [\" + numBoxes + \"] \" + (\"but had shape \" + $boxes.shape + \".\");\n  });\n  util.assert(cropSize.length === 2, function () {\n    return \"Error in cropAndResize: cropSize must be of length 2, but got \" + (\"length \" + cropSize.length + \".\");\n  });\n  util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, function () {\n    return \"cropSize must be atleast [1,1], but was \" + cropSize;\n  });\n  util.assert(method === 'bilinear' || method === 'nearest', function () {\n    return \"method must be bilinear or nearest, but was \" + method;\n  });\n  var inputs = {\n    image: $image,\n    boxes: $boxes,\n    boxInd: $boxInd\n  };\n  var attrs = {\n    method: method,\n    extrapolationValue: extrapolationValue,\n    cropSize: cropSize\n  };\n  var res = ENGINE.runKernel(CropAndResize, inputs, attrs);\n  return res;\n}\n\nexport var cropAndResize = op({\n  cropAndResize_: cropAndResize_\n});","map":{"version":3,"sources":["../../../src/ops/image/crop_and_resize.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR;AACA,SAAQ,aAAR;AAIA,SAAQ,eAAR;AAEA,OAAO,KAAK,IAAZ;AAEA,SAAQ,EAAR;;AAyBA,SAAS,cAAT,CACI,KADJ,EAEI,KAFJ,EAGI,MAHJ,EAII,QAJJ,EAM0B;EAAA,IADtB,MACsB,uEADS,UACT;EAAA,IAAtB,kBAAsB,uEAAD,CAAC;EAExB,IAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,CAA9B;EACA,IAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,EAAkC,SAAlC,CAA9B;EACA,IAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,eAAnB,EAAoC,OAApC,CAA/B;EAEA,IAAM,QAAQ,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAjB;EAEA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,CADpB,EAEI;IAAA,OAAM,qEACc,MAAM,CAAC,IADrB,OAAN;EAAA,CAFJ;EAIA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,CAAhB,IAAqB,MAAM,CAAC,KAAP,CAAa,CAAb,MAAoB,CAD7C,EAEI;IAAA,OAAM,sDAAoD,QAApD,gCACe,MAAM,CAAC,KADtB,OAAN;EAAA,CAFJ;EAIA,IAAI,CAAC,MAAL,CACI,OAAO,CAAC,IAAR,KAAiB,CAAjB,IAAsB,OAAO,CAAC,KAAR,CAAc,CAAd,MAAqB,QAD/C,EAEI;IAAA,OAAM,uDAAqD,QAArD,8BACe,MAAM,CAAC,KADtB,OAAN;EAAA,CAFJ;EAIA,IAAI,CAAC,MAAL,CACI,QAAQ,CAAC,MAAT,KAAoB,CADxB,EAEI;IAAA,OAAM,gFACQ,QAAQ,CAAC,MADjB,OAAN;EAAA,CAFJ;EAIA,IAAI,CAAC,MAAL,CACI,QAAQ,CAAC,CAAD,CAAR,IAAe,CAAf,IAAoB,QAAQ,CAAC,CAAD,CAAR,IAAe,CADvC,EAEI;IAAA,oDAAiD,QAAjD;EAAA,CAFJ;EAGA,IAAI,CAAC,MAAL,CACI,MAAM,KAAK,UAAX,IAAyB,MAAM,KAAK,SADxC,EAEI;IAAA,wDAAqD,MAArD;EAAA,CAFJ;EAIA,IAAM,MAAM,GACc;IAAC,KAAK,EAAE,MAAR;IAAgB,KAAK,EAAE,MAAvB;IAA+B,MAAM,EAAE;EAAvC,CAD1B;EAEA,IAAM,KAAK,GAAuB;IAAC,MAAM,EAAN,MAAD;IAAS,kBAAkB,EAAlB,kBAAT;IAA6B,QAAQ,EAAR;EAA7B,CAAlC;EACA,IAAM,GAAG,GAAG,MAAM,CAAC,SAAP,CACR,aADQ,EACO,MADP,EAER,KAFQ,CAAZ;EAGA,OAAO,GAAP;AACD;;AAED,OAAO,IAAM,aAAa,GAAG,EAAE,CAAC;EAAC,cAAc,EAAd;AAAD,CAAD,CAAxB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { CropAndResize } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { op } from '../operation';\n/**\n * Extracts crops from the input image tensor and resizes them using bilinear\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\n * to a common output size specified by cropSize.\n *\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\n *     where imageHeight and imageWidth must be positive, specifying the\n *     batch of images from which to take crops\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\n *     coordinates of the box in the boxInd[i]'th image in the batch\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\n *     specifying the size to which all crops are resized to.\n * @param method Optional string from `'bilinear' | 'nearest'`,\n *     defaults to bilinear, which specifies the sampling method for resizing\n * @param extrapolationValue A threshold for deciding when to remove boxes based\n *     on score. Defaults to 0.\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction cropAndResize_(image, boxes, boxInd, cropSize, method = 'bilinear', extrapolationValue = 0) {\n    const $image = convertToTensor(image, 'image', 'cropAndResize');\n    const $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n    const $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n    const numBoxes = $boxes.shape[0];\n    util.assert($image.rank === 4, () => 'Error in cropAndResize: image must be rank 4,' +\n        `but got rank ${$image.rank}.`);\n    util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` +\n        `but had shape ${$boxes.shape}.`);\n    util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` +\n        `but had shape ${$boxes.shape}.`);\n    util.assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got ` +\n        `length ${cropSize.length}.`);\n    util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);\n    util.assert(method === 'bilinear' || method === 'nearest', () => `method must be bilinear or nearest, but was ${method}`);\n    const inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };\n    const attrs = { method, extrapolationValue, cropSize };\n    const res = ENGINE.runKernel(CropAndResize, inputs, attrs);\n    return res;\n}\nexport const cropAndResize = op({ cropAndResize_ });\n//# sourceMappingURL=crop_and_resize.js.map"]},"metadata":{},"sourceType":"module"}