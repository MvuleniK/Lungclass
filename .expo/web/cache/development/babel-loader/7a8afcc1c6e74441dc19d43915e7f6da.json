{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES } from \"./keras_format/common\";\nimport { checkStringTypeUnionValue } from \"./utils/generic_utils\";\nvar nameMap = new Map();\nexport function checkDataFormat(value) {\n  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\nexport function checkInterpolationFormat(value) {\n  checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\nexport function checkPaddingMode(value) {\n  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\nexport function checkPoolMode(value) {\n  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\nvar _nameScopeStack = [];\nvar _nameScopeDivider = '/';\nexport function nameScope(name, fn) {\n  _nameScopeStack.push(name);\n\n  try {\n    var val = fn();\n\n    _nameScopeStack.pop();\n\n    return val;\n  } catch (e) {\n    _nameScopeStack.pop();\n\n    throw e;\n  }\n}\n\nfunction currentNameScopePrefix() {\n  if (_nameScopeStack.length === 0) {\n    return '';\n  } else {\n    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n  }\n}\n\nexport function getScopedTensorName(tensorName) {\n  if (!isValidTensorName(tensorName)) {\n    throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n  }\n\n  return currentNameScopePrefix() + tensorName;\n}\nexport function getUniqueTensorName(scopedName) {\n  if (!isValidTensorName(scopedName)) {\n    throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n  }\n\n  if (!nameMap.has(scopedName)) {\n    nameMap.set(scopedName, 0);\n  }\n\n  var index = nameMap.get(scopedName);\n  nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n\n  if (index > 0) {\n    var result = scopedName + \"_\" + index;\n    nameMap.set(result, 1);\n    return result;\n  } else {\n    return scopedName;\n  }\n}\nvar tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\nexport function isValidTensorName(name) {\n  return !!name.match(tensorNameRegex);\n}","map":{"version":3,"sources":["../src/common.ts"],"names":[],"mappings":"AAAA;;;;;;;;AAQG;AAKH,SAAQ,wBAAR,EAAkC,iCAAlC,EAAqE,yBAArE,EAAgG,sBAAhG;AACA,SAAQ,yBAAR;AAKA,IAAM,OAAO,GAAwB,IAAI,GAAJ,EAArC;AAEA,OAAM,SAAU,eAAV,CAA0B,KAA1B,EAAwC;EAC5C,yBAAyB,CAAC,wBAAD,EAA2B,YAA3B,EAAyC,KAAzC,CAAzB;AACD;AAED,OAAM,SAAU,wBAAV,CAAmC,KAAnC,EAAiD;EACrD,yBAAyB,CACrB,iCADqB,EACc,qBADd,EACqC,KADrC,CAAzB;AAED;AAED,OAAM,SAAU,gBAAV,CAA2B,KAA3B,EAAyC;EAC7C,yBAAyB,CAAC,yBAAD,EAA4B,aAA5B,EAA2C,KAA3C,CAAzB;AACD;AAED,OAAM,SAAU,aAAV,CAAwB,KAAxB,EAAsC;EAC1C,yBAAyB,CAAC,sBAAD,EAAyB,UAAzB,EAAqC,KAArC,CAAzB;AACD;AAED,IAAM,eAAe,GAAa,EAAlC;AACA,IAAM,iBAAiB,GAAG,GAA1B;AAKA,OAAM,SAAU,SAAV,CAAuB,IAAvB,EAAqC,EAArC,EAAgD;EACpD,eAAe,CAAC,IAAhB,CAAqB,IAArB;;EACA,IAAI;IACF,IAAM,GAAG,GAAM,EAAE,EAAjB;;IACA,eAAe,CAAC,GAAhB;;IACA,OAAO,GAAP;EACD,CAJD,CAIE,OAAO,CAAP,EAAU;IACV,eAAe,CAAC,GAAhB;;IACA,MAAM,CAAN;EACD;AACF;;AAKD,SAAS,sBAAT,GAA+B;EAC7B,IAAI,eAAe,CAAC,MAAhB,KAA2B,CAA/B,EAAkC;IAChC,OAAO,EAAP;EACD,CAFD,MAEO;IACL,OAAO,eAAe,CAAC,IAAhB,CAAqB,iBAArB,IAA0C,iBAAjD;EACD;AACF;;AAOD,OAAM,SAAU,mBAAV,CAA8B,UAA9B,EAAgD;EACpD,IAAI,CAAC,iBAAiB,CAAC,UAAD,CAAtB,EAAoC;IAClC,MAAM,IAAI,KAAJ,CAAU,gCAAgC,UAAhC,GAA6C,IAAvD,CAAN;EACD;;EACD,OAAO,sBAAsB,KAAK,UAAlC;AACD;AAYD,OAAM,SAAU,mBAAV,CAA8B,UAA9B,EAAgD;EACpD,IAAI,CAAC,iBAAiB,CAAC,UAAD,CAAtB,EAAoC;IAClC,MAAM,IAAI,KAAJ,CAAU,gCAAgC,UAAhC,GAA6C,IAAvD,CAAN;EACD;;EACD,IAAI,CAAC,OAAO,CAAC,GAAR,CAAY,UAAZ,CAAL,EAA8B;IAC5B,OAAO,CAAC,GAAR,CAAY,UAAZ,EAAwB,CAAxB;EACD;;EACD,IAAM,KAAK,GAAG,OAAO,CAAC,GAAR,CAAY,UAAZ,CAAd;EACA,OAAO,CAAC,GAAR,CAAY,UAAZ,EAAwB,OAAO,CAAC,GAAR,CAAY,UAAZ,IAA0B,CAAlD;;EAEA,IAAI,KAAK,GAAG,CAAZ,EAAe;IACb,IAAM,MAAM,GAAM,UAAN,SAAoB,KAAhC;IAGA,OAAO,CAAC,GAAR,CAAY,MAAZ,EAAoB,CAApB;IACA,OAAO,MAAP;EACD,CAND,MAMO;IACL,OAAO,UAAP;EACD;AACF;AAED,IAAM,eAAe,GAAG,IAAI,MAAJ,CAAW,iCAAX,CAAxB;AAOA,OAAM,SAAU,iBAAV,CAA4B,IAA5B,EAAwC;EAC5C,OAAO,CAAC,CAAC,IAAI,CAAC,KAAL,CAAW,eAAX,CAAT;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport { VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES } from './keras_format/common';\nimport { checkStringTypeUnionValue } from './utils/generic_utils';\n// A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\nconst nameMap = new Map();\nexport function checkDataFormat(value) {\n    checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\nexport function checkInterpolationFormat(value) {\n    checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\nexport function checkPaddingMode(value) {\n    checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\nexport function checkPoolMode(value) {\n    checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\nconst _nameScopeStack = [];\nconst _nameScopeDivider = '/';\n/**\n * Enter namescope, which can be nested.\n */\nexport function nameScope(name, fn) {\n    _nameScopeStack.push(name);\n    try {\n        const val = fn();\n        _nameScopeStack.pop();\n        return val;\n    }\n    catch (e) {\n        _nameScopeStack.pop();\n        throw e;\n    }\n}\n/**\n * Get the current namescope as a flat, concatenated string.\n */\nfunction currentNameScopePrefix() {\n    if (_nameScopeStack.length === 0) {\n        return '';\n    }\n    else {\n        return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n    }\n}\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\nexport function getScopedTensorName(tensorName) {\n    if (!isValidTensorName(tensorName)) {\n        throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n    }\n    return currentNameScopePrefix() + tensorName;\n}\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\nexport function getUniqueTensorName(scopedName) {\n    if (!isValidTensorName(scopedName)) {\n        throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n    }\n    if (!nameMap.has(scopedName)) {\n        nameMap.set(scopedName, 0);\n    }\n    const index = nameMap.get(scopedName);\n    nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n    if (index > 0) {\n        const result = `${scopedName}_${index}`;\n        // Mark the composed name as used in case someone wants\n        // to call getUniqueTensorName(\"name_1\").\n        nameMap.set(result, 1);\n        return result;\n    }\n    else {\n        return scopedName;\n    }\n}\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\nexport function isValidTensorName(name) {\n    return !!name.match(tensorNameRegex);\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}