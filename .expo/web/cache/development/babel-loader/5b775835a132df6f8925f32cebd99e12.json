{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from \"../engine\";\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from \"../util\";\nexport function makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n\n  if (dtype === 'complex64') {\n    throw new Error(\"Cannot construct a complex64 tensor directly. \" + \"Please use tf.complex(real, imag).\");\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    var providedSize = sizeFromShape(shape);\n    var inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, function () {\n      return \"Based on the provided shape, [\" + shape + \"], the tensor should have \" + (providedSize + \" values but has \" + inferredSize);\n    });\n\n    for (var i = 0; i < inferredShape.length; ++i) {\n      var inferred = inferredShape[i];\n      var flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, function () {\n        return \"Error creating a new Tensor. Inferred shape \" + (\"(\" + inferredShape + \") does not match the provided \") + (\"shape (\" + shape + \"). \");\n      });\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}","map":{"version":3,"sources":["../../src/ops/tensor_ops_util.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR;AAIA,SAAQ,MAAR,EAAgB,kCAAhB,EAAoD,OAApD,EAA6D,UAA7D,EAAyE,YAAzE,EAAuF,aAAvF,EAAsG,YAAtG;AAGA,OAAM,SAAU,UAAV,CACF,MADE,EACkB,KADlB,EACmC,aADnC,EAEF,KAFE,EAEc;EAClB,IAAI,KAAK,IAAI,IAAb,EAAmB;IACjB,KAAK,GAAG,UAAU,CAAC,MAAD,CAAlB;EACD;;EACD,IAAI,KAAK,KAAK,WAAd,EAA2B;IACzB,MAAM,IAAI,KAAJ,CACF,uFADE,CAAN;EAGD;;EACD,IAAI,CAAC,YAAY,CAAC,MAAD,CAAb,IAAyB,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAA1B,IACA,OAAO,MAAP,KAAkB,QADlB,IAC8B,OAAO,MAAP,KAAkB,SADhD,IAEA,OAAO,MAAP,KAAkB,QAFtB,EAEgC;IAC9B,MAAM,IAAI,KAAJ,CACF,wEACA,uDAFE,CAAN;EAGD;;EACD,IAAI,KAAK,IAAI,IAAb,EAAmB;IACjB,kCAAkC,CAAC,KAAD,CAAlC;IAEA,IAAM,YAAY,GAAG,aAAa,CAAC,KAAD,CAAlC;IACA,IAAM,YAAY,GAAG,aAAa,CAAC,aAAD,CAAlC;IACA,MAAM,CACF,YAAY,KAAK,YADf,EAEF;MAAA,OACI,mCAAiC,KAAjC,mCACG,YADH,wBACkC,YADlC,CADJ;IAAA,CAFE,CAAN;;IAMA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,aAAa,CAAC,MAAlC,EAA0C,EAAE,CAA5C,EAA+C;MAC7C,IAAM,QAAQ,GAAG,aAAa,CAAC,CAAD,CAA9B;MACA,IAAM,iBAAiB,GAAG,CAAC,KAAK,aAAa,CAAC,MAAd,GAAuB,CAA7B,GACtB,QAAQ,KAAK,aAAa,CAAC,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAD,CADJ,GAEtB,IAFJ;MAGA,MAAM,CACF,aAAa,CAAC,CAAD,CAAb,KAAqB,KAAK,CAAC,CAAD,CAA1B,IAAiC,CAAC,iBADhC,EAEF;QAAA,OAAM,wDACE,aADF,oDAEQ,KAFR,SAAN;MAAA,CAFE,CAAN;IAKD;EACF;;EAED,IAAI,CAAC,YAAY,CAAC,MAAD,CAAb,IAAyB,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAA9B,EAAqD;IACnD,MAAM,GAAG,CAAC,MAAD,CAAT;EACD;;EAED,KAAK,GAAG,KAAK,IAAI,aAAjB;EACA,MAAM,GAAG,KAAK,KAAK,QAAV,GACL,YAAY,CAAC,MAAD,EAAS,KAAT,CADP,GAEL,OAAO,CAAC,MAAD,EAAqB,EAArB,EAAyB,IAAzB,CAFX;EAGA,OAAO,MAAM,CAAC,UAAP,CAAkB,MAAlB,EAAwC,KAAxC,EAA+C,KAA/C,CAAP;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(values, shape, inferredShape, dtype) {\n    if (dtype == null) {\n        dtype = inferDtype(values);\n    }\n    if (dtype === 'complex64') {\n        throw new Error(`Cannot construct a complex64 tensor directly. ` +\n            `Please use tf.complex(real, imag).`);\n    }\n    if (!isTypedArray(values) && !Array.isArray(values) &&\n        typeof values !== 'number' && typeof values !== 'boolean' &&\n        typeof values !== 'string') {\n        throw new Error('values passed to tensor(values) must be a number/boolean/string or ' +\n            'an array of numbers/booleans/strings, or a TypedArray');\n    }\n    if (shape != null) {\n        assertNonNegativeIntegerDimensions(shape);\n        const providedSize = sizeFromShape(shape);\n        const inferredSize = sizeFromShape(inferredShape);\n        assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n        for (let i = 0; i < inferredShape.length; ++i) {\n            const inferred = inferredShape[i];\n            const flatDimsDontMatch = i === inferredShape.length - 1 ?\n                inferred !== sizeFromShape(shape.slice(i)) :\n                true;\n            assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` +\n                `(${inferredShape}) does not match the provided ` +\n                `shape (${shape}). `);\n        }\n    }\n    if (!isTypedArray(values) && !Array.isArray(values)) {\n        values = [values];\n    }\n    shape = shape || inferredShape;\n    values = dtype !== 'string' ?\n        toTypedArray(values, dtype) :\n        flatten(values, [], true);\n    return ENGINE.makeTensor(values, shape, dtype);\n}\n//# sourceMappingURL=tensor_ops_util.js.map"]},"metadata":{},"sourceType":"module"}