{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assertTypesMatch } from \"../tensor_util\";\nimport { convertToTensor } from \"../tensor_util_env\";\nimport * as util from \"../util\";\nimport { add } from \"./add\";\nimport { div } from \"./div\";\nimport { mul } from \"./mul\";\nimport { op } from \"./operation\";\nimport { pow } from \"./pow\";\nimport { scalar } from \"./scalar\";\nimport { sub } from \"./sub\";\n\nfunction movingAverage_(v, x, decay, step) {\n  var zeroDebias = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var $v = convertToTensor(v, 'v', 'movingAverage');\n  var $x = convertToTensor(x, 'x', 'movingAverage');\n  var $decay = convertToTensor(decay, 'decay', 'movingAverage');\n  assertTypesMatch($v, $x);\n  util.assert(util.arraysEqual($v.shape, $x.shape), function () {\n    return 'Shape mismatch in v and x';\n  });\n  var one = scalar(1);\n  var oneMinusDecay = sub(one, $decay);\n  var update = mul(sub($x, $v), oneMinusDecay);\n\n  if (zeroDebias) {\n    util.assert(step != null, function () {\n      return 'When using zeroDebias: true, step is required.';\n    });\n    var $step = convertToTensor(step, 'step', 'movingAverage');\n    update = div(update, sub(one, pow($decay, $step)));\n  }\n\n  return add($v, update);\n}\n\nexport var movingAverage = op({\n  movingAverage_: movingAverage_\n});","map":{"version":3,"sources":["../../src/ops/moving_average.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAGH,SAAQ,gBAAR;AACA,SAAQ,eAAR;AAEA,OAAO,KAAK,IAAZ;AAEA,SAAQ,GAAR;AACA,SAAQ,GAAR;AACA,SAAQ,GAAR;AACA,SAAQ,EAAR;AACA,SAAQ,GAAR;AACA,SAAQ,MAAR;AACA,SAAQ,GAAR;;AA8BA,SAAS,cAAT,CACI,CADJ,EACqB,CADrB,EACsC,KADtC,EAEI,IAFJ,EAE2C;EAAA,IAAjB,UAAiB,uEAAJ,IAAI;EACzC,IAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,eAAT,CAA1B;EACA,IAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,eAAT,CAA1B;EACA,IAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,CAA9B;EAEA,gBAAgB,CAAC,EAAD,EAAK,EAAL,CAAhB;EACA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,WAAL,CAAiB,EAAE,CAAC,KAApB,EAA2B,EAAE,CAAC,KAA9B,CADJ,EAC0C;IAAA,OAAM,2BAAN;EAAA,CAD1C;EAGA,IAAM,GAAG,GAAG,MAAM,CAAC,CAAD,CAAlB;EACA,IAAM,aAAa,GAAG,GAAG,CAAC,GAAD,EAAM,MAAN,CAAzB;EAEA,IAAI,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,EAAD,EAAK,EAAL,CAAJ,EAAc,aAAd,CAAhB;;EACA,IAAI,UAAJ,EAAgB;IACd,IAAI,CAAC,MAAL,CACI,IAAI,IAAI,IADZ,EACkB;MAAA,OAAM,gDAAN;IAAA,CADlB;IAEA,IAAM,KAAK,GAAG,eAAe,CAAC,IAAD,EAAO,MAAP,EAAe,eAAf,CAA7B;IACA,MAAM,GAAG,GAAG,CAAC,MAAD,EAAS,GAAG,CAAC,GAAD,EAAM,GAAG,CAAC,MAAD,EAAS,KAAT,CAAT,CAAZ,CAAZ;EACD;;EACD,OAAO,GAAG,CAAC,EAAD,EAAK,MAAL,CAAV;AACD;;AAED,OAAO,IAAM,aAAa,GAAG,EAAE,CAAC;EAAC,cAAc,EAAd;AAAD,CAAD,CAAxB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assertTypesMatch } from '../tensor_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { add } from './add';\nimport { div } from './div';\nimport { mul } from './mul';\nimport { op } from './operation';\nimport { pow } from './pow';\nimport { scalar } from './scalar';\nimport { sub } from './sub';\n/**\n * Compute the moving average of a variable.\n *\n * Without zeroDebias, the moving average operation is defined by:\n *   `v += delta`\n * where\n *   `delta = (1 - decay) * (x - v)`\n *\n * With zeroDebias (default), the `delta` term is scaled to debias the\n * effect of the (assumed) zero-initialization of `v`.\n *   `delta /= (1 - decay ^ step)`\n *\n * For more details on the zero-debiasing algorithm, see:\n *   https://arxiv.org/abs/1412.6980\n *\n * Note that this function is completely stateless and does not keep track of\n * step count. The step count needs to be maintained by the caller and passed\n * in as `step`.\n *\n * @param v The current moving average value.\n * @param x New input value, must have the same shape and dtype as `v`.\n * @param decay The decay factor. Typical values are 0.95 and 0.99.\n * @param step Step count.\n * @param zeroDebias: Whether zeroDebias is to be performed (default: `true`).\n * @returns The new moving average value.\n *\n * @doc {heading: 'Operations', subheading: 'Moving Average'}\n */\nfunction movingAverage_(v, x, decay, step, zeroDebias = true) {\n    const $v = convertToTensor(v, 'v', 'movingAverage');\n    const $x = convertToTensor(x, 'x', 'movingAverage');\n    const $decay = convertToTensor(decay, 'decay', 'movingAverage');\n    assertTypesMatch($v, $x);\n    util.assert(util.arraysEqual($v.shape, $x.shape), () => 'Shape mismatch in v and x');\n    const one = scalar(1);\n    const oneMinusDecay = sub(one, $decay);\n    let update = mul(sub($x, $v), oneMinusDecay);\n    if (zeroDebias) {\n        util.assert(step != null, () => 'When using zeroDebias: true, step is required.');\n        const $step = convertToTensor(step, 'step', 'movingAverage');\n        update = div(update, sub(one, pow($decay, $step)));\n    }\n    return add($v, update);\n}\nexport const movingAverage = op({ movingAverage_ });\n//# sourceMappingURL=moving_average.js.map"]},"metadata":{},"sourceType":"module"}