{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"C:\\\\Users\\\\mlab\\\\Aireact\\\\Lungclass\\\\node_modules\\\\@tensorflow\\\\tfjs-react-native\\\\dist\\\\camera\\\\camera_stream.js\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as React from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport PixelRatio from \"react-native-web/dist/exports/PixelRatio\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { Camera } from 'expo-camera';\nimport { GLView } from 'expo-gl';\nimport { fromTexture, renderToGLView, detectGLCapabilities } from \"./camera\";\nvar DEFAULT_AUTORENDER = true;\nvar DEFAULT_RESIZE_DEPTH = 3;\nexport function cameraWithTensors(CameraComponent) {\n  return function (_React$Component) {\n    _inherits(CameraWithTensorStream, _React$Component);\n\n    var _super = _createSuper(CameraWithTensorStream);\n\n    function CameraWithTensorStream(props) {\n      var _this;\n\n      _classCallCheck(this, CameraWithTensorStream);\n\n      _this = _super.call(this, props);\n      _this.onCameraLayout = _this.onCameraLayout.bind(_assertThisInitialized(_this));\n      _this.onGLContextCreate = _this.onGLContextCreate.bind(_assertThisInitialized(_this));\n      _this.state = {\n        cameraLayout: null\n      };\n      return _this;\n    }\n\n    _createClass(CameraWithTensorStream, [{\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        cancelAnimationFrame(this.rafID);\n\n        if (this.glContext) {\n          GLView.destroyContextAsync(this.glContext);\n        }\n\n        this.camera = null;\n        this.glView = null;\n        this.glContext = null;\n      }\n    }, {\n      key: \"onCameraLayout\",\n      value: function onCameraLayout(event) {\n        var _event$nativeEvent$la = event.nativeEvent.layout,\n            x = _event$nativeEvent$la.x,\n            y = _event$nativeEvent$la.y,\n            width = _event$nativeEvent$la.width,\n            height = _event$nativeEvent$la.height;\n        this.setState({\n          cameraLayout: {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          }\n        });\n      }\n    }, {\n      key: \"createCameraTexture\",\n      value: function createCameraTexture() {\n        return _regeneratorRuntime.async(function createCameraTexture$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.glView != null && this.camera != null)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.glView.createCameraTextureAsync(this.camera));\n\n              case 4:\n                throw new Error('Expo GL context or camera not available');\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, null, this, null, Promise);\n      }\n    }, {\n      key: \"onGLContextCreate\",\n      value: function onGLContextCreate(gl) {\n        var _this2 = this;\n\n        var _marked, cameraTexture, autorender, updatePreview, renderLoop, _this$props, resizeHeight, resizeWidth, resizeDepth, cameraTextureHeight, cameraTextureWidth, cameraStreamView, nextFrameGenerator, nextFrameIterator;\n\n        return _regeneratorRuntime.async(function onGLContextCreate$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                nextFrameGenerator = function _nextFrameGenerator() {\n                  var RGBA_DEPTH, textureDims, targetDims, imageTensor;\n                  return _regeneratorRuntime.wrap(function nextFrameGenerator$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          RGBA_DEPTH = 4;\n                          textureDims = {\n                            height: cameraTextureHeight,\n                            width: cameraTextureWidth,\n                            depth: RGBA_DEPTH\n                          };\n                          targetDims = {\n                            height: resizeHeight,\n                            width: resizeWidth,\n                            depth: resizeDepth || DEFAULT_RESIZE_DEPTH\n                          };\n\n                        case 3:\n                          if (!(cameraStreamView.glContext != null)) {\n                            _context2.next = 9;\n                            break;\n                          }\n\n                          imageTensor = fromTexture(gl, cameraTexture, textureDims, targetDims);\n                          _context2.next = 7;\n                          return imageTensor;\n\n                        case 7:\n                          _context2.next = 3;\n                          break;\n\n                        case 9:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _marked);\n                };\n\n                _marked = _regeneratorRuntime.mark(nextFrameGenerator);\n                this.glContext = gl;\n                _context3.next = 5;\n                return _regeneratorRuntime.awrap(this.createCameraTexture());\n\n              case 5:\n                cameraTexture = _context3.sent;\n                _context3.next = 8;\n                return _regeneratorRuntime.awrap(detectGLCapabilities(gl));\n\n              case 8:\n                autorender = this.props.autorender != null ? this.props.autorender : DEFAULT_AUTORENDER;\n                updatePreview = this.previewUpdateFunc(gl, cameraTexture);\n\n                if (autorender) {\n                  renderLoop = function renderLoop() {\n                    updatePreview();\n                    gl.endFrameEXP();\n                    _this2.rafID = requestAnimationFrame(renderLoop);\n                  };\n\n                  renderLoop();\n                }\n\n                _this$props = this.props, resizeHeight = _this$props.resizeHeight, resizeWidth = _this$props.resizeWidth, resizeDepth = _this$props.resizeDepth, cameraTextureHeight = _this$props.cameraTextureHeight, cameraTextureWidth = _this$props.cameraTextureWidth;\n                cameraStreamView = this;\n                nextFrameIterator = nextFrameGenerator();\n                this.props.onReady(nextFrameIterator, updatePreview, gl, cameraTexture);\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, null, this, null, Promise);\n      }\n    }, {\n      key: \"previewUpdateFunc\",\n      value: function previewUpdateFunc(gl, cameraTexture) {\n        var _this3 = this;\n\n        var renderFunc = function renderFunc() {\n          var cameraLayout = _this3.state.cameraLayout;\n          var width = PixelRatio.getPixelSizeForLayoutSize(cameraLayout.width);\n          var height = PixelRatio.getPixelSizeForLayoutSize(cameraLayout.height);\n          var isFrontCamera = _this3.camera.props.type === Camera.Constants.Type.front;\n          var flipHorizontal = Platform.OS === 'ios' && isFrontCamera ? false : true;\n          renderToGLView(gl, cameraTexture, {\n            width: width,\n            height: height\n          }, flipHorizontal);\n        };\n\n        return renderFunc.bind(this);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this4 = this;\n\n        var cameraLayout = this.state.cameraLayout;\n        var tensorCameraPropMap = {\n          cameraTextureWidth: null,\n          cameraTextureHeight: null,\n          resizeWidth: null,\n          resizeHeight: null,\n          resizeDepth: null,\n          autorender: null,\n          onReady: null\n        };\n        var tensorCameraPropKeys = Object.keys(tensorCameraPropMap);\n        var cameraProps = {};\n        var allProps = Object.keys(this.props);\n\n        for (var i = 0; i < allProps.length; i++) {\n          var key = allProps[i];\n\n          if (!tensorCameraPropKeys.includes(key)) {\n            cameraProps[key] = this.props[key];\n          }\n        }\n\n        var onlayout = this.props.onLayout ? function (e) {\n          _this4.props.onLayout(e);\n\n          _this4.onCameraLayout(e);\n        } : this.onCameraLayout;\n        cameraProps.onLayout = onlayout;\n        var cameraComp = React.createElement(CameraComponent, _extends({\n          key: \"camera-with-tensor-camera-view\"\n        }, cameraProps, {\n          ref: function ref(_ref) {\n            return _this4.camera = _ref;\n          },\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 281,\n            columnNumber: 13\n          }\n        }));\n        var glViewComponent = null;\n\n        if (cameraLayout != null) {\n          var styles = StyleSheet.create({\n            glView: {\n              position: 'absolute',\n              left: cameraLayout.x,\n              top: cameraLayout.y,\n              width: cameraLayout.width,\n              height: cameraLayout.height,\n              zIndex: this.props.style.zIndex ? parseInt(this.props.style.zIndex, 10) + 10 : 10\n            }\n          });\n          glViewComponent = React.createElement(GLView, {\n            key: \"camera-with-tensor-gl-view\",\n            style: styles.glView,\n            onContextCreate: this.onGLContextCreate,\n            ref: function ref(_ref2) {\n              return _this4.glView = _ref2;\n            },\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 296,\n              columnNumber: 36\n            }\n          });\n        }\n\n        return [cameraComp, glViewComponent];\n      }\n    }]);\n\n    return CameraWithTensorStream;\n  }(React.Component);\n}","map":{"version":3,"sources":["../../src/camera/camera_stream.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as React from 'react';\nimport { StyleSheet, PixelRatio, Platform } from 'react-native';\nimport { Camera } from 'expo-camera';\nimport { GLView } from 'expo-gl';\nimport { fromTexture, renderToGLView, detectGLCapabilities } from './camera';\nconst DEFAULT_AUTORENDER = true;\nconst DEFAULT_RESIZE_DEPTH = 3;\n/**\n * A higher-order-component (HOC) that augments the [Expo.Camera](https://docs.expo.io/versions/latest/sdk/camera/)\n * component with the ability to yield tensors representing the camera stream.\n *\n * Because the camera data will be consumed in the process, the original\n * camera component will not render any content. This component provides\n * options that can be used to render the camera preview.\n *\n * Notably the component allows on-the-fly resizing of the camera image to\n * smaller dimensions, this speeds up data transfer between the native and\n * javascript threads immensely.\n *\n * __In addition to__ all the props taken by Expo.Camera. The returned\n * component takes the following props\n *\n * - __cameraTextureWidth__: number — the width the camera preview texture\n *   (see example and note below)\n * - __cameraTextureHeight__: number — the height the camera preview texture\n *   (see example and note below)\n * - __resizeWidth__: number — the width of the output tensor\n * - __resizeHeight__: number — the height of the output tensor\n * - __resizeDepth__: number — the depth (num of channels) of the output tensor.\n *    Should be 3 or 4.\n * - __autorender__: boolean — if true the view will be automatically updated\n *   with the contents of the camera. Set this to false if you want more direct\n *   control on when rendering happens.\n * - __onReady__: (\n *    images: IterableIterator<tf.Tensor3D>,\n *    updateCameraPreview: () => void,\n *    gl: ExpoWebGLRenderingContext,\n *    cameraTexture: WebGLTexture\n *  ) => void — When the component is mounted and ready this callback will\n *  be called and recieve the following 3 elements:\n *    - __images__ is a (iterator)[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators]\n *      that yields tensors representing the camera image on demand.\n *    - __updateCameraPreview__ is a function that will update the WebGL render\n *      buffer with the contents of the camera. Not needed when `autorender`\n *      is true\n *    - __gl__ is the ExpoWebGl context used to do the rendering. After calling\n *      `updateCameraPreview` and any other operations you want to synchronize\n *      to the camera rendering you must call gl.endFrameExp() to display it\n *      on the screen. This is also provided in case you want to do other\n *      rendering using WebGL. Not needed when `autorender` is true.\n *    - __cameraTexture__ The underlying cameraTexture. This can be used to\n *      implement your own __updateCameraPreview__.\n *\n * ```js\n * import { Camera } from 'expo-camera';\n * import { cameraWithTensors } from '@tensorflow/tfjs-react-native';\n *\n * const TensorCamera = cameraWithTensors(Camera);\n *\n * class MyComponent {\n *\n *   handleCameraStream(images, updatePreview, gl) {\n *     const loop = async () => {\n *       const nextImageTensor = images.next().value\n *\n *       //\n *       // do something with tensor here\n *       //\n *\n *       // if autorender is false you need the following two lines.\n *       // updatePreview();\n *       // gl.endFrameEXP();\n *\n *       requestAnimationFrame(loop);\n *     }\n *     loop();\n *   }\n *\n *   render() {\n *    // Currently expo does not support automatically determining the\n *    // resolution of the camera texture used. So it must be determined\n *    // empirically for the supported devices and preview size.\n *\n *    let textureDims;\n *    if (Platform.OS === 'ios') {\n *     textureDims = {\n *       height: 1920,\n *       width: 1080,\n *     };\n *    } else {\n *     textureDims = {\n *       height: 1200,\n *       width: 1600,\n *     };\n *    }\n *\n *    return <View>\n *      <TensorCamera\n *       // Standard Camera props\n *       style={styles.camera}\n *       type={Camera.Constants.Type.front}\n *       // Tensor related props\n *       cameraTextureHeight={textureDims.height}\n *       cameraTextureWidth={textureDims.width}\n *       resizeHeight={200}\n *       resizeWidth={152}\n *       resizeDepth={3}\n *       onReady={this.handleCameraStream}\n *       autorender={true}\n *      />\n *    </View>\n *   }\n * }\n * ```\n *\n * @param CameraComponent an expo Camera component constructor\n */\n/** @doc {heading: 'Media', subheading: 'Camera'} */\nexport function cameraWithTensors(\n// tslint:disable-next-line: variable-name\nCameraComponent) {\n    return class CameraWithTensorStream extends React.Component {\n        constructor(props) {\n            super(props);\n            this.onCameraLayout = this.onCameraLayout.bind(this);\n            this.onGLContextCreate = this.onGLContextCreate.bind(this);\n            this.state = {\n                cameraLayout: null,\n            };\n        }\n        componentWillUnmount() {\n            cancelAnimationFrame(this.rafID);\n            if (this.glContext) {\n                GLView.destroyContextAsync(this.glContext);\n            }\n            this.camera = null;\n            this.glView = null;\n            this.glContext = null;\n        }\n        /*\n         * Measure the camera component when it is laid out so that we can overlay\n         * the GLView.\n         */\n        onCameraLayout(event) {\n            const { x, y, width, height } = event.nativeEvent.layout;\n            this.setState({\n                cameraLayout: { x, y, width, height },\n            });\n        }\n        /**\n         * Creates a WebGL texture that is updated by the underlying platform to\n         * contain the contents of the camera.\n         */\n        async createCameraTexture() {\n            if (this.glView != null && this.camera != null) {\n                //@ts-ignore\n                return this.glView.createCameraTextureAsync(this.camera);\n            }\n            else {\n                throw new Error('Expo GL context or camera not available');\n            }\n        }\n        /**\n         * Callback for GL context creation. We do mose of the work of setting\n         * up the component here.\n         * @param gl\n         */\n        async onGLContextCreate(gl) {\n            this.glContext = gl;\n            const cameraTexture = await this.createCameraTexture();\n            await detectGLCapabilities(gl);\n            // Optionally set up a render loop that just displays the camera texture\n            // to the GLView.\n            const autorender = this.props.autorender != null\n                ? this.props.autorender\n                : DEFAULT_AUTORENDER;\n            const updatePreview = this.previewUpdateFunc(gl, cameraTexture);\n            if (autorender) {\n                const renderLoop = () => {\n                    updatePreview();\n                    gl.endFrameEXP();\n                    this.rafID = requestAnimationFrame(renderLoop);\n                };\n                renderLoop();\n            }\n            const { resizeHeight, resizeWidth, resizeDepth, cameraTextureHeight, cameraTextureWidth, } = this.props;\n            //\n            //  Set up a generator function that yields tensors representing the\n            // camera on demand.\n            //\n            const cameraStreamView = this;\n            function* nextFrameGenerator() {\n                const RGBA_DEPTH = 4;\n                const textureDims = {\n                    height: cameraTextureHeight,\n                    width: cameraTextureWidth,\n                    depth: RGBA_DEPTH,\n                };\n                const targetDims = {\n                    height: resizeHeight,\n                    width: resizeWidth,\n                    depth: resizeDepth || DEFAULT_RESIZE_DEPTH,\n                };\n                while (cameraStreamView.glContext != null) {\n                    const imageTensor = fromTexture(gl, cameraTexture, textureDims, targetDims);\n                    yield imageTensor;\n                }\n            }\n            const nextFrameIterator = nextFrameGenerator();\n            // Pass the utility functions to the caller provided callback\n            this.props.onReady(nextFrameIterator, updatePreview, gl, cameraTexture);\n        }\n        /**\n         * Helper function that can be used to update the GLView framebuffer.\n         *\n         * @param gl the open gl texture to render to\n         * @param cameraTexture the texture to draw.\n         */\n        previewUpdateFunc(gl, cameraTexture) {\n            const renderFunc = () => {\n                const { cameraLayout } = this.state;\n                const width = PixelRatio.getPixelSizeForLayoutSize(cameraLayout.width);\n                const height = PixelRatio.getPixelSizeForLayoutSize(cameraLayout.height);\n                const isFrontCamera = this.camera.props.type === Camera.Constants.Type.front;\n                const flipHorizontal = Platform.OS === 'ios' && isFrontCamera ? false : true;\n                renderToGLView(gl, cameraTexture, { width, height }, flipHorizontal);\n            };\n            return renderFunc.bind(this);\n        }\n        /**\n         * Render the component\n         */\n        render() {\n            const { cameraLayout } = this.state;\n            // Before passing props into the original wrapped component we want to\n            // remove the props that we augment the component with.\n            // Use this object to use typescript to check that we are removing\n            // all the tensorCamera properties.\n            const tensorCameraPropMap = {\n                cameraTextureWidth: null,\n                cameraTextureHeight: null,\n                resizeWidth: null,\n                resizeHeight: null,\n                resizeDepth: null,\n                autorender: null,\n                onReady: null,\n            };\n            const tensorCameraPropKeys = Object.keys(tensorCameraPropMap);\n            const cameraProps = {};\n            const allProps = Object.keys(this.props);\n            for (let i = 0; i < allProps.length; i++) {\n                const key = allProps[i];\n                if (!tensorCameraPropKeys.includes(key)) {\n                    cameraProps[key] = this.props[key];\n                }\n            }\n            // Set up an on layout handler\n            const onlayout = this.props.onLayout ? (e) => {\n                this.props.onLayout(e);\n                this.onCameraLayout(e);\n            } : this.onCameraLayout;\n            cameraProps.onLayout = onlayout;\n            const cameraComp = (\n            //@ts-ignore see https://github.com/microsoft/TypeScript/issues/30650\n            <CameraComponent key='camera-with-tensor-camera-view' {...(cameraProps)} ref={(ref) => (this.camera = ref)}/>);\n            // Create the glView if the camera has mounted.\n            let glViewComponent = null;\n            if (cameraLayout != null) {\n                const styles = StyleSheet.create({\n                    glView: {\n                        position: 'absolute',\n                        left: cameraLayout.x,\n                        top: cameraLayout.y,\n                        width: cameraLayout.width,\n                        height: cameraLayout.height,\n                        zIndex: this.props.style.zIndex ?\n                            parseInt(this.props.style.zIndex, 10) + 10 : 10,\n                    }\n                });\n                glViewComponent = (<GLView key='camera-with-tensor-gl-view' style={styles.glView} onContextCreate={this.onGLContextCreate} ref={ref => (this.glView = ref)}/>);\n            }\n            return [cameraComp, glViewComponent];\n        }\n    };\n}\n//# sourceMappingURL=camera_stream.js.map"]},"metadata":{},"sourceType":"module"}