{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport * as generic_utils from \"../utils/generic_utils\";\n\nfunction isArrayItemInputOrOutputName(key, index, value) {\n  return (key === 'inboundNodes' || key === 'outputLayers' || key === 'inputLayers') && index === 0 && typeof value === 'string';\n}\n\nexport function convertPythonicToTs(pythonicConfig, key) {\n  if (pythonicConfig === null) {\n    return null;\n  } else if (typeof pythonicConfig === 'string') {\n    return generic_utils.toCamelCase(pythonicConfig);\n  } else if (typeof pythonicConfig === 'number' || typeof pythonicConfig === 'boolean') {\n    return pythonicConfig;\n  } else if (pythonicConfig instanceof Array) {\n    var tsArray = [];\n    var arrayLength = pythonicConfig.length;\n\n    for (var i = 0; i < arrayLength; ++i) {\n      var item = pythonicConfig[i];\n\n      if (isArrayItemInputOrOutputName(key, i, item)) {\n        tsArray.push(item);\n      } else {\n        tsArray.push(convertPythonicToTs(item, key));\n      }\n    }\n\n    return tsArray;\n  } else {\n    var tsDict = {};\n\n    for (var _i = 0, _Object$keys = Object.keys(pythonicConfig); _i < _Object$keys.length; _i++) {\n      var pythonicKey = _Object$keys[_i];\n      var pythonicValue = pythonicConfig[pythonicKey];\n\n      if (pythonicKey === 'name' && typeof pythonicValue === 'string') {\n        tsDict[pythonicKey] = pythonicValue;\n      } else {\n        var tsKey = generic_utils.toCamelCase(pythonicKey);\n        tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);\n      }\n    }\n\n    return tsDict;\n  }\n}\nexport function convertTsToPythonic(tsConfig, key) {\n  if (tsConfig === null || tsConfig === undefined) {\n    return null;\n  } else if (typeof tsConfig === 'string') {\n    return generic_utils.toSnakeCase(tsConfig);\n  } else if (typeof tsConfig === 'number' || typeof tsConfig === 'boolean') {\n    return tsConfig;\n  } else if (tsConfig instanceof Array) {\n    var pyArray = [];\n    var arrayLength = tsConfig.length;\n\n    for (var i = 0; i < arrayLength; ++i) {\n      var item = tsConfig[i];\n\n      if (isArrayItemInputOrOutputName(key, i, item)) {\n        pyArray.push(item);\n      } else {\n        pyArray.push(convertTsToPythonic(item, key));\n      }\n    }\n\n    return pyArray;\n  } else {\n    var pyDict = {};\n\n    for (var _i2 = 0, _Object$keys2 = Object.keys(tsConfig); _i2 < _Object$keys2.length; _i2++) {\n      var tsKey = _Object$keys2[_i2];\n      var tsValue = tsConfig[tsKey];\n      var pyKey = generic_utils.toSnakeCase(tsKey);\n\n      if ((tsKey === 'name' || tsKey === 'className') && typeof tsValue === 'string') {\n        pyDict[pyKey] = tsValue;\n      } else {\n        pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);\n      }\n    }\n\n    return pyDict;\n  }\n}","map":{"version":3,"sources":["../../src/utils/serialization_utils.ts"],"names":[],"mappings":"AAAA;;;;;;;;AAQG;AAUH,OAAO,KAAK,aAAZ;;AAYA,SAAS,4BAAT,CACI,GADJ,EACiB,KADjB,EACgC,KADhC,EACwC;EACtC,OAAO,CAAC,GAAG,KAAK,cAAR,IAA0B,GAAG,KAAK,cAAlC,IACA,GAAG,KAAK,aADT,KAEH,KAAK,KAAK,CAFP,IAEY,OAAO,KAAP,KAAiB,QAFpC;AAGD;;AAQD,OAAM,SAAU,mBAAV,CACF,cADE,EAC2B,GAD3B,EACuC;EAC3C,IAAI,cAAc,KAAK,IAAvB,EAA6B;IAC3B,OAAO,IAAP;EACD,CAFD,MAEO,IAAI,OAAO,cAAP,KAA0B,QAA9B,EAAwC;IAC7C,OAAO,aAAa,CAAC,WAAd,CAA0B,cAA1B,CAAP;EACD,CAFM,MAEA,IACF,OAAO,cAAP,KAA0B,QAA3B,IACC,OAAO,cAAP,KAA0B,SAFxB,EAEoC;IACzC,OAAO,cAAP;EACD,CAJM,MAIA,IAAI,cAAc,YAAY,KAA9B,EAAqC;IAC1C,IAAM,OAAO,GAAG,EAAhB;IACA,IAAM,WAAW,GAAG,cAAc,CAAC,MAAnC;;IACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAApB,EAAiC,EAAE,CAAnC,EAAsC;MACpC,IAAM,IAAI,GAAG,cAAc,CAAC,CAAD,CAA3B;;MACA,IAAI,4BAA4B,CAAC,GAAD,EAAM,CAAN,EAAS,IAAT,CAAhC,EAAgD;QAC9C,OAAO,CAAC,IAAR,CAAa,IAAb;MACD,CAFD,MAEO;QACL,OAAO,CAAC,IAAR,CAAa,mBAAmB,CAAC,IAAD,EAAO,GAAP,CAAhC;MACD;IACF;;IACD,OAAO,OAAP;EACD,CAZM,MAYA;IACL,IAAM,MAAM,GAA6B,EAAzC;;IACA,gCAA0B,MAAM,CAAC,IAAP,CAAY,cAAZ,CAA1B,kCAAuD;MAAlD,IAAM,WAAW,mBAAjB;MACH,IAAM,aAAa,GAAG,cAAc,CAAC,WAAD,CAApC;;MACA,IAAI,WAAW,KAAK,MAAhB,IAA0B,OAAO,aAAP,KAAyB,QAAvD,EAAiE;QAI/D,MAAM,CAAC,WAAD,CAAN,GAAsB,aAAtB;MACD,CALD,MAKO;QACL,IAAM,KAAK,GAAG,aAAa,CAAC,WAAd,CAA0B,WAA1B,CAAd;QACA,MAAM,CAAC,KAAD,CAAN,GAAgB,mBAAmB,CAAC,aAAD,EAAgB,KAAhB,CAAnC;MACD;IACF;;IACD,OAAO,MAAP;EACD;AACF;AAQD,OAAM,SAAU,mBAAV,CACF,QADE,EACuC,GADvC,EACmD;EACvD,IAAI,QAAQ,KAAK,IAAb,IAAqB,QAAQ,KAAK,SAAtC,EAAiD;IAC/C,OAAO,IAAP;EACD,CAFD,MAEO,IAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;IACvC,OAAO,aAAa,CAAC,WAAd,CAA0B,QAA1B,CAAP;EACD,CAFM,MAEA,IACF,OAAO,QAAP,KAAoB,QAArB,IAAmC,OAAO,QAAP,KAAoB,SADpD,EACgE;IACrE,OAAO,QAAP;EACD,CAHM,MAGA,IAAI,QAAQ,YAAY,KAAxB,EAA+B;IACpC,IAAM,OAAO,GAAG,EAAhB;IACA,IAAM,WAAW,GAAG,QAAQ,CAAC,MAA7B;;IACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAApB,EAAiC,EAAE,CAAnC,EAAsC;MACpC,IAAM,IAAI,GAAG,QAAQ,CAAC,CAAD,CAArB;;MACA,IAAI,4BAA4B,CAAC,GAAD,EAAM,CAAN,EAAS,IAAT,CAAhC,EAAgD;QAC9C,OAAO,CAAC,IAAR,CAAa,IAAb;MACD,CAFD,MAEO;QACL,OAAO,CAAC,IAAR,CAAa,mBAAmB,CAAC,IAAD,EAAO,GAAP,CAAhC;MACD;IACF;;IACD,OAAO,OAAP;EACD,CAZM,MAYA;IACL,IAAM,MAAM,GAA6B,EAAzC;;IACA,kCAAoB,MAAM,CAAC,IAAP,CAAY,QAAZ,CAApB,qCAA2C;MAAtC,IAAM,KAAK,qBAAX;MACH,IAAM,OAAO,GAAG,QAAQ,CAAC,KAAD,CAAxB;MACA,IAAM,KAAK,GAAG,aAAa,CAAC,WAAd,CAA0B,KAA1B,CAAd;;MACA,IAAI,CAAC,KAAK,KAAK,MAAV,IAAoB,KAAK,KAAK,WAA/B,KACA,OAAO,OAAP,KAAmB,QADvB,EACiC;QAI/B,MAAM,CAAC,KAAD,CAAN,GAAgB,OAAhB;MACD,CAND,MAMO;QACL,MAAM,CAAC,KAAD,CAAN,GAAgB,mBAAmB,CAAC,OAAD,EAAU,KAAV,CAAnC;MACD;IACF;;IACD,OAAO,MAAP;EACD;AACF","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport * as generic_utils from '../utils/generic_utils';\n// tslint:enable\n/**\n * Test whether a value in an array is the name of a LayersModel or Layer.\n * @param key The key name that the value is found under. Note that the key\n *   may not be at the level immediately above the value, if the value is in a\n *   nested array.\n * @param index Index of the value in the Array that it is found in.\n * @param value The value object.\n * @returns A boolean indicating whether value is a name.\n */\nfunction isArrayItemInputOrOutputName(key, index, value) {\n    return (key === 'inboundNodes' || key === 'outputLayers' ||\n        key === 'inputLayers') &&\n        index === 0 && typeof value === 'string';\n}\n/**\n * Convert a Pythonic config object to TypeScript config object.\n * @param pythonicConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\nexport function convertPythonicToTs(pythonicConfig, key) {\n    if (pythonicConfig === null) {\n        return null;\n    }\n    else if (typeof pythonicConfig === 'string') {\n        return generic_utils.toCamelCase(pythonicConfig);\n    }\n    else if ((typeof pythonicConfig === 'number') ||\n        (typeof pythonicConfig === 'boolean')) {\n        return pythonicConfig;\n    }\n    else if (pythonicConfig instanceof Array) {\n        const tsArray = [];\n        const arrayLength = pythonicConfig.length;\n        for (let i = 0; i < arrayLength; ++i) {\n            const item = pythonicConfig[i];\n            if (isArrayItemInputOrOutputName(key, i, item)) {\n                tsArray.push(item);\n            }\n            else {\n                tsArray.push(convertPythonicToTs(item, key));\n            }\n        }\n        return tsArray;\n    }\n    else {\n        const tsDict = {};\n        for (const pythonicKey of Object.keys(pythonicConfig)) {\n            const pythonicValue = pythonicConfig[pythonicKey];\n            if (pythonicKey === 'name' && typeof pythonicValue === 'string') {\n                // Special case the 'name' key with a string value. Name values, such as\n                // the names of LayersModel and Layer instances, should not undergo the\n                // camel-case conversion.\n                tsDict[pythonicKey] = pythonicValue;\n            }\n            else {\n                const tsKey = generic_utils.toCamelCase(pythonicKey);\n                tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);\n            }\n        }\n        return tsDict;\n    }\n}\n/**\n * Convert a TypeScript config object to Python config object.\n * @param tsConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\nexport function convertTsToPythonic(tsConfig, key) {\n    if (tsConfig === null || tsConfig === undefined) {\n        return null;\n    }\n    else if (typeof tsConfig === 'string') {\n        return generic_utils.toSnakeCase(tsConfig);\n    }\n    else if ((typeof tsConfig === 'number') || (typeof tsConfig === 'boolean')) {\n        return tsConfig;\n    }\n    else if (tsConfig instanceof Array) {\n        const pyArray = [];\n        const arrayLength = tsConfig.length;\n        for (let i = 0; i < arrayLength; ++i) {\n            const item = tsConfig[i];\n            if (isArrayItemInputOrOutputName(key, i, item)) {\n                pyArray.push(item);\n            }\n            else {\n                pyArray.push(convertTsToPythonic(item, key));\n            }\n        }\n        return pyArray;\n    }\n    else {\n        const pyDict = {};\n        for (const tsKey of Object.keys(tsConfig)) {\n            const tsValue = tsConfig[tsKey];\n            const pyKey = generic_utils.toSnakeCase(tsKey);\n            if ((tsKey === 'name' || tsKey === 'className') &&\n                typeof tsValue === 'string') {\n                // Special case the 'name' key with a string value. Name values, such as\n                // the names of LayersModel and Layer instances, should not undergo the\n                // snake-case conversion.\n                pyDict[pyKey] = tsValue;\n            }\n            else {\n                pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);\n            }\n        }\n        return pyDict;\n    }\n}\n//# sourceMappingURL=serialization_utils.js.map"]},"metadata":{},"sourceType":"module"}