{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { getCoordsDataType } from \"./shader_compiler\";\nexport var CumSumProgram = function () {\n  function CumSumProgram(shape, exclusive, reverse) {\n    _classCallCheck(this, CumSumProgram);\n\n    this.variableNames = ['x'];\n    this.outputShape = shape;\n    var rank = shape.length;\n    var val = exclusive ? '0.0' : \"getX(\" + getCoords(rank, 'coords') + \")\";\n    var length = shape[shape.length - 1];\n    var condition = '';\n    var idxString = '';\n\n    if (exclusive) {\n      condition = reverse ? \"end != \" + (length - 1) : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? \"end + pow2 < \" + length : 'end >= pow2';\n      idxString = reverse ? 'end + pow2' : 'end - pow2';\n    }\n\n    this.userCode = \"\\n      uniform float index;\\n      void main() {\\n        \" + getCoordsDataType(rank) + \" coords = getOutputCoords();\\n        int end = \" + getFinalCoord(rank, 'coords') + \";\\n        float val = \" + val + \";\\n        int pow2 = int(pow(2.0, index));\\n        if (\" + condition + \") {\\n          int idx = \" + idxString + \";\\n          \" + getFinalCoord(rank, 'coords') + \" = idx;\\n          val += getX(\" + getCoords(rank, 'coords') + \");\\n        }\\n        setOutput(val);\\n      }\\n    \";\n  }\n\n  _createClass(CumSumProgram, [{\n    key: \"getCustomSetupFunc\",\n    value: function getCustomSetupFunc(index) {\n      var _this = this;\n\n      return function (gpgpu, webGLProgram) {\n        if (_this.index == null) {\n          _this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n        }\n\n        gpgpu.gl.uniform1f(_this.index, index);\n      };\n    }\n  }]);\n\n  return CumSumProgram;\n}();\n\nfunction getCoords(rank, name) {\n  if (rank === 1) {\n    return \"\" + name;\n  } else if (rank === 2) {\n    return name + \".x, \" + name + \".y\";\n  } else if (rank === 3) {\n    return name + \".x, \" + name + \".y, \" + name + \".z\";\n  } else if (rank === 4) {\n    return name + \".x, \" + name + \".y, \" + name + \".z, \" + name + \".w\";\n  } else {\n    throw Error(\"Cumulative sum for rank \" + rank + \" is not yet supported\");\n  }\n}\n\nfunction getFinalCoord(rank, name) {\n  if (rank === 1) {\n    return \"\" + name;\n  } else if (rank === 2) {\n    return name + \".y\";\n  } else if (rank === 3) {\n    return name + \".z\";\n  } else if (rank === 4) {\n    return name + \".w\";\n  } else {\n    throw Error(\"Cumulative sum for rank \" + rank + \" is not yet supported\");\n  }\n}","map":{"version":3,"sources":["../src/cumsum_gpu.ts"],"names":[],"mappings":";;AAkBA,SAAQ,iBAAR;AAEA,WAAa,aAAb;EAQE,uBAAY,KAAZ,EAA6B,SAA7B,EAAiD,OAAjD,EAAiE;IAAA;;IAPjE,KAAA,aAAA,GAAgB,CAAC,GAAD,CAAhB;IAQE,KAAK,WAAL,GAAmB,KAAnB;IACA,IAAM,IAAI,GAAG,KAAK,CAAC,MAAnB;IACA,IAAM,GAAG,GAAG,SAAS,GAAG,KAAH,aAAmB,SAAS,CAAC,IAAD,EAAO,QAAP,CAA5B,MAArB;IACA,IAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAApB;IACA,IAAI,SAAS,GAAG,EAAhB;IACA,IAAI,SAAS,GAAG,EAAhB;;IAIA,IAAI,SAAJ,EAAe;MACb,SAAS,GAAG,OAAO,gBAAa,MAAM,GAAG,CAAtB,IAA4B,UAA/C;MACA,SAAS,GAAG,OAAO,GAAG,SAAH,GAAe,SAAlC;IACD,CAHD,MAGO;MACL,SAAS,GAAG,OAAO,qBAAmB,MAAnB,GAA8B,aAAjD;MACA,SAAS,GAAI,OAAO,GAAG,YAAH,GAAkB,YAAtC;IACD;;IAED,KAAK,QAAL,mEAGM,iBAAiB,CAAC,IAAD,CAHvB,wDAIgB,aAAa,CAAC,IAAD,EAAO,QAAP,CAJ7B,+BAKkB,GALlB,iEAOU,SAPV,iCAQkB,SARlB,qBASQ,aAAa,CAAC,IAAD,EAAO,QAAP,CATrB,uCAUoB,SAAS,CAAC,IAAD,EAAO,QAAP,CAV7B;EAeD;;EAzCH;IAAA;IAAA,OA2CE,4BAAmB,KAAnB,EAAgC;MAAA;;MAC9B,OAAO,UAAC,KAAD,EAAsB,YAAtB,EAAoD;QACzD,IAAI,KAAI,CAAC,KAAL,IAAc,IAAlB,EAAwB;UACtB,KAAI,CAAC,KAAL,GAAa,KAAK,CAAC,kBAAN,CAAyB,YAAzB,EAAuC,OAAvC,CAAb;QACD;;QACD,KAAK,CAAC,EAAN,CAAS,SAAT,CAAmB,KAAI,CAAC,KAAxB,EAA+B,KAA/B;MACD,CALD;IAMD;EAlDH;;EAAA;AAAA;;AAqDA,SAAS,SAAT,CAAmB,IAAnB,EAAiC,IAAjC,EAA6C;EAC3C,IAAI,IAAI,KAAK,CAAb,EAAgB;IACd,YAAU,IAAV;EACD,CAFD,MAEO,IAAI,IAAI,KAAK,CAAb,EAAgB;IACrB,OAAU,IAAV,YAAqB,IAArB;EACD,CAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;IACrB,OAAU,IAAV,YAAqB,IAArB,YAAgC,IAAhC;EACD,CAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;IACrB,OAAU,IAAV,YAAqB,IAArB,YAAgC,IAAhC,YAA2C,IAA3C;EACD,CAFM,MAEA;IACL,MAAM,KAAK,8BAA4B,IAA5B,2BAAX;EACD;AACF;;AAED,SAAS,aAAT,CAAuB,IAAvB,EAAqC,IAArC,EAAiD;EAC/C,IAAI,IAAI,KAAK,CAAb,EAAgB;IACd,YAAU,IAAV;EACD,CAFD,MAEO,IAAI,IAAI,KAAK,CAAb,EAAgB;IACrB,OAAU,IAAV;EACD,CAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;IACrB,OAAU,IAAV;EACD,CAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;IACrB,OAAU,IAAV;EACD,CAFM,MAEA;IACL,MAAM,KAAK,8BAA4B,IAA5B,2BAAX;EACD;AACF","sourceRoot":"","sourcesContent":["import { getCoordsDataType } from './shader_compiler';\nexport class CumSumProgram {\n    constructor(shape, exclusive, reverse) {\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        const rank = shape.length;\n        const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n        const length = shape[shape.length - 1];\n        let condition = '';\n        let idxString = '';\n        // When exclusive is set, the cumsum op becomes roll op that copies the\n        // value from the previous index based on the direction specified by the\n        // reverse flag.\n        if (exclusive) {\n            condition = reverse ? `end != ${length - 1}` : 'end != 0';\n            idxString = reverse ? 'end + 1' : 'end - 1';\n        }\n        else {\n            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n            idxString = (reverse ? 'end + pow2' : 'end - pow2');\n        }\n        this.userCode = `\n      uniform float index;\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n    }\n    getCustomSetupFunc(index) {\n        return (gpgpu, webGLProgram) => {\n            if (this.index == null) {\n                this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n            }\n            gpgpu.gl.uniform1f(this.index, index);\n        };\n    }\n}\nfunction getCoords(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.x, ${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.x, ${name}.y, ${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\nfunction getFinalCoord(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=cumsum_gpu.js.map"]},"metadata":{},"sourceType":"module"}