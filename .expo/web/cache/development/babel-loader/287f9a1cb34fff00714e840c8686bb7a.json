{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from \"./packing_util\";\nimport { getCoordsDataType } from \"./shader_compiler\";\nexport var ConcatPackedProgram = _createClass(function ConcatPackedProgram(shapes, axis) {\n  _classCallCheck(this, ConcatPackedProgram);\n\n  this.packedInputs = true;\n  this.packedOutput = true;\n  this.outputShape = [];\n  this.outputShape = backend_util.computeOutShape(shapes, axis);\n  var shape = this.outputShape;\n  var rank = shape.length;\n  var dtype = getCoordsDataType(rank);\n  var coords = getChannels('coords', rank);\n  var channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n  this.variableNames = shapes.map(function (_, i) {\n    return \"T\" + i;\n  });\n  var offsets = new Array(shapes.length - 1);\n  offsets[0] = shapes[0][axis];\n\n  for (var i = 1; i < offsets.length; i++) {\n    offsets[i] = offsets[i - 1] + shapes[i][axis];\n  }\n\n  var channel = channels[axis];\n  var lastChannels = channels.slice(-2);\n  var allChannels = channels.join();\n  var getValueSnippet = \"if (\" + channel + \" < \" + offsets[0] + \") {\\n        return getChannel(\\n            getT0(\" + allChannels + \"), vec2(\" + lastChannels.join() + \"));\\n        }\";\n\n  for (var _i = 1; _i < offsets.length; _i++) {\n    var _shift = offsets[_i - 1];\n    getValueSnippet += \"\\n        if (\" + channel + \" < \" + offsets[_i] + \"  && \" + channel + \" >= \" + offsets[_i - 1] + \") {\\n          return getChannel(\\n            getT\" + _i + \"(\" + shiftedChannels(channels, channel, _shift) + \"),\\n            vec2(\" + shiftedChannels(lastChannels, channel, _shift) + \"));\\n        }\";\n  }\n\n  var lastIndex = offsets.length;\n  var shift = offsets[offsets.length - 1];\n  getValueSnippet += \"\\n        return getChannel(\\n          getT\" + lastIndex + \"(\" + shiftedChannels(channels, channel, shift) + \"),\\n          vec2(\" + shiftedChannels(lastChannels, channel, shift) + \"));\";\n  this.userCode = \"\\n      float getValue(\" + channels.map(function (x) {\n    return 'int ' + x;\n  }) + \") {\\n        \" + getValueSnippet + \"\\n      }\\n\\n      void main() {\\n        \" + dtype + \" coords = getOutputCoords();\\n        vec4 result = vec4(getValue(\" + coords + \"), 0., 0., 0.);\\n\\n        \" + coords[rank - 1] + \" = \" + coords[rank - 1] + \" + 1;\\n        if (\" + coords[rank - 1] + \" < \" + shape[rank - 1] + \") {\\n          result.g = getValue(\" + coords + \");\\n        }\\n\\n        \" + coords[rank - 2] + \" = \" + coords[rank - 2] + \" + 1;\\n        if (\" + coords[rank - 2] + \" < \" + shape[rank - 2] + \") {\\n          result.a = getValue(\" + coords + \");\\n        }\\n\\n        \" + coords[rank - 1] + \" = \" + coords[rank - 1] + \" - 1;\\n        if (\" + coords[rank - 2] + \" < \" + shape[rank - 2] + \" &&\\n            \" + coords[rank - 1] + \" < \" + shape[rank - 1] + \") {\\n          result.b = getValue(\" + coords + \");\\n        }\\n        setOutput(result);\\n      }\\n    \";\n});\n\nfunction shiftedChannels(channels, channel, shift) {\n  var channelIdx = channels.indexOf(channel);\n  var res = channels.map(function (c, idx) {\n    if (idx === channelIdx) {\n      return c + \" - \" + shift;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n}","map":{"version":3,"sources":["../src/concat_packed_gpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ConcatPackedProgram {\n    constructor(shapes, axis) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, axis);\n        const shape = this.outputShape;\n        const rank = shape.length;\n        const dtype = getCoordsDataType(rank);\n        const coords = getChannels('coords', rank);\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][axis];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][axis];\n        }\n        const channel = channels[axis];\n        const lastChannels = channels.slice(-2);\n        const allChannels = channels.join();\n        let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            // Note: the >= comparison below may seem unnecessary given the check\n            // above but is needed to workaround branch execution issues on some\n            // devices. It makes all the conditions exclusive without relying on\n            // execution order.\n            getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n        }\n        const lastIndex = offsets.length;\n        const shift = offsets[offsets.length - 1];\n        getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n        this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n    }\n}\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels, channel, shift) {\n    const channelIdx = channels.indexOf(channel);\n    const res = channels.map((c, idx) => {\n        if (idx === channelIdx) {\n            return `${c} - ${shift}`;\n        }\n        else {\n            return c;\n        }\n    });\n    return res.join();\n}\n//# sourceMappingURL=concat_packed_gpu.js.map"]},"metadata":{},"sourceType":"module"}