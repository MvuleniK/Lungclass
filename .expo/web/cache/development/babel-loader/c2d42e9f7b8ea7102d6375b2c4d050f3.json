{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from \"./packing_util\";\nimport { getCoordsDataType } from \"./shader_compiler\";\nexport var MirrorPadPackedProgram = _createClass(function MirrorPadPackedProgram(xShape, paddings, mode) {\n  _classCallCheck(this, MirrorPadPackedProgram);\n\n  this.variableNames = ['x'];\n  this.packedInputs = true;\n  this.packedOutput = true;\n  this.outputShape = paddings.map(function (p, i) {\n    return p[0] + xShape[i] + p[1];\n  });\n  var rank = xShape.length;\n  var dtype = getCoordsDataType(rank);\n  var start = paddings.map(function (p) {\n    return p[0];\n  }).join(',');\n  var end = paddings.map(function (p, i) {\n    return p[0] + xShape[i];\n  }).join(',');\n  var coords = getChannels('rc', rank);\n  var source = getChannels('source', rank);\n  var cLimit = coords[rank - 1] + \" < \" + this.outputShape[rank - 1];\n  var innerDims = rank === 1 ? 'source' : \"vec2(\" + source.slice(-2).join() + \")\";\n  var offset = mode === 'reflect' ? 0 : 1;\n  var mainLoop = '';\n\n  if (rank === 1) {\n    var padSetup = \"\\n        \" + dtype + \" source = rc;\\n        if (source < start) {\\n          source = start * 2 - source - \" + offset + \";\\n        } else if (source >= end) {\\n          source = (end - 1) * 2 - source + \" + offset + \";\\n        }\\n        source -= start;\\n      \";\n    mainLoop = \"\\n        \" + dtype + \" rc = outputLoc;\\n        \" + padSetup + \"\\n        result[0] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n        \" + coords[rank - 1] + \" += 1;\\n        if(\" + cLimit + \") {\\n          \" + padSetup + \"\\n          result[1] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n        }\\n      \";\n  } else {\n    var _padSetup = \"\\n        \" + dtype + \" source = rc;\\n        \" + dtype + \" lt = \" + dtype + \"(lessThan(source, start));\\n        \" + dtype + \" gte = \" + dtype + \"(greaterThanEqual(source, end));\\n        \" + dtype + \" orig = 1 - (lt + gte);\\n        source = orig * source +\\n                lt * (start * 2 - source - \" + offset + \") +\\n                gte * ((end - 1) * 2 - source + \" + offset + \");\\n        source -= start;\\n      \";\n\n    mainLoop = \"\\n        \" + dtype + \" rc = outputLoc;\\n        \" + _padSetup + \"\\n        result[0] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n        \" + coords[rank - 1] + \" += 1;\\n        if(\" + cLimit + \") {\\n          \" + _padSetup + \"\\n          result[1] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n        }\\n        rc = outputLoc;\\n        \" + coords[rank - 2] + \" += 1;\\n        if(\" + coords[rank - 2] + \" < \" + this.outputShape[rank - 2] + \") {\\n          \" + _padSetup + \"\\n          result[2] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n          \" + coords[rank - 1] + \" += 1;\\n          if(\" + cLimit + \") {\\n            \" + _padSetup + \"\\n            result[3] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n          }\\n        }\\n      \";\n  }\n\n  this.userCode = \"\\n      const \" + dtype + \" start = \" + dtype + \"(\" + start + \");\\n      const \" + dtype + \" end = \" + dtype + \"(\" + end + \");\\n\\n      void main() {\\n        \" + dtype + \" outputLoc = getOutputCoords();\\n        vec4 result = vec4(0.);\\n        \" + mainLoop + \"\\n        setOutput(result);\\n      }\\n    \";\n});","map":{"version":3,"sources":["../src/mirror_pad_packed_gpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\n/**\n * Example shader code for\n * `mirrorPad(tf.tensor1d([1, 2, 3], 'int32'), [[2, 2]], 'reflect')`\n * ```\n *    const int start = int(2);\n *    const int end = int(5);\n *\n *    void main() {\n *       int outputLoc = getOutputCoords();\n *       vec4 result = vec4(0.);\n *\n *       int rc = outputLoc;\n *\n *       int source = rc;\n *       if (source < start) {\n *         source = start * 2 - source - 0;\n *       } else if (source >= end) {\n *         source = (end - 1) * 2 - source + 0;\n *       }\n *       source -= start;\n *\n *       result[0] = getChannel(getX(source), source);\n *       rc += 1;\n *       if(rc < 6) {\n *          int source = rc;\n *          if (source < start) {\n *            source = start * 2 - source - 0;\n *          } else if (source >= end) {\n *            source = (end - 1) * 2 - source + 0;\n *          }\n *          source -= start;\n *\n *         result[1] = getChannel(getX(source), source);\n *       }\n *\n *       setOutput(result);\n *     }\n * ```\n */\nexport class MirrorPadPackedProgram {\n    constructor(xShape, paddings, mode) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const dtype = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const coords = getChannels('rc', rank);\n        const source = getChannels('source', rank);\n        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n        const offset = mode === 'reflect' ? 0 : 1;\n        let mainLoop = '';\n        if (rank === 1) {\n            const padSetup = `\n        ${dtype} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${offset};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${offset};\n        }\n        source -= start;\n      `;\n            mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n        }\n        else {\n            const padSetup = `\n        ${dtype} source = rc;\n        ${dtype} lt = ${dtype}(lessThan(source, start));\n        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));\n        ${dtype} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${offset}) +\n                gte * ((end - 1) * 2 - source + ${offset});\n        source -= start;\n      `;\n            mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n        rc = outputLoc;\n        ${coords[rank - 2]} += 1;\n        if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {\n          ${padSetup}\n          result[2] = getChannel(getX(${source.join()}), ${innerDims});\n          ${coords[rank - 1]} += 1;\n          if(${cLimit}) {\n            ${padSetup}\n            result[3] = getChannel(getX(${source.join()}), ${innerDims});\n          }\n        }\n      `;\n        }\n        this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mirror_pad_packed_gpu.js.map"]},"metadata":{},"sourceType":"module"}