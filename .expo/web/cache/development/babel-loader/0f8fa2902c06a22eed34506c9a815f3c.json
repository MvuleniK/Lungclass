{"ast":null,"code":"import _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\nimport { deepClone } from \"../util/deep_clone\";\nimport { deepMapAndAwaitAll, deepZip, zipToList } from \"../util/deep_map\";\nimport { GrowingRingBuffer } from \"../util/growing_ring_buffer\";\nimport { RingBuffer } from \"../util/ring_buffer\";\nexport function iteratorFromItems(items) {\n  return new ArrayIterator(items);\n}\nexport function iteratorFromIncrementing(start) {\n  var i = start;\n  return iteratorFromFunction(function () {\n    return {\n      value: i++,\n      done: false\n    };\n  });\n}\nexport function iteratorFromFunction(func) {\n  return new FunctionCallIterator(func);\n}\nexport function iteratorFromConcatenated(baseIterators, baseErrorHandler) {\n  return new ChainedIterator(baseIterators, baseErrorHandler);\n}\nexport function iteratorFromConcatenatedFunction(iteratorFunc, count, baseErrorHandler) {\n  return iteratorFromConcatenated(iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\nexport function iteratorFromZipped(iterators) {\n  var mismatchMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZipMismatchMode.FAIL;\n  return new ZipIterator(iterators, mismatchMode);\n}\nexport var LazyIterator = function () {\n  function LazyIterator() {\n    _classCallCheck(this, LazyIterator);\n  }\n\n  _createClass(LazyIterator, [{\n    key: \"toArray\",\n    value: function toArray() {\n      var result, x;\n      return _regeneratorRuntime.async(function toArray$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              result = [];\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(this.next());\n\n            case 3:\n              x = _context.sent;\n\n            case 4:\n              if (x.done) {\n                _context.next = 11;\n                break;\n              }\n\n              result.push(x.value);\n              _context.next = 8;\n              return _regeneratorRuntime.awrap(this.next());\n\n            case 8:\n              x = _context.sent;\n              _context.next = 4;\n              break;\n\n            case 11:\n              return _context.abrupt(\"return\", result);\n\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"toArrayForTest\",\n    value: function toArrayForTest() {\n      var stream, result, x;\n      return _regeneratorRuntime.async(function toArrayForTest$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              stream = this.prefetch(100);\n              result = [];\n              _context2.next = 4;\n              return _regeneratorRuntime.awrap(stream.next());\n\n            case 4:\n              x = _context2.sent;\n\n            case 5:\n              if (x.done) {\n                _context2.next = 12;\n                break;\n              }\n\n              result.push(x.value);\n              _context2.next = 9;\n              return _regeneratorRuntime.awrap(stream.next());\n\n            case 9:\n              x = _context2.sent;\n              _context2.next = 5;\n              break;\n\n            case 12:\n              return _context2.abrupt(\"return\", result);\n\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"resolveFully\",\n    value: function resolveFully() {\n      var x;\n      return _regeneratorRuntime.async(function resolveFully$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _regeneratorRuntime.awrap(this.next());\n\n            case 2:\n              x = _context3.sent;\n\n            case 3:\n              if (x.done) {\n                _context3.next = 9;\n                break;\n              }\n\n              _context3.next = 6;\n              return _regeneratorRuntime.awrap(this.next());\n\n            case 6:\n              x = _context3.sent;\n              _context3.next = 3;\n              break;\n\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"resolveWhile\",\n    value: function resolveWhile(predicate) {\n      var x, shouldContinue;\n      return _regeneratorRuntime.async(function resolveWhile$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return _regeneratorRuntime.awrap(this.next());\n\n            case 2:\n              x = _context4.sent;\n              shouldContinue = predicate(x.value);\n\n            case 4:\n              if (!(!x.done && shouldContinue)) {\n                _context4.next = 11;\n                break;\n              }\n\n              _context4.next = 7;\n              return _regeneratorRuntime.awrap(this.next());\n\n            case 7:\n              x = _context4.sent;\n              shouldContinue = predicate(x.value);\n              _context4.next = 4;\n              break;\n\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"handleErrors\",\n    value: function handleErrors(handler) {\n      return new ErrorHandlingLazyIterator(this, handler);\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(predicate) {\n      return new FilterIterator(this, predicate);\n    }\n  }, {\n    key: \"map\",\n    value: function map(transform) {\n      return new MapIterator(this, transform);\n    }\n  }, {\n    key: \"mapAsync\",\n    value: function mapAsync(transform) {\n      return new AsyncMapIterator(this, transform);\n    }\n  }, {\n    key: \"serialMapAsync\",\n    value: function serialMapAsync(transform) {\n      return new AsyncMapIterator(this, transform).serial();\n    }\n  }, {\n    key: \"flatmap\",\n    value: function flatmap(transform) {\n      return new FlatmapIterator(this, transform);\n    }\n  }, {\n    key: \"forEachAsync\",\n    value: function forEachAsync(f) {\n      return _regeneratorRuntime.async(function forEachAsync$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", this.map(f).resolveFully());\n\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"serialForEach\",\n    value: function serialForEach(f) {\n      return _regeneratorRuntime.async(function serialForEach$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", this.serialMapAsync(f).resolveWhile(function (x) {\n                return x === true;\n              }));\n\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"rowMajorBatch\",\n    value: function rowMajorBatch(batchSize) {\n      var smallLastBatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n    }\n  }, {\n    key: \"columnMajorBatch\",\n    value: function columnMajorBatch(batchSize) {\n      var smallLastBatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var zipFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : zipToList;\n      var rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);\n      return rowBatches.map(function (x) {\n        return deepZip(x, zipFn);\n      });\n    }\n  }, {\n    key: \"concatenate\",\n    value: function concatenate(iterator, baseErrorHandler) {\n      return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);\n    }\n  }, {\n    key: \"take\",\n    value: function take(count) {\n      if (count < 0 || count == null) {\n        return this;\n      }\n\n      return new TakeIterator(this, count);\n    }\n  }, {\n    key: \"skip\",\n    value: function skip(count) {\n      if (count < 0 || count == null) {\n        return this;\n      }\n\n      return new SkipIterator(this, count);\n    }\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(bufferSize) {\n      return new PrefetchIterator(this, bufferSize);\n    }\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(windowSize, seed) {\n      return new ShuffleIterator(this, windowSize, seed);\n    }\n  }, {\n    key: \"serial\",\n    value: function serial() {\n      return new SerialIterator(this);\n    }\n  }]);\n\n  return LazyIterator;\n}();\n\nvar ArrayIterator = function (_LazyIterator) {\n  _inherits(ArrayIterator, _LazyIterator);\n\n  var _super = _createSuper(ArrayIterator);\n\n  function ArrayIterator(items) {\n    var _this;\n\n    _classCallCheck(this, ArrayIterator);\n\n    _this = _super.call(this);\n    _this.items = items;\n    _this.trav = 0;\n    return _this;\n  }\n\n  _createClass(ArrayIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"Array of \" + this.items.length + \" items\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var item;\n      return _regeneratorRuntime.async(function next$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(this.trav >= this.items.length)) {\n                _context7.next = 2;\n                break;\n              }\n\n              return _context7.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 2:\n              item = this.items[this.trav];\n              this.trav++;\n              return _context7.abrupt(\"return\", {\n                value: deepClone(item),\n                done: false\n              });\n\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return ArrayIterator;\n}(LazyIterator);\n\nvar FunctionCallIterator = function (_LazyIterator2) {\n  _inherits(FunctionCallIterator, _LazyIterator2);\n\n  var _super2 = _createSuper(FunctionCallIterator);\n\n  function FunctionCallIterator(nextFn) {\n    var _this2;\n\n    _classCallCheck(this, FunctionCallIterator);\n\n    _this2 = _super2.call(this);\n    _this2.nextFn = nextFn;\n    return _this2;\n  }\n\n  _createClass(FunctionCallIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"Function call\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      return _regeneratorRuntime.async(function next$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.prev = 0;\n              return _context8.abrupt(\"return\", this.nextFn());\n\n            case 4:\n              _context8.prev = 4;\n              _context8.t0 = _context8[\"catch\"](0);\n              _context8.t0.message = \"Error thrown while iterating through a dataset: \" + _context8.t0.message;\n              throw _context8.t0;\n\n            case 8:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, this, [[0, 4]], Promise);\n    }\n  }]);\n\n  return FunctionCallIterator;\n}(LazyIterator);\n\nvar SerialIterator = function (_LazyIterator3) {\n  _inherits(SerialIterator, _LazyIterator3);\n\n  var _super3 = _createSuper(SerialIterator);\n\n  function SerialIterator(upstream) {\n    var _this3;\n\n    _classCallCheck(this, SerialIterator);\n\n    _this3 = _super3.call(this);\n    _this3.upstream = upstream;\n    _this3.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this3;\n  }\n\n  _createClass(SerialIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.upstream.summary() + \" -> Serial\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var _this4 = this;\n\n      return _regeneratorRuntime.async(function next$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              this.lastRead = this.lastRead.then(function () {\n                return _this4.serialNext();\n              });\n              return _context9.abrupt(\"return\", this.lastRead);\n\n            case 2:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"serialNext\",\n    value: function serialNext() {\n      return _regeneratorRuntime.async(function serialNext$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", this.upstream.next());\n\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return SerialIterator;\n}(LazyIterator);\n\nvar SkipIterator = function (_LazyIterator4) {\n  _inherits(SkipIterator, _LazyIterator4);\n\n  var _super4 = _createSuper(SkipIterator);\n\n  function SkipIterator(upstream, maxCount) {\n    var _this5;\n\n    _classCallCheck(this, SkipIterator);\n\n    _this5 = _super4.call(this);\n    _this5.upstream = upstream;\n    _this5.maxCount = maxCount;\n    _this5.count = 0;\n    _this5.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this5;\n  }\n\n  _createClass(SkipIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.upstream.summary() + \" -> Skip\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var _this6 = this;\n\n      return _regeneratorRuntime.async(function next$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              this.lastRead = this.lastRead.then(function () {\n                return _this6.serialNext();\n              });\n              return _context11.abrupt(\"return\", this.lastRead);\n\n            case 2:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"serialNext\",\n    value: function serialNext() {\n      var skipped;\n      return _regeneratorRuntime.async(function serialNext$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!(this.count++ < this.maxCount)) {\n                _context12.next = 9;\n                break;\n              }\n\n              _context12.next = 3;\n              return _regeneratorRuntime.awrap(this.upstream.next());\n\n            case 3:\n              skipped = _context12.sent;\n\n              if (!skipped.done) {\n                _context12.next = 6;\n                break;\n              }\n\n              return _context12.abrupt(\"return\", skipped);\n\n            case 6:\n              tf.dispose(skipped.value);\n              _context12.next = 0;\n              break;\n\n            case 9:\n              return _context12.abrupt(\"return\", this.upstream.next());\n\n            case 10:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return SkipIterator;\n}(LazyIterator);\n\nvar TakeIterator = function (_LazyIterator5) {\n  _inherits(TakeIterator, _LazyIterator5);\n\n  var _super5 = _createSuper(TakeIterator);\n\n  function TakeIterator(upstream, maxCount) {\n    var _this7;\n\n    _classCallCheck(this, TakeIterator);\n\n    _this7 = _super5.call(this);\n    _this7.upstream = upstream;\n    _this7.maxCount = maxCount;\n    _this7.count = 0;\n    return _this7;\n  }\n\n  _createClass(TakeIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.upstream.summary() + \" -> Take\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      return _regeneratorRuntime.async(function next$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              if (!(this.count++ >= this.maxCount)) {\n                _context13.next = 2;\n                break;\n              }\n\n              return _context13.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 2:\n              return _context13.abrupt(\"return\", this.upstream.next());\n\n            case 3:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return TakeIterator;\n}(LazyIterator);\n\nvar RowMajorBatchIterator = function (_LazyIterator6) {\n  _inherits(RowMajorBatchIterator, _LazyIterator6);\n\n  var _super6 = _createSuper(RowMajorBatchIterator);\n\n  function RowMajorBatchIterator(upstream, batchSize) {\n    var _this8;\n\n    var enableSmallLastBatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    _classCallCheck(this, RowMajorBatchIterator);\n\n    _this8 = _super6.call(this);\n    _this8.upstream = upstream;\n    _this8.batchSize = batchSize;\n    _this8.enableSmallLastBatch = enableSmallLastBatch;\n    _this8.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this8;\n  }\n\n  _createClass(RowMajorBatchIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.upstream.summary() + \" -> RowMajorBatch\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var _this9 = this;\n\n      return _regeneratorRuntime.async(function next$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              this.lastRead = this.lastRead.then(function () {\n                return _this9.serialNext();\n              });\n              return _context14.abrupt(\"return\", this.lastRead);\n\n            case 2:\n            case \"end\":\n              return _context14.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"serialNext\",\n    value: function serialNext() {\n      var batch, item;\n      return _regeneratorRuntime.async(function serialNext$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              batch = [];\n\n            case 1:\n              if (!(batch.length < this.batchSize)) {\n                _context15.next = 12;\n                break;\n              }\n\n              _context15.next = 4;\n              return _regeneratorRuntime.awrap(this.upstream.next());\n\n            case 4:\n              item = _context15.sent;\n\n              if (!item.done) {\n                _context15.next = 9;\n                break;\n              }\n\n              if (!(this.enableSmallLastBatch && batch.length > 0)) {\n                _context15.next = 8;\n                break;\n              }\n\n              return _context15.abrupt(\"return\", {\n                value: batch,\n                done: false\n              });\n\n            case 8:\n              return _context15.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 9:\n              batch.push(item.value);\n              _context15.next = 1;\n              break;\n\n            case 12:\n              return _context15.abrupt(\"return\", {\n                value: batch,\n                done: false\n              });\n\n            case 13:\n            case \"end\":\n              return _context15.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return RowMajorBatchIterator;\n}(LazyIterator);\n\nvar FilterIterator = function (_LazyIterator7) {\n  _inherits(FilterIterator, _LazyIterator7);\n\n  var _super7 = _createSuper(FilterIterator);\n\n  function FilterIterator(upstream, predicate) {\n    var _this10;\n\n    _classCallCheck(this, FilterIterator);\n\n    _this10 = _super7.call(this);\n    _this10.upstream = upstream;\n    _this10.predicate = predicate;\n    _this10.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this10;\n  }\n\n  _createClass(FilterIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.upstream.summary() + \" -> Filter\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var _this11 = this;\n\n      return _regeneratorRuntime.async(function next$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              this.lastRead = this.lastRead.then(function () {\n                return _this11.serialNext();\n              });\n              return _context16.abrupt(\"return\", this.lastRead);\n\n            case 2:\n            case \"end\":\n              return _context16.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"serialNext\",\n    value: function serialNext() {\n      var item;\n      return _regeneratorRuntime.async(function serialNext$(_context17) {\n        while (1) {\n          switch (_context17.prev = _context17.next) {\n            case 0:\n              if (!true) {\n                _context17.next = 9;\n                break;\n              }\n\n              _context17.next = 3;\n              return _regeneratorRuntime.awrap(this.upstream.next());\n\n            case 3:\n              item = _context17.sent;\n\n              if (!(item.done || this.predicate(item.value))) {\n                _context17.next = 6;\n                break;\n              }\n\n              return _context17.abrupt(\"return\", item);\n\n            case 6:\n              tf.dispose(item.value);\n              _context17.next = 0;\n              break;\n\n            case 9:\n            case \"end\":\n              return _context17.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return FilterIterator;\n}(LazyIterator);\n\nvar MapIterator = function (_LazyIterator8) {\n  _inherits(MapIterator, _LazyIterator8);\n\n  var _super8 = _createSuper(MapIterator);\n\n  function MapIterator(upstream, transform) {\n    var _this12;\n\n    _classCallCheck(this, MapIterator);\n\n    _this12 = _super8.call(this);\n    _this12.upstream = upstream;\n    _this12.transform = transform;\n    return _this12;\n  }\n\n  _createClass(MapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.upstream.summary() + \" -> Map\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var item, inputTensors, mapped, outputTensors, _iterator, _step, t;\n\n      return _regeneratorRuntime.async(function next$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.next = 2;\n              return _regeneratorRuntime.awrap(this.upstream.next());\n\n            case 2:\n              item = _context18.sent;\n\n              if (!item.done) {\n                _context18.next = 5;\n                break;\n              }\n\n              return _context18.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 5:\n              inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n              mapped = this.transform(item.value);\n              outputTensors = tf.tensor_util.getTensorsInContainer(mapped);\n\n              for (_iterator = _createForOfIteratorHelperLoose(inputTensors); !(_step = _iterator()).done;) {\n                t = _step.value;\n\n                if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                  t.dispose();\n                }\n              }\n\n              return _context18.abrupt(\"return\", {\n                value: mapped,\n                done: false\n              });\n\n            case 10:\n            case \"end\":\n              return _context18.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return MapIterator;\n}(LazyIterator);\n\nvar ErrorHandlingLazyIterator = function (_LazyIterator9) {\n  _inherits(ErrorHandlingLazyIterator, _LazyIterator9);\n\n  var _super9 = _createSuper(ErrorHandlingLazyIterator);\n\n  function ErrorHandlingLazyIterator(upstream, handler) {\n    var _this13;\n\n    _classCallCheck(this, ErrorHandlingLazyIterator);\n\n    _this13 = _super9.call(this);\n    _this13.upstream = upstream;\n    _this13.handler = handler;\n    _this13.count = 0;\n    _this13.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this13;\n  }\n\n  _createClass(ErrorHandlingLazyIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.upstream.summary() + \" -> handleErrors\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var _this14 = this;\n\n      return _regeneratorRuntime.async(function next$(_context19) {\n        while (1) {\n          switch (_context19.prev = _context19.next) {\n            case 0:\n              this.lastRead = this.lastRead.then(function () {\n                return _this14.serialNext();\n              });\n              return _context19.abrupt(\"return\", this.lastRead);\n\n            case 2:\n            case \"end\":\n              return _context19.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"serialNext\",\n    value: function serialNext() {\n      return _regeneratorRuntime.async(function serialNext$(_context20) {\n        while (1) {\n          switch (_context20.prev = _context20.next) {\n            case 0:\n              if (!true) {\n                _context20.next = 13;\n                break;\n              }\n\n              _context20.prev = 1;\n              _context20.next = 4;\n              return _regeneratorRuntime.awrap(this.upstream.next());\n\n            case 4:\n              return _context20.abrupt(\"return\", _context20.sent);\n\n            case 7:\n              _context20.prev = 7;\n              _context20.t0 = _context20[\"catch\"](1);\n\n              if (this.handler(_context20.t0)) {\n                _context20.next = 11;\n                break;\n              }\n\n              return _context20.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 11:\n              _context20.next = 0;\n              break;\n\n            case 13:\n            case \"end\":\n              return _context20.stop();\n          }\n        }\n      }, null, this, [[1, 7]], Promise);\n    }\n  }]);\n\n  return ErrorHandlingLazyIterator;\n}(LazyIterator);\n\nvar AsyncMapIterator = function (_LazyIterator10) {\n  _inherits(AsyncMapIterator, _LazyIterator10);\n\n  var _super10 = _createSuper(AsyncMapIterator);\n\n  function AsyncMapIterator(upstream, transform) {\n    var _this15;\n\n    _classCallCheck(this, AsyncMapIterator);\n\n    _this15 = _super10.call(this);\n    _this15.upstream = upstream;\n    _this15.transform = transform;\n    return _this15;\n  }\n\n  _createClass(AsyncMapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.upstream.summary() + \" -> AsyncMap\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var item, inputTensors, mapped, outputTensors, _iterator2, _step2, t;\n\n      return _regeneratorRuntime.async(function next$(_context21) {\n        while (1) {\n          switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return _regeneratorRuntime.awrap(this.upstream.next());\n\n            case 2:\n              item = _context21.sent;\n\n              if (!item.done) {\n                _context21.next = 5;\n                break;\n              }\n\n              return _context21.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 5:\n              inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n              _context21.next = 8;\n              return _regeneratorRuntime.awrap(this.transform(item.value));\n\n            case 8:\n              mapped = _context21.sent;\n              outputTensors = tf.tensor_util.getTensorsInContainer(mapped);\n\n              for (_iterator2 = _createForOfIteratorHelperLoose(inputTensors); !(_step2 = _iterator2()).done;) {\n                t = _step2.value;\n\n                if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                  t.dispose();\n                }\n              }\n\n              return _context21.abrupt(\"return\", {\n                value: mapped,\n                done: false\n              });\n\n            case 12:\n            case \"end\":\n              return _context21.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return AsyncMapIterator;\n}(LazyIterator);\n\nexport var OneToManyIterator = function (_LazyIterator11) {\n  _inherits(OneToManyIterator, _LazyIterator11);\n\n  var _super11 = _createSuper(OneToManyIterator);\n\n  function OneToManyIterator() {\n    var _this16;\n\n    _classCallCheck(this, OneToManyIterator);\n\n    _this16 = _super11.call(this);\n    _this16.outputQueue = new GrowingRingBuffer();\n    _this16.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this16;\n  }\n\n  _createClass(OneToManyIterator, [{\n    key: \"next\",\n    value: function next() {\n      var _this17 = this;\n\n      return _regeneratorRuntime.async(function next$(_context22) {\n        while (1) {\n          switch (_context22.prev = _context22.next) {\n            case 0:\n              this.lastRead = this.lastRead.then(function () {\n                return _this17.serialNext();\n              });\n              return _context22.abrupt(\"return\", this.lastRead);\n\n            case 2:\n            case \"end\":\n              return _context22.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"serialNext\",\n    value: function serialNext() {\n      return _regeneratorRuntime.async(function serialNext$(_context23) {\n        while (1) {\n          switch (_context23.prev = _context23.next) {\n            case 0:\n              if (!(this.outputQueue.length() === 0)) {\n                _context23.next = 7;\n                break;\n              }\n\n              _context23.next = 3;\n              return _regeneratorRuntime.awrap(this.pump());\n\n            case 3:\n              if (_context23.sent) {\n                _context23.next = 5;\n                break;\n              }\n\n              return _context23.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 5:\n              _context23.next = 0;\n              break;\n\n            case 7:\n              return _context23.abrupt(\"return\", {\n                value: this.outputQueue.shift(),\n                done: false\n              });\n\n            case 8:\n            case \"end\":\n              return _context23.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return OneToManyIterator;\n}(LazyIterator);\n\nvar FlatmapIterator = function (_OneToManyIterator) {\n  _inherits(FlatmapIterator, _OneToManyIterator);\n\n  var _super12 = _createSuper(FlatmapIterator);\n\n  function FlatmapIterator(upstream, transform) {\n    var _this18;\n\n    _classCallCheck(this, FlatmapIterator);\n\n    _this18 = _super12.call(this);\n    _this18.upstream = upstream;\n    _this18.transform = transform;\n    return _this18;\n  }\n\n  _createClass(FlatmapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.upstream.summary() + \" -> Flatmap\";\n    }\n  }, {\n    key: \"pump\",\n    value: function pump() {\n      var item, inputTensors, mappedArray, outputTensors, _iterator3, _step3, t;\n\n      return _regeneratorRuntime.async(function pump$(_context24) {\n        while (1) {\n          switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return _regeneratorRuntime.awrap(this.upstream.next());\n\n            case 2:\n              item = _context24.sent;\n\n              if (!item.done) {\n                _context24.next = 5;\n                break;\n              }\n\n              return _context24.abrupt(\"return\", false);\n\n            case 5:\n              inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n              mappedArray = this.transform(item.value);\n              outputTensors = tf.tensor_util.getTensorsInContainer(mappedArray);\n              this.outputQueue.pushAll(mappedArray);\n\n              for (_iterator3 = _createForOfIteratorHelperLoose(inputTensors); !(_step3 = _iterator3()).done;) {\n                t = _step3.value;\n\n                if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                  t.dispose();\n                }\n              }\n\n              return _context24.abrupt(\"return\", true);\n\n            case 11:\n            case \"end\":\n              return _context24.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return FlatmapIterator;\n}(OneToManyIterator);\n\nexport var ChainedIterator = function (_LazyIterator12) {\n  _inherits(ChainedIterator, _LazyIterator12);\n\n  var _super13 = _createSuper(ChainedIterator);\n\n  function ChainedIterator(iterators, baseErrorHandler) {\n    var _this19;\n\n    _classCallCheck(this, ChainedIterator);\n\n    _this19 = _super13.call(this);\n    _this19.baseErrorHandler = baseErrorHandler;\n    _this19.lastRead = null;\n    _this19.iterator = null;\n    _this19.moreIterators = iterators;\n    return _this19;\n  }\n\n  _createClass(ChainedIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      var upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n      return upstreamSummaries + \" -> Chained\";\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      return _regeneratorRuntime.async(function next$(_context25) {\n        while (1) {\n          switch (_context25.prev = _context25.next) {\n            case 0:\n              this.lastRead = this.readFromChain(this.lastRead);\n              return _context25.abrupt(\"return\", this.lastRead);\n\n            case 2:\n            case \"end\":\n              return _context25.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"readFromChain\",\n    value: function readFromChain(lastRead) {\n      var iteratorResult, itemResult;\n      return _regeneratorRuntime.async(function readFromChain$(_context26) {\n        while (1) {\n          switch (_context26.prev = _context26.next) {\n            case 0:\n              _context26.next = 2;\n              return _regeneratorRuntime.awrap(lastRead);\n\n            case 2:\n              if (!(this.iterator == null)) {\n                _context26.next = 10;\n                break;\n              }\n\n              _context26.next = 5;\n              return _regeneratorRuntime.awrap(this.moreIterators.next());\n\n            case 5:\n              iteratorResult = _context26.sent;\n\n              if (!iteratorResult.done) {\n                _context26.next = 8;\n                break;\n              }\n\n              return _context26.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 8:\n              this.iterator = iteratorResult.value;\n\n              if (this.baseErrorHandler != null) {\n                this.iterator = this.iterator.handleErrors(this.baseErrorHandler);\n              }\n\n            case 10:\n              _context26.next = 12;\n              return _regeneratorRuntime.awrap(this.iterator.next());\n\n            case 12:\n              itemResult = _context26.sent;\n\n              if (!itemResult.done) {\n                _context26.next = 16;\n                break;\n              }\n\n              this.iterator = null;\n              return _context26.abrupt(\"return\", this.readFromChain(lastRead));\n\n            case 16:\n              return _context26.abrupt(\"return\", itemResult);\n\n            case 17:\n            case \"end\":\n              return _context26.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return ChainedIterator;\n}(LazyIterator);\nexport var ZipMismatchMode;\n\n(function (ZipMismatchMode) {\n  ZipMismatchMode[ZipMismatchMode[\"FAIL\"] = 0] = \"FAIL\";\n  ZipMismatchMode[ZipMismatchMode[\"SHORTEST\"] = 1] = \"SHORTEST\";\n  ZipMismatchMode[ZipMismatchMode[\"LONGEST\"] = 2] = \"LONGEST\";\n})(ZipMismatchMode || (ZipMismatchMode = {}));\n\nvar ZipIterator = function (_LazyIterator13) {\n  _inherits(ZipIterator, _LazyIterator13);\n\n  var _super14 = _createSuper(ZipIterator);\n\n  function ZipIterator(iterators) {\n    var _this20;\n\n    var mismatchMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZipMismatchMode.FAIL;\n\n    _classCallCheck(this, ZipIterator);\n\n    _this20 = _super14.call(this);\n    _this20.iterators = iterators;\n    _this20.mismatchMode = mismatchMode;\n    _this20.count = 0;\n    _this20.currentPromise = null;\n    return _this20;\n  }\n\n  _createClass(ZipIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      var upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n      return \"{\" + upstreamSummaries + \"} -> Zip\";\n    }\n  }, {\n    key: \"nextState\",\n    value: function nextState(afterState) {\n      var numIterators, iteratorsDone, getNext, mapped;\n      return _regeneratorRuntime.async(function nextState$(_context27) {\n        while (1) {\n          switch (_context27.prev = _context27.next) {\n            case 0:\n              getNext = function _getNext(container) {\n                if (container instanceof LazyIterator) {\n                  var result = container.next();\n                  return {\n                    value: result.then(function (x) {\n                      numIterators++;\n\n                      if (x.done) {\n                        iteratorsDone++;\n                      }\n\n                      return x.value;\n                    }),\n                    recurse: false\n                  };\n                } else {\n                  return {\n                    value: null,\n                    recurse: true\n                  };\n                }\n              };\n\n              _context27.next = 3;\n              return _regeneratorRuntime.awrap(afterState);\n\n            case 3:\n              numIterators = 0;\n              iteratorsDone = 0;\n              _context27.next = 7;\n              return _regeneratorRuntime.awrap(deepMapAndAwaitAll(this.iterators, getNext));\n\n            case 7:\n              mapped = _context27.sent;\n\n              if (!(numIterators === iteratorsDone)) {\n                _context27.next = 10;\n                break;\n              }\n\n              return _context27.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 10:\n              if (!(iteratorsDone > 0)) {\n                _context27.next = 16;\n                break;\n              }\n\n              _context27.t0 = this.mismatchMode;\n              _context27.next = _context27.t0 === ZipMismatchMode.FAIL ? 14 : _context27.t0 === ZipMismatchMode.SHORTEST ? 15 : _context27.t0 === ZipMismatchMode.LONGEST ? 16 : 16;\n              break;\n\n            case 14:\n              throw new Error('Zipped streams should have the same length. ' + (\"Mismatched at element \" + this.count + \".\"));\n\n            case 15:\n              return _context27.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 16:\n              this.count++;\n              return _context27.abrupt(\"return\", {\n                value: mapped,\n                done: false\n              });\n\n            case 18:\n            case \"end\":\n              return _context27.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      return _regeneratorRuntime.async(function next$(_context28) {\n        while (1) {\n          switch (_context28.prev = _context28.next) {\n            case 0:\n              this.currentPromise = this.nextState(this.currentPromise);\n              return _context28.abrupt(\"return\", this.currentPromise);\n\n            case 2:\n            case \"end\":\n              return _context28.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return ZipIterator;\n}(LazyIterator);\n\nexport var PrefetchIterator = function (_LazyIterator14) {\n  _inherits(PrefetchIterator, _LazyIterator14);\n\n  var _super15 = _createSuper(PrefetchIterator);\n\n  function PrefetchIterator(upstream, bufferSize) {\n    var _this21;\n\n    _classCallCheck(this, PrefetchIterator);\n\n    _this21 = _super15.call(this);\n    _this21.upstream = upstream;\n    _this21.bufferSize = bufferSize;\n    _this21.buffer = new RingBuffer(bufferSize);\n    return _this21;\n  }\n\n  _createClass(PrefetchIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.upstream.summary() + \" -> Prefetch\";\n    }\n  }, {\n    key: \"refill\",\n    value: function refill() {\n      while (!this.buffer.isFull()) {\n        var v = this.upstream.next();\n        this.buffer.push(v);\n      }\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      this.refill();\n      return this.buffer.shift();\n    }\n  }]);\n\n  return PrefetchIterator;\n}(LazyIterator);\nexport var ShuffleIterator = function (_PrefetchIterator) {\n  _inherits(ShuffleIterator, _PrefetchIterator);\n\n  var _super16 = _createSuper(ShuffleIterator);\n\n  function ShuffleIterator(upstream, windowSize, seed) {\n    var _this22;\n\n    _classCallCheck(this, ShuffleIterator);\n\n    _this22 = _super16.call(this, upstream, windowSize);\n    _this22.upstream = upstream;\n    _this22.windowSize = windowSize;\n    _this22.upstreamExhausted = false;\n    _this22.random = seedrandom.alea(seed || tf.util.now().toString());\n    _this22.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this22;\n  }\n\n  _createClass(ShuffleIterator, [{\n    key: \"next\",\n    value: function next() {\n      var _this23 = this;\n\n      return _regeneratorRuntime.async(function next$(_context29) {\n        while (1) {\n          switch (_context29.prev = _context29.next) {\n            case 0:\n              this.lastRead = this.lastRead.then(function () {\n                return _this23.serialNext();\n              });\n              return _context29.abrupt(\"return\", this.lastRead);\n\n            case 2:\n            case \"end\":\n              return _context29.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"randomInt\",\n    value: function randomInt(max) {\n      return Math.floor(this.random() * max);\n    }\n  }, {\n    key: \"chooseIndex\",\n    value: function chooseIndex() {\n      return this.randomInt(this.buffer.length());\n    }\n  }, {\n    key: \"serialNext\",\n    value: function serialNext() {\n      var chosenIndex, result;\n      return _regeneratorRuntime.async(function serialNext$(_context30) {\n        while (1) {\n          switch (_context30.prev = _context30.next) {\n            case 0:\n              if (!this.upstreamExhausted) {\n                this.refill();\n              }\n\n            case 1:\n              if (this.buffer.isEmpty()) {\n                _context30.next = 14;\n                break;\n              }\n\n              chosenIndex = this.chooseIndex();\n              _context30.next = 5;\n              return _regeneratorRuntime.awrap(this.buffer.shuffleExcise(chosenIndex));\n\n            case 5:\n              result = _context30.sent;\n\n              if (!result.done) {\n                _context30.next = 10;\n                break;\n              }\n\n              this.upstreamExhausted = true;\n              _context30.next = 12;\n              break;\n\n            case 10:\n              this.refill();\n              return _context30.abrupt(\"return\", result);\n\n            case 12:\n              _context30.next = 1;\n              break;\n\n            case 14:\n              return _context30.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 15:\n            case \"end\":\n              return _context30.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return ShuffleIterator;\n}(PrefetchIterator);","map":{"version":3,"sources":["../../src/iterators/lazy_iterator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\nimport { deepClone } from '../util/deep_clone';\nimport { deepMapAndAwaitAll, deepZip, zipToList } from '../util/deep_map';\nimport { GrowingRingBuffer } from '../util/growing_ring_buffer';\nimport { RingBuffer } from '../util/ring_buffer';\n// Here we implement a simple asynchronous iterator.\n// This lets us avoid using either third-party stream libraries or\n// recent TypeScript language support requiring polyfills.\n/**\n * Create a `LazyIterator` from an array of items.\n */\nexport function iteratorFromItems(items) {\n    return new ArrayIterator(items);\n}\n/**\n * Create a `LazyIterator` of incrementing integers.\n */\nexport function iteratorFromIncrementing(start) {\n    let i = start;\n    return iteratorFromFunction(() => ({ value: i++, done: false }));\n}\n/**\n * Create a `LazyIterator` from a function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * await iter.forEachAsync(e => console.log(e));\n * ```\n *\n * @param func A function that produces data on each call.\n */\nexport function iteratorFromFunction(func) {\n    return new FunctionCallIterator(func);\n}\n/**\n * Create a `LazyIterator` by concatenating underlying streams, which are\n * themselves provided as a stream.\n *\n * This can also be thought of as a \"stream flatten\" operation.\n *\n * @param baseIterators A stream of streams to be concatenated.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenated(baseIterators, baseErrorHandler) {\n    return new ChainedIterator(baseIterators, baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by concatenating streams produced by calling a\n * stream-generating function a given number of times.\n *\n * Since a `LazyIterator` is read-once, it cannot be repeated, but this\n * function can be used to achieve a similar effect:\n *\n *   LazyIterator.ofConcatenatedFunction(() => new MyIterator(), 6);\n *\n * @param iteratorFunc: A function that produces a new stream on each call.\n * @param count: The number of times to call the function.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenatedFunction(iteratorFunc, count, baseErrorHandler) {\n    return iteratorFromConcatenated(iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by zipping together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nexport function iteratorFromZipped(iterators, mismatchMode = ZipMismatchMode.FAIL) {\n    return new ZipIterator(iterators, mismatchMode);\n}\n/**\n * An asynchronous iterator, providing lazy access to a potentially\n * unbounded stream of elements.\n *\n * Iterator can be obtained from a dataset:\n * `const iter = await dataset.iterator();`\n */\nexport class LazyIterator {\n    /**\n     * Collect all remaining elements of a bounded stream into an array.\n     * Obviously this will succeed only for small streams that fit in memory.\n     * Useful for testing.\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n    async toArray() {\n        const result = [];\n        let x = await this.next();\n        while (!x.done) {\n            result.push(x.value);\n            x = await this.next();\n        }\n        return result;\n    }\n    /**\n     * Collect all elements of this dataset into an array with prefetching 100\n     * elements. This is useful for testing, because the prefetch changes the\n     * order in which the Promises are resolved along the processing pipeline.\n     * This may help expose bugs where results are dependent on the order of\n     * Promise resolution rather than on the logical order of the stream (i.e.,\n     * due to hidden mutable state).\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n    async toArrayForTest() {\n        const stream = this.prefetch(100);\n        const result = [];\n        let x = await stream.next();\n        while (!x.done) {\n            result.push(x.value);\n            x = await stream.next();\n        }\n        return result;\n    }\n    /**\n     * Draw items from the stream until it is exhausted.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n    async resolveFully() {\n        let x = await this.next();\n        while (!x.done) {\n            x = await this.next();\n        }\n    }\n    /**\n     * Draw items from the stream until it is exhausted, or a predicate fails.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n    async resolveWhile(predicate) {\n        let x = await this.next();\n        let shouldContinue = predicate(x.value);\n        while ((!x.done) && shouldContinue) {\n            x = await this.next();\n            shouldContinue = predicate(x.value);\n        }\n    }\n    /**\n     * Handles errors thrown on this stream using a provided handler function.\n     *\n     * @param handler A function that handles any `Error` thrown during a `next()`\n     *   call and returns true if the stream should continue (dropping the failed\n     *   call) or false if the stream should quietly terminate.  If the handler\n     *   itself throws (or rethrows) an `Error`, that will be propagated.\n     *\n     * @returns A `LazyIterator` of elements passed through from upstream,\n     *   possibly filtering or terminating on upstream `next()` calls that\n     *   throw an `Error`.\n     */\n    handleErrors(handler) {\n        return new ErrorHandlingLazyIterator(this, handler);\n    }\n    // TODO(soergel): Implement reduce() etc.\n    /**\n     * Filters this stream according to `predicate`.\n     *\n     * @param predicate A function mapping a stream element to a boolean or a\n     * `Promise` for one.\n     *\n     * @returns A `LazyIterator` of elements for which the predicate was true.\n     */\n    filter(predicate) {\n        return new FilterIterator(this, predicate);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n    map(transform) {\n        return new MapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through an async 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a `Promise` for a\n     *   transformed stream element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n    mapAsync(transform) {\n        return new AsyncMapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform, forcing serial execution.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n    serialMapAsync(transform) {\n        return new AsyncMapIterator(this, transform).serial();\n    }\n    /**\n     * Maps this stream through a 1-to-many transform.\n     *\n     * @param transform A function mapping a stream element to an array of\n     *   transformed elements.\n     *\n     * @returns A `DataStream` of transformed elements.\n     */\n    flatmap(transform) {\n        return new FlatmapIterator(this, transform);\n    }\n    /**\n     * Apply a function to every element of the stream.\n     *\n     * @param f A function to apply to each stream element.\n     */\n    async forEachAsync(f) {\n        return this.map(f).resolveFully();\n    }\n    /**\n     * Apply a function to every element of the stream, forcing serial execution.\n     *\n     * @param f A function to apply to each stream element.  Should return 'true'\n     *   to indicate that the stream should continue, or 'false' to cause it to\n     *   terminate.\n     */\n    async serialForEach(f) {\n        return this.serialMapAsync(f).resolveWhile(x => (x === true));\n    }\n    /**\n     * Groups elements into batches, represented as arrays of elements.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"Row-major\" means that the resulting batch is simply a collection of\n     * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major\n     * form, which is needed for vectorized computation.\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @returns A `LazyIterator` of batches of elements, represented as arrays\n     *   of the original element type.\n     */\n    rowMajorBatch(batchSize, smallLastBatch = true) {\n        return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n    }\n    /**\n     * Groups elements into batches, represented in column-major form.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"column-major\" means that the resulting batch is a (potentially\n     * nested) structure representing the columns.  Each column entry, then,\n     * contains a collection of the values found in that column for a range of\n     * input elements.  This representation allows for vectorized computation, in\n     * contrast to the row-major form.\n     *\n     * The inputs should all have the same nested structure (i.e., of arrays and\n     * dicts).  The result is a single object with the same nested structure,\n     * where the leaves are arrays collecting the values of the inputs at that\n     * location (or, optionally, the result of a custom function applied to those\n     * arrays).\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @param zipFn: (optional) A function that expects an array of elements at a\n     *   single node of the object tree, and returns a `DeepMapResult`.  The\n     *   `DeepMapResult` either provides a result value for that node (i.e.,\n     *   representing the subtree), or indicates that the node should be processed\n     *   recursively.  The default zipFn recurses as far as possible and places\n     *   arrays at the leaves.\n     * @returns A `LazyIterator` of batches of elements, represented as an object\n     *   with collections at the leaves.\n     */\n    columnMajorBatch(batchSize, smallLastBatch = true, \n    // tslint:disable-next-line:no-any\n    zipFn = zipToList) {\n        // First collect the desired number of input elements as a row-major batch.\n        const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);\n        // Now 'rotate' or 'pivot' the data, collecting all values from each column\n        // in the batch (i.e., for each key within the elements) into an array.\n        return rowBatches.map(x => deepZip(x, zipFn));\n    }\n    /**\n     * Concatenate this `LazyIterator` with another.\n     *\n     * @param iterator A `LazyIterator` to be concatenated onto this one.\n     * @param baseErrorHandler An optional function that can intercept `Error`s\n     *   raised during a `next()` call on the base stream.  This function can\n     *   decide whether the error should be propagated, whether the error should\n     *   be ignored, or whether the base stream should be terminated.\n     * @returns A `LazyIterator`.\n     */\n    concatenate(iterator, baseErrorHandler) {\n        return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);\n    }\n    /**\n     * Limits this stream to return at most `count` items.\n     *\n     * @param count The maximum number of items to provide from the stream. If\n     * a negative or undefined value is given, the entire stream is returned\n     *   unaltered.\n     */\n    take(count) {\n        if (count < 0 || count == null) {\n            return this;\n        }\n        return new TakeIterator(this, count);\n    }\n    /**\n     * Skips the first `count` items in this stream.\n     *\n     * @param count The number of items to skip.  If a negative or undefined\n     * value is given, the entire stream is returned unaltered.\n     */\n    skip(count) {\n        if (count < 0 || count == null) {\n            return this;\n        }\n        return new SkipIterator(this, count);\n    }\n    /**\n     * Prefetch the first `bufferSize` items in this stream.\n     *\n     * Note this prefetches Promises, but makes no guarantees about when those\n     * Promises resolve.\n     *\n     * @param bufferSize: An integer specifying the number of elements to be\n     *   prefetched.\n     */\n    prefetch(bufferSize) {\n        return new PrefetchIterator(this, bufferSize);\n    }\n    // TODO(soergel): deep sharded shuffle, where supported\n    /**\n     * Randomly shuffles the elements of this stream.\n     *\n     * @param bufferSize: An integer specifying the number of elements from\n     * this stream from which the new stream will sample.\n     * @param seed: (Optional.) An integer specifying the random seed that\n     * will be used to create the distribution.\n     */\n    shuffle(windowSize, seed) {\n        return new ShuffleIterator(this, windowSize, seed);\n    }\n    /**\n     * Force an iterator to execute serially: each next() call will await the\n     * prior one, so that they cannot execute concurrently.\n     */\n    serial() {\n        return new SerialIterator(this);\n    }\n}\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on LazyIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n// Iterators that just extend LazyIterator directly\n// ============================================================================\nclass ArrayIterator extends LazyIterator {\n    constructor(items) {\n        super();\n        this.items = items;\n        this.trav = 0;\n    }\n    summary() {\n        return `Array of ${this.items.length} items`;\n    }\n    async next() {\n        if (this.trav >= this.items.length) {\n            return { value: null, done: true };\n        }\n        const item = this.items[this.trav];\n        this.trav++;\n        return { value: deepClone(item), done: false };\n    }\n}\nclass FunctionCallIterator extends LazyIterator {\n    constructor(nextFn) {\n        super();\n        this.nextFn = nextFn;\n    }\n    summary() {\n        return `Function call`;\n    }\n    async next() {\n        try {\n            return this.nextFn();\n        }\n        catch (e) {\n            // Modify the error message but leave the stack trace intact\n            e.message =\n                `Error thrown while iterating through a dataset: ${e.message}`;\n            throw e;\n        }\n    }\n}\nclass SerialIterator extends LazyIterator {\n    constructor(upstream) {\n        super();\n        this.upstream = upstream;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Serial`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        return this.upstream.next();\n    }\n}\nclass SkipIterator extends LazyIterator {\n    constructor(upstream, maxCount) {\n        super();\n        this.upstream = upstream;\n        this.maxCount = maxCount;\n        // Local state that should not be clobbered by out-of-order execution.\n        this.count = 0;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Skip`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        // TODO(soergel): consider tradeoffs of reading in parallel, eg.\n        // collecting next() promises in an Array and then waiting for\n        // Promise.all() of those. Benefit: pseudo-parallel execution.  Drawback:\n        // maybe delayed GC.\n        while (this.count++ < this.maxCount) {\n            const skipped = await this.upstream.next();\n            // short-circuit if upstream is already empty\n            if (skipped.done) {\n                return skipped;\n            }\n            tf.dispose(skipped.value);\n        }\n        return this.upstream.next();\n    }\n}\nclass TakeIterator extends LazyIterator {\n    constructor(upstream, maxCount) {\n        super();\n        this.upstream = upstream;\n        this.maxCount = maxCount;\n        this.count = 0;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Take`;\n    }\n    async next() {\n        if (this.count++ >= this.maxCount) {\n            return { value: null, done: true };\n        }\n        return this.upstream.next();\n    }\n}\n// Note this batch just groups items into row-wise element arrays.\n// Rotating these to a column-wise representation happens only at the dataset\n// level.\nclass RowMajorBatchIterator extends LazyIterator {\n    constructor(upstream, batchSize, enableSmallLastBatch = true) {\n        super();\n        this.upstream = upstream;\n        this.batchSize = batchSize;\n        this.enableSmallLastBatch = enableSmallLastBatch;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> RowMajorBatch`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        const batch = [];\n        while (batch.length < this.batchSize) {\n            const item = await this.upstream.next();\n            if (item.done) {\n                if (this.enableSmallLastBatch && batch.length > 0) {\n                    return { value: batch, done: false };\n                }\n                return { value: null, done: true };\n            }\n            batch.push(item.value);\n        }\n        return { value: batch, done: false };\n    }\n}\nclass FilterIterator extends LazyIterator {\n    constructor(upstream, predicate) {\n        super();\n        this.upstream = upstream;\n        this.predicate = predicate;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Filter`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        while (true) {\n            const item = await this.upstream.next();\n            if (item.done || this.predicate(item.value)) {\n                return item;\n            }\n            tf.dispose(item.value);\n        }\n    }\n}\nclass MapIterator extends LazyIterator {\n    constructor(upstream, transform) {\n        super();\n        this.upstream = upstream;\n        this.transform = transform;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Map`;\n    }\n    async next() {\n        const item = await this.upstream.next();\n        if (item.done) {\n            return { value: null, done: true };\n        }\n        const inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n        // Careful: the transform may mutate the item in place.\n        // That's why we have to remember the input Tensors above, and then\n        // below dispose only those that were not passed through to the output.\n        // Note too that the transform function is responsible for tidying\n        // any intermediate Tensors.  Here we are concerned only about the\n        // inputs.\n        const mapped = this.transform(item.value);\n        const outputTensors = tf.tensor_util.getTensorsInContainer(mapped);\n        // TODO(soergel) faster intersection\n        // TODO(soergel) move to tf.disposeExcept(in, out)?\n        for (const t of inputTensors) {\n            if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                t.dispose();\n            }\n        }\n        return { value: mapped, done: false };\n    }\n}\nclass ErrorHandlingLazyIterator extends LazyIterator {\n    constructor(upstream, handler) {\n        super();\n        this.upstream = upstream;\n        this.handler = handler;\n        this.count = 0;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> handleErrors`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        while (true) {\n            try {\n                return await this.upstream.next();\n            }\n            catch (e) {\n                if (!this.handler(e)) {\n                    return { value: null, done: true };\n                }\n                // If the handler returns true, loop and fetch the next upstream item.\n                // If the upstream iterator throws an endless stream of errors, and if\n                // the handler says to ignore them, then we loop forever here.  That is\n                // the correct behavior-- it's up to the handler to decide when to stop.\n            }\n        }\n    }\n}\nclass AsyncMapIterator extends LazyIterator {\n    constructor(upstream, transform) {\n        super();\n        this.upstream = upstream;\n        this.transform = transform;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> AsyncMap`;\n    }\n    async next() {\n        const item = await this.upstream.next();\n        if (item.done) {\n            return { value: null, done: true };\n        }\n        const inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n        // Careful: the transform may mutate the item in place.\n        // That's why we have to remember the input Tensors above, and then\n        // below dispose only those that were not passed through to the output.\n        // Note too that the transform function is responsible for tidying\n        // any intermediate Tensors.  Here we are concerned only about the\n        // inputs.\n        const mapped = await this.transform(item.value);\n        const outputTensors = tf.tensor_util.getTensorsInContainer(mapped);\n        // TODO(soergel) faster intersection\n        // TODO(soergel) move to tf.disposeExcept(in, out)?\n        for (const t of inputTensors) {\n            if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                t.dispose();\n            }\n        }\n        return { value: mapped, done: false };\n    }\n}\n// Iterators that maintain a queue of pending items\n// ============================================================================\n/**\n * A base class for transforming streams that operate by maintaining an\n * output queue of elements that are ready to return via next().  This is\n * commonly required when the transformation is 1-to-many:  A call to next()\n * may trigger a call to the underlying stream, which will produce many\n * mapped elements of this stream-- of which we need to return only one, so\n * we have to queue the rest.\n */\nexport class OneToManyIterator extends LazyIterator {\n    constructor() {\n        super();\n        this.outputQueue = new GrowingRingBuffer();\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        // Fetch so that the queue contains at least one item if possible.\n        // If the upstream source is exhausted, AND there are no items left in\n        // the output queue, then this stream is also exhausted.\n        while (this.outputQueue.length() === 0) {\n            // TODO(soergel): consider parallel reads.\n            if (!await this.pump()) {\n                return { value: null, done: true };\n            }\n        }\n        return { value: this.outputQueue.shift(), done: false };\n    }\n}\nclass FlatmapIterator extends OneToManyIterator {\n    constructor(upstream, transform) {\n        super();\n        this.upstream = upstream;\n        this.transform = transform;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Flatmap`;\n    }\n    async pump() {\n        const item = await this.upstream.next();\n        if (item.done) {\n            return false;\n        }\n        const inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n        // Careful: the transform may mutate the item in place.\n        // that's why we have to remember the input Tensors above, and then\n        // below dispose only those that were not passed through to the output.\n        // Note too that the transform function is responsible for tidying any\n        // intermediate Tensors.  Here we are concerned only about the inputs.\n        const mappedArray = this.transform(item.value);\n        const outputTensors = tf.tensor_util.getTensorsInContainer(mappedArray);\n        this.outputQueue.pushAll(mappedArray);\n        // TODO(soergel) faster intersection, and deduplicate outputTensors\n        // TODO(soergel) move to tf.disposeExcept(in, out)?\n        for (const t of inputTensors) {\n            if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                t.dispose();\n            }\n        }\n        return true;\n    }\n}\n/**\n * Provides a `LazyIterator` that concatenates a stream of underlying\n * streams.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n */\nexport class ChainedIterator extends LazyIterator {\n    constructor(iterators, baseErrorHandler) {\n        super();\n        this.baseErrorHandler = baseErrorHandler;\n        // Strict Promise execution order:\n        // a next() call may not even begin until the previous one completes.\n        this.lastRead = null;\n        // Local state that should not be clobbered by out-of-order execution.\n        this.iterator = null;\n        this.moreIterators = iterators;\n    }\n    summary() {\n        const upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n        return `${upstreamSummaries} -> Chained`;\n    }\n    async next() {\n        this.lastRead = this.readFromChain(this.lastRead);\n        return this.lastRead;\n    }\n    async readFromChain(lastRead) {\n        // Must await on the previous read since the previous read may have advanced\n        // the stream of streams, from which we need to read.\n        // This is unfortunate since we can't parallelize reads. Which means\n        // prefetching of chained streams is a no-op.\n        // One solution is to prefetch immediately upstream of this.\n        await lastRead;\n        if (this.iterator == null) {\n            const iteratorResult = await this.moreIterators.next();\n            if (iteratorResult.done) {\n                // No more streams to stream from.\n                return { value: null, done: true };\n            }\n            this.iterator = iteratorResult.value;\n            if (this.baseErrorHandler != null) {\n                this.iterator = this.iterator.handleErrors(this.baseErrorHandler);\n            }\n        }\n        const itemResult = await this.iterator.next();\n        if (itemResult.done) {\n            this.iterator = null;\n            return this.readFromChain(lastRead);\n        }\n        return itemResult;\n    }\n}\nexport var ZipMismatchMode;\n(function (ZipMismatchMode) {\n    ZipMismatchMode[ZipMismatchMode[\"FAIL\"] = 0] = \"FAIL\";\n    ZipMismatchMode[ZipMismatchMode[\"SHORTEST\"] = 1] = \"SHORTEST\";\n    ZipMismatchMode[ZipMismatchMode[\"LONGEST\"] = 2] = \"LONGEST\"; // use nulls for exhausted streams; use up the longest stream.\n})(ZipMismatchMode || (ZipMismatchMode = {}));\n/**\n * Provides a `LazyIterator` that zips together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nclass ZipIterator extends LazyIterator {\n    constructor(iterators, mismatchMode = ZipMismatchMode.FAIL) {\n        super();\n        this.iterators = iterators;\n        this.mismatchMode = mismatchMode;\n        this.count = 0;\n        this.currentPromise = null;\n    }\n    summary() {\n        const upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n        return `{${upstreamSummaries}} -> Zip`;\n    }\n    async nextState(afterState) {\n        // This chaining ensures that the underlying next() are not even called\n        // before the previous ones have resolved.\n        await afterState;\n        // Collect underlying iterator \"done\" signals as a side effect in\n        // getNext()\n        let numIterators = 0;\n        let iteratorsDone = 0;\n        function getNext(container) {\n            if (container instanceof LazyIterator) {\n                const result = container.next();\n                return {\n                    value: result.then(x => {\n                        numIterators++;\n                        if (x.done) {\n                            iteratorsDone++;\n                        }\n                        return x.value;\n                    }),\n                    recurse: false\n                };\n            }\n            else {\n                return { value: null, recurse: true };\n            }\n        }\n        const mapped = await deepMapAndAwaitAll(this.iterators, getNext);\n        if (numIterators === iteratorsDone) {\n            // The streams have all ended.\n            return { value: null, done: true };\n        }\n        if (iteratorsDone > 0) {\n            switch (this.mismatchMode) {\n                case ZipMismatchMode.FAIL:\n                    throw new Error('Zipped streams should have the same length. ' +\n                        `Mismatched at element ${this.count}.`);\n                case ZipMismatchMode.SHORTEST:\n                    return { value: null, done: true };\n                case ZipMismatchMode.LONGEST:\n                default:\n                // Continue.  The exhausted streams already produced value: null.\n            }\n        }\n        this.count++;\n        return { value: mapped, done: false };\n    }\n    async next() {\n        this.currentPromise = this.nextState(this.currentPromise);\n        return this.currentPromise;\n    }\n}\n// Iterators that maintain a ring buffer of pending promises\n// ============================================================================\n/**\n * A stream that prefetches a given number of items from an upstream source,\n * returning them in FIFO order.\n *\n * Note this prefetches Promises, but makes no guarantees about when those\n * Promises resolve.\n */\nexport class PrefetchIterator extends LazyIterator {\n    constructor(upstream, bufferSize) {\n        super();\n        this.upstream = upstream;\n        this.bufferSize = bufferSize;\n        this.buffer = new RingBuffer(bufferSize);\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Prefetch`;\n    }\n    /**\n     * Refill the prefetch buffer.  Returns only after the buffer is full, or\n     * the upstream source is exhausted.\n     */\n    refill() {\n        while (!this.buffer.isFull()) {\n            const v = this.upstream.next();\n            this.buffer.push(v);\n        }\n    }\n    next() {\n        this.refill();\n        // This shift will never throw an error because the buffer is always\n        // full after a refill. If the stream is exhausted, the buffer will be\n        // full of Promises that will resolve to the end-of-stream signal.\n        return this.buffer.shift();\n    }\n}\n/**\n * A stream that performs a sliding-window random shuffle on an upstream\n * source. This is like a `PrefetchIterator` except that the items are\n * returned in randomized order.  Mixing naturally improves as the buffer\n * size increases.\n */\nexport class ShuffleIterator extends PrefetchIterator {\n    constructor(upstream, windowSize, seed) {\n        super(upstream, windowSize);\n        this.upstream = upstream;\n        this.windowSize = windowSize;\n        // Local state that should not be clobbered by out-of-order execution.\n        this.upstreamExhausted = false;\n        this.random = seedrandom.alea(seed || tf.util.now().toString());\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    randomInt(max) {\n        return Math.floor(this.random() * max);\n    }\n    chooseIndex() {\n        return this.randomInt(this.buffer.length());\n    }\n    async serialNext() {\n        // TODO(soergel): consider performance\n        if (!this.upstreamExhausted) {\n            this.refill();\n        }\n        while (!this.buffer.isEmpty()) {\n            const chosenIndex = this.chooseIndex();\n            const result = await this.buffer.shuffleExcise(chosenIndex);\n            if (result.done) {\n                this.upstreamExhausted = true;\n            }\n            else {\n                this.refill();\n                return result;\n            }\n        }\n        return { value: null, done: true };\n    }\n}\n//# sourceMappingURL=lazy_iterator.js.map"]},"metadata":{},"sourceType":"module"}