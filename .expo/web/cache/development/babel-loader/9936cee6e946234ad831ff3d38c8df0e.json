{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, env, image, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from \"./lazy_iterator\";\nexport var WebcamIterator = function (_LazyIterator) {\n  _inherits(WebcamIterator, _LazyIterator);\n\n  var _super = _createSuper(WebcamIterator);\n\n  function WebcamIterator(webcamVideoElement, webcamConfig) {\n    var _this;\n\n    _classCallCheck(this, WebcamIterator);\n\n    _this = _super.call(this);\n    _this.webcamVideoElement = webcamVideoElement;\n    _this.webcamConfig = webcamConfig;\n    _this.isClosed = true;\n    _this.resize = false;\n\n    if (_this.needToResize()) {\n      _this.resize = true;\n      _this.cropSize = [_this.webcamConfig.resizeHeight, _this.webcamConfig.resizeWidth];\n      _this.cropBoxInd = tensor1d([0], 'int32');\n\n      if (_this.webcamConfig.centerCrop) {\n        var widthCroppingRatio = _this.webcamConfig.resizeWidth * 1.0 / _this.webcamVideoElement.width;\n        var heightCroppingRatio = _this.webcamConfig.resizeHeight * 1.0 / _this.webcamVideoElement.height;\n        var widthCropStart = (1 - widthCroppingRatio) / 2;\n        var heightCropStart = (1 - heightCroppingRatio) / 2;\n        var widthCropEnd = widthCropStart + widthCroppingRatio;\n        var heightCropEnd = heightCroppingRatio + heightCropStart;\n        _this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n      } else {\n        _this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(WebcamIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"webcam\";\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n\n      return _regeneratorRuntime.async(function start$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (this.webcamConfig.facingMode) {\n                util.assert(this.webcamConfig.facingMode === 'user' || this.webcamConfig.facingMode === 'environment', function () {\n                  return \"Invalid webcam facing mode: \" + _this2.webcamConfig.facingMode + \". \" + \"Please provide 'user' or 'environment'\";\n                });\n              }\n\n              _context.prev = 1;\n              _context.next = 4;\n              return _regeneratorRuntime.awrap(navigator.mediaDevices.getUserMedia({\n                video: {\n                  deviceId: this.webcamConfig.deviceId,\n                  facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : 'user',\n                  width: this.webcamVideoElement.width,\n                  height: this.webcamVideoElement.height\n                }\n              }));\n\n            case 4:\n              this.stream = _context.sent;\n              _context.next = 11;\n              break;\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](1);\n              _context.t0.message = \"Error thrown while initializing video stream: \" + _context.t0.message;\n              throw _context.t0;\n\n            case 11:\n              if (this.stream) {\n                _context.next = 13;\n                break;\n              }\n\n              throw new Error('Could not obtain video from webcam.');\n\n            case 13:\n              try {\n                this.webcamVideoElement.srcObject = this.stream;\n              } catch (error) {\n                console.log(error);\n                this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n              }\n\n              this.webcamVideoElement.play();\n              this.isClosed = false;\n              return _context.abrupt(\"return\", new Promise(function (resolve) {\n                _this2.webcamVideoElement.onloadedmetadata = function () {\n                  resolve();\n                };\n              }));\n\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, [[1, 7]], Promise);\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var img;\n      return _regeneratorRuntime.async(function next$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!this.isClosed) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n\n            case 2:\n              _context2.prev = 2;\n              img = browser.fromPixels(this.webcamVideoElement);\n              _context2.next = 9;\n              break;\n\n            case 6:\n              _context2.prev = 6;\n              _context2.t0 = _context2[\"catch\"](2);\n              throw new Error(\"Error thrown converting video to pixels: \" + JSON.stringify(_context2.t0));\n\n            case 9:\n              if (!this.resize) {\n                _context2.next = 22;\n                break;\n              }\n\n              _context2.prev = 10;\n              return _context2.abrupt(\"return\", {\n                value: this.cropAndResizeFrame(img),\n                done: false\n              });\n\n            case 14:\n              _context2.prev = 14;\n              _context2.t1 = _context2[\"catch\"](10);\n              throw new Error(\"Error thrown cropping the video: \" + _context2.t1.message);\n\n            case 17:\n              _context2.prev = 17;\n              img.dispose();\n              return _context2.finish(17);\n\n            case 20:\n              _context2.next = 23;\n              break;\n\n            case 22:\n              return _context2.abrupt(\"return\", {\n                value: img,\n                done: false\n              });\n\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, [[2, 6], [10, 14, 17, 20]], Promise);\n    }\n  }, {\n    key: \"needToResize\",\n    value: function needToResize() {\n      if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"cropAndResizeFrame\",\n    value: function cropAndResizeFrame(img) {\n      var _this3 = this;\n\n      return tidy(function () {\n        var expandedImage = img.toFloat().expandDims(0);\n        var resizedImage;\n        resizedImage = image.cropAndResize(expandedImage, _this3.cropBox, _this3.cropBoxInd, _this3.cropSize, 'bilinear');\n        var shape = resizedImage.shape;\n        return resizedImage.reshape(shape.slice(1));\n      });\n    }\n  }, {\n    key: \"capture\",\n    value: function capture() {\n      return _regeneratorRuntime.async(function capture$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _regeneratorRuntime.awrap(this.next());\n\n            case 2:\n              return _context3.abrupt(\"return\", _context3.sent.value);\n\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var tracks = this.stream.getTracks();\n      tracks.forEach(function (track) {\n        return track.stop();\n      });\n\n      try {\n        this.webcamVideoElement.srcObject = null;\n      } catch (error) {\n        console.log(error);\n        this.webcamVideoElement.src = null;\n      }\n\n      this.isClosed = true;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      throw new Error('Can not convert infinite video stream to array.');\n    }\n  }], [{\n    key: \"create\",\n    value: function create(webcamVideoElement) {\n      var webcamConfig,\n          webcamIterator,\n          _args4 = arguments;\n      return _regeneratorRuntime.async(function create$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              webcamConfig = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n\n              if (!env().get('IS_NODE')) {\n                _context4.next = 3;\n                break;\n              }\n\n              throw new Error('tf.data.webcam is only supported in browser environment.');\n\n            case 3:\n              if (webcamVideoElement) {\n                _context4.next = 9;\n                break;\n              }\n\n              webcamVideoElement = document.createElement('video');\n\n              if (!(!webcamConfig.resizeWidth || !webcamConfig.resizeHeight)) {\n                _context4.next = 7;\n                break;\n              }\n\n              throw new Error('Please provide webcam video element, or resizeWidth and ' + 'resizeHeight to create a hidden video element.');\n\n            case 7:\n              webcamVideoElement.width = webcamConfig.resizeWidth;\n              webcamVideoElement.height = webcamConfig.resizeHeight;\n\n            case 9:\n              webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);\n              _context4.next = 12;\n              return _regeneratorRuntime.awrap(webcamIterator.start());\n\n            case 12:\n              return _context4.abrupt(\"return\", webcamIterator);\n\n            case 13:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }]);\n\n  return WebcamIterator;\n}(LazyIterator);","map":{"version":3,"sources":["../../src/iterators/webcam_iterator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, env, image, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\nexport class WebcamIterator extends LazyIterator {\n    constructor(webcamVideoElement, webcamConfig) {\n        super();\n        this.webcamVideoElement = webcamVideoElement;\n        this.webcamConfig = webcamConfig;\n        this.isClosed = true;\n        this.resize = false;\n        if (this.needToResize()) {\n            this.resize = true;\n            this.cropSize =\n                [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n            this.cropBoxInd = tensor1d([0], 'int32');\n            if (this.webcamConfig.centerCrop) {\n                // Calculate the box based on resizing shape.\n                const widthCroppingRatio = this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n                const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 /\n                    this.webcamVideoElement.height;\n                const widthCropStart = (1 - widthCroppingRatio) / 2;\n                const heightCropStart = (1 - heightCroppingRatio) / 2;\n                const widthCropEnd = widthCropStart + widthCroppingRatio;\n                const heightCropEnd = heightCroppingRatio + heightCropStart;\n                this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n            }\n            else {\n                this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n            }\n        }\n    }\n    summary() {\n        return `webcam`;\n    }\n    // Construct a WebcamIterator and start it's video stream.\n    static async create(webcamVideoElement, webcamConfig = {}) {\n        if (env().get('IS_NODE')) {\n            throw new Error('tf.data.webcam is only supported in browser environment.');\n        }\n        if (!webcamVideoElement) {\n            // If webcam video element is not provided, create a hidden video element\n            // with provided width and height.\n            webcamVideoElement = document.createElement('video');\n            if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n                throw new Error('Please provide webcam video element, or resizeWidth and ' +\n                    'resizeHeight to create a hidden video element.');\n            }\n            webcamVideoElement.width = webcamConfig.resizeWidth;\n            webcamVideoElement.height = webcamConfig.resizeHeight;\n        }\n        const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);\n        // Call async function to initialize the video stream.\n        await webcamIterator.start();\n        return webcamIterator;\n    }\n    // Async function to start video stream.\n    async start() {\n        if (this.webcamConfig.facingMode) {\n            util.assert((this.webcamConfig.facingMode === 'user') ||\n                (this.webcamConfig.facingMode === 'environment'), () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. ` +\n                `Please provide 'user' or 'environment'`);\n        }\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    deviceId: this.webcamConfig.deviceId,\n                    facingMode: this.webcamConfig.facingMode ?\n                        this.webcamConfig.facingMode :\n                        'user',\n                    width: this.webcamVideoElement.width,\n                    height: this.webcamVideoElement.height\n                }\n            });\n        }\n        catch (e) {\n            // Modify the error message but leave the stack trace intact\n            e.message = `Error thrown while initializing video stream: ${e.message}`;\n            throw e;\n        }\n        if (!this.stream) {\n            throw new Error('Could not obtain video from webcam.');\n        }\n        // Older browsers may not have srcObject\n        try {\n            this.webcamVideoElement.srcObject = this.stream;\n        }\n        catch (error) {\n            console.log(error);\n            this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n        }\n        // Start the webcam video stream\n        this.webcamVideoElement.play();\n        this.isClosed = false;\n        return new Promise(resolve => {\n            // Add event listener to make sure the webcam has been fully initialized.\n            this.webcamVideoElement.onloadedmetadata = () => {\n                resolve();\n            };\n        });\n    }\n    async next() {\n        if (this.isClosed) {\n            return { value: null, done: true };\n        }\n        let img;\n        try {\n            img = browser.fromPixels(this.webcamVideoElement);\n        }\n        catch (e) {\n            throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n        }\n        if (this.resize) {\n            try {\n                return { value: this.cropAndResizeFrame(img), done: false };\n            }\n            catch (e) {\n                throw new Error(`Error thrown cropping the video: ${e.message}`);\n            }\n            finally {\n                img.dispose();\n            }\n        }\n        else {\n            return { value: img, done: false };\n        }\n    }\n    needToResize() {\n        // If resizeWidth and resizeHeight are provided, and different from the\n        // width and height of original HTMLVideoElement, then resizing and cropping\n        // is required.\n        if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight &&\n            (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth ||\n                this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n            return true;\n        }\n        return false;\n    }\n    // Cropping and resizing each frame based on config\n    cropAndResizeFrame(img) {\n        return tidy(() => {\n            const expandedImage = img.toFloat().expandDims(0);\n            let resizedImage;\n            resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, 'bilinear');\n            // Extract image from batch cropping.\n            const shape = resizedImage.shape;\n            return resizedImage.reshape(shape.slice(1));\n        });\n    }\n    // Capture one frame from the video stream, and extract the value from\n    // iterator.next() result.\n    async capture() {\n        return (await this.next()).value;\n    }\n    // Stop the video stream and pause webcam iterator.\n    stop() {\n        const tracks = this.stream.getTracks();\n        tracks.forEach(track => track.stop());\n        try {\n            this.webcamVideoElement.srcObject = null;\n        }\n        catch (error) {\n            console.log(error);\n            this.webcamVideoElement.src = null;\n        }\n        this.isClosed = true;\n    }\n    // Override toArray() function to prevent collecting.\n    toArray() {\n        throw new Error('Can not convert infinite video stream to array.');\n    }\n}\n//# sourceMappingURL=webcam_iterator.js.map"]},"metadata":{},"sourceType":"module"}