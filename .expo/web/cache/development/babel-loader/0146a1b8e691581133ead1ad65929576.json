{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function getLogicalCoordinatesFromFlatIndex(coords, shape) {\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'index';\n  var strides = util.computeStrides(shape);\n  return strides.map(function (stride, i) {\n    var line1 = \"int \" + coords[i] + \" = \" + index + \" / \" + stride;\n    var line2 = i === strides.length - 1 ? \"int \" + coords[i + 1] + \" = \" + index + \" - \" + coords[i] + \" * \" + stride : \"index -= \" + coords[i] + \" * \" + stride;\n    return line1 + \"; \" + line2 + \";\";\n  }).join('');\n}\n\nfunction buildVec(x) {\n  if (x.length === 1) {\n    return \"\" + x[0];\n  }\n\n  return \"vec\" + x.length + \"(\" + x.join(',') + \")\";\n}\n\nexport function dotify(x, y) {\n  if (x.length !== y.length) {\n    throw new Error(\"Vectors to be dotted must be of the same length -\" + (\"got \" + x.length + \" and \" + y.length));\n  }\n\n  var slices = [];\n  var nearestVec4 = Math.floor(x.length / 4);\n  var nearestVec4Remainder = x.length % 4;\n\n  for (var i = 0; i < nearestVec4; i++) {\n    var xSlice = x.slice(i * 4, i * 4 + 4);\n    var ySlice = y.slice(i * 4, i * 4 + 4);\n    slices.push(buildVec(xSlice) + \", \" + buildVec(ySlice));\n  }\n\n  if (nearestVec4Remainder !== 0) {\n    var _xSlice = x.slice(nearestVec4 * 4);\n\n    var _ySlice = y.slice(nearestVec4 * 4);\n\n    if (_xSlice.length === 1) {\n      _xSlice = _xSlice.map(function (d) {\n        return \"float(\" + d + \")\";\n      });\n      _ySlice = _ySlice.map(function (d) {\n        return \"float(\" + d + \")\";\n      });\n    }\n\n    slices.push(buildVec(_xSlice) + \", \" + buildVec(_ySlice));\n  }\n\n  return slices.map(function (d, i) {\n    return \"dot(\" + d + \")\";\n  }).join('+');\n}\nexport function getFlatIndexFrom3D(shape) {\n  var strides = util.computeStrides(shape).map(function (d) {\n    return d.toString();\n  });\n  return \"\\n  int getFlatIndex(ivec3 coords) {\\n    return coords.x * \" + strides[0] + \" + coords.y * \" + strides[1] + \" + coords.z;\\n  }\\n\";\n}\nexport var ENCODE_FLOAT_SNIPPET = \"\\n  const float FLOAT_MAX = 1.70141184e38;\\n  const float FLOAT_MIN = 1.17549435e-38;\\n\\n  lowp vec4 encode_float(highp float v) {\\n    if (isnan(v)) {\\n      return vec4(255, 255, 255, 255);\\n    }\\n\\n    highp float av = abs(v);\\n\\n    if(av < FLOAT_MIN) {\\n      return vec4(0.0, 0.0, 0.0, 0.0);\\n    } else if(v > FLOAT_MAX) {\\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n    } else if(v < -FLOAT_MAX) {\\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n    }\\n\\n    highp vec4 c = vec4(0,0,0,0);\\n\\n    highp float e = floor(log2(av));\\n    highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n    c[2] = floor(128.0 * m);\\n    m -= c[2] / 128.0;\\n    c[1] = floor(32768.0 * m);\\n    m -= c[1] / 32768.0;\\n    c[0] = floor(8388608.0 * m);\\n\\n    highp float ebias = e + 127.0;\\n    c[3] = floor(ebias / 2.0);\\n    ebias -= c[3] * 2.0;\\n    c[2] += floor(ebias) * 128.0;\\n\\n    c[3] += 128.0 * step(0.0, -v);\\n\\n    return c / 255.0;\\n  }\\n\";","map":{"version":3,"sources":["../src/shader_compiler_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nexport function getLogicalCoordinatesFromFlatIndex(coords, shape, index = 'index') {\n    const strides = util.computeStrides(shape);\n    return strides\n        .map((stride, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n            `index -= ${coords[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n    })\n        .join('');\n}\nfunction buildVec(x) {\n    if (x.length === 1) {\n        return `${x[0]}`;\n    }\n    return `vec${x.length}(${x.join(',')})`;\n}\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\nexport function dotify(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(`Vectors to be dotted must be of the same length -` +\n            `got ${x.length} and ${y.length}`);\n    }\n    const slices = [];\n    const nearestVec4 = Math.floor(x.length / 4);\n    const nearestVec4Remainder = x.length % 4;\n    for (let i = 0; i < nearestVec4; i++) {\n        const xSlice = x.slice(i * 4, i * 4 + 4);\n        const ySlice = y.slice(i * 4, i * 4 + 4);\n        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n    }\n    if (nearestVec4Remainder !== 0) {\n        let xSlice = x.slice(nearestVec4 * 4);\n        let ySlice = y.slice(nearestVec4 * 4);\n        if (xSlice.length === 1) {\n            xSlice = xSlice.map(d => `float(${d})`);\n            ySlice = ySlice.map(d => `float(${d})`);\n        }\n        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n    }\n    return slices.map((d, i) => `dot(${d})`).join('+');\n}\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nexport function getFlatIndexFrom3D(shape) {\n    const strides = util.computeStrides(shape).map(d => d.toString());\n    return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;\n//# sourceMappingURL=shader_compiler_util.js.map"]},"metadata":{},"sourceType":"module"}