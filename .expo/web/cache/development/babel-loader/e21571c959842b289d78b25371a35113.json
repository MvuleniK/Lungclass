{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { Dataset } from \"../dataset\";\nimport { TextLineDataset } from \"./text_line_dataset\";\nvar CODE_QUOTE = '\"';\nvar STATE_OUT = Symbol('out');\nvar STATE_FIELD = Symbol('field');\nvar STATE_QUOTE = Symbol('quote');\nvar STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nvar STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\nexport var CSVDataset = function (_Dataset) {\n  _inherits(CSVDataset, _Dataset);\n\n  var _super = _createSuper(CSVDataset);\n\n  function CSVDataset(input, csvConfig) {\n    var _this;\n\n    _classCallCheck(this, CSVDataset);\n\n    _this = _super.call(this);\n    _this.input = input;\n    _this.hasHeader = true;\n    _this.fullColumnNames = null;\n    _this.columnNamesValidated = false;\n    _this.columnConfigs = null;\n    _this.configuredColumnsOnly = false;\n    _this.delimiter = ',';\n    _this.delimWhitespace = false;\n    _this.base = new TextLineDataset(input);\n\n    if (!csvConfig) {\n      csvConfig = {};\n    }\n\n    _this.hasHeader = csvConfig.hasHeader === false ? false : true;\n    _this.fullColumnNames = csvConfig.columnNames;\n    _this.columnConfigs = csvConfig.columnConfigs;\n    _this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n\n    if (csvConfig.delimWhitespace) {\n      util.assert(csvConfig.delimiter == null, function () {\n        return 'Delimiter should not be provided when delimWhitespace is true.';\n      });\n      _this.delimWhitespace = true;\n      _this.delimiter = ' ';\n    } else {\n      _this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n    }\n\n    return _this;\n  }\n\n  _createClass(CSVDataset, [{\n    key: \"columnNames\",\n    value: function columnNames() {\n      return _regeneratorRuntime.async(function columnNames$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (this.columnNamesValidated) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(this.setColumnNames());\n\n            case 3:\n              return _context.abrupt(\"return\", this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames);\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setColumnNames\",\n    value: function setColumnNames() {\n      var _this2 = this;\n\n      var columnNamesFromFile, counts, duplicateNames, _i, _Object$keys, key, index;\n\n      return _regeneratorRuntime.async(function setColumnNames$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return _regeneratorRuntime.awrap(this.maybeReadHeaderLine());\n\n            case 2:\n              columnNamesFromFile = _context2.sent;\n\n              if (!(!this.fullColumnNames && !columnNamesFromFile)) {\n                _context2.next = 7;\n                break;\n              }\n\n              throw new Error('Column names must be provided if there is no header line.');\n\n            case 7:\n              if (this.fullColumnNames && columnNamesFromFile) {\n                util.assert(columnNamesFromFile.length === this.fullColumnNames.length, function () {\n                  return 'The length of provided columnNames (' + _this2.fullColumnNames.length.toString() + ') does not match the length of the header line read from ' + 'file (' + columnNamesFromFile.length.toString() + ').';\n                });\n              }\n\n            case 8:\n              if (!this.fullColumnNames) {\n                this.fullColumnNames = columnNamesFromFile;\n              }\n\n              counts = this.fullColumnNames.reduce(function (countAcc, name) {\n                countAcc[name] = countAcc[name] + 1 || 1;\n                return countAcc;\n              }, {});\n              duplicateNames = Object.keys(counts).filter(function (name) {\n                return counts[name] > 1;\n              });\n              util.assert(duplicateNames.length === 0, function () {\n                return 'Duplicate column names found: ' + duplicateNames.toString();\n              });\n\n              if (!this.columnConfigs) {\n                _context2.next = 22;\n                break;\n              }\n\n              _i = 0, _Object$keys = Object.keys(this.columnConfigs);\n\n            case 14:\n              if (!(_i < _Object$keys.length)) {\n                _context2.next = 22;\n                break;\n              }\n\n              key = _Object$keys[_i];\n              index = this.fullColumnNames.indexOf(key);\n\n              if (!(index === -1)) {\n                _context2.next = 19;\n                break;\n              }\n\n              throw new Error('The key \"' + key + '\" provided in columnConfigs does not match any of the column ' + 'names (' + this.fullColumnNames.toString() + ').');\n\n            case 19:\n              _i++;\n              _context2.next = 14;\n              break;\n\n            case 22:\n              this.columnNamesValidated = true;\n\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"maybeReadHeaderLine\",\n    value: function maybeReadHeaderLine() {\n      var iter, firstElement, firstLine, headers;\n      return _regeneratorRuntime.async(function maybeReadHeaderLine$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!this.hasHeader) {\n                _context3.next = 14;\n                break;\n              }\n\n              _context3.next = 3;\n              return _regeneratorRuntime.awrap(this.base.iterator());\n\n            case 3:\n              iter = _context3.sent;\n              _context3.next = 6;\n              return _regeneratorRuntime.awrap(iter.next());\n\n            case 6:\n              firstElement = _context3.sent;\n\n              if (!firstElement.done) {\n                _context3.next = 9;\n                break;\n              }\n\n              throw new Error('No data was found for CSV parsing.');\n\n            case 9:\n              firstLine = firstElement.value;\n              headers = this.parseRow(firstLine, false);\n              return _context3.abrupt(\"return\", headers);\n\n            case 14:\n              return _context3.abrupt(\"return\", null);\n\n            case 15:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"iterator\",\n    value: function iterator() {\n      var _this3 = this;\n\n      var lines;\n      return _regeneratorRuntime.async(function iterator$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (this.columnNamesValidated) {\n                _context4.next = 3;\n                break;\n              }\n\n              _context4.next = 3;\n              return _regeneratorRuntime.awrap(this.setColumnNames());\n\n            case 3:\n              _context4.next = 5;\n              return _regeneratorRuntime.awrap(this.base.iterator());\n\n            case 5:\n              lines = _context4.sent;\n\n              if (this.hasHeader) {\n                lines = lines.skip(1);\n              }\n\n              return _context4.abrupt(\"return\", lines.map(function (x) {\n                return _this3.makeDataElement(x);\n              }));\n\n            case 8:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"makeDataElement\",\n    value: function makeDataElement(line) {\n      var values = this.parseRow(line);\n      var features = {};\n      var labels = {};\n\n      for (var i = 0; i < this.fullColumnNames.length; i++) {\n        var key = this.fullColumnNames[i];\n        var config = this.columnConfigs ? this.columnConfigs[key] : null;\n\n        if (this.configuredColumnsOnly && !config) {\n          continue;\n        } else {\n          var value = values[i];\n          var parsedValue = null;\n\n          if (value === '') {\n            if (config && config.default !== undefined) {\n              parsedValue = config.default;\n            } else if (config && (config.required || config.isLabel)) {\n              throw new Error(\"Required column \" + key + \" is empty in this line: \" + line);\n            } else {\n              parsedValue = undefined;\n            }\n          } else {\n            var valueAsNum = Number(value);\n\n            if (isNaN(valueAsNum)) {\n              if (config && config.dtype === 'bool') {\n                parsedValue = this.getBoolean(value);\n              } else {\n                parsedValue = value;\n              }\n            } else if (!config || !config.dtype) {\n              parsedValue = valueAsNum;\n            } else {\n              switch (config.dtype) {\n                case 'float32':\n                  parsedValue = valueAsNum;\n                  break;\n\n                case 'int32':\n                  parsedValue = Math.floor(valueAsNum);\n                  break;\n\n                case 'bool':\n                  parsedValue = this.getBoolean(value);\n                  break;\n\n                default:\n                  parsedValue = valueAsNum;\n              }\n            }\n          }\n\n          config && config.isLabel ? labels[key] = parsedValue : features[key] = parsedValue;\n        }\n      }\n\n      if (Object.keys(labels).length === 0) {\n        return features;\n      } else {\n        return {\n          xs: features,\n          ys: labels\n        };\n      }\n    }\n  }, {\n    key: \"getBoolean\",\n    value: function getBoolean(value) {\n      if (value === '1' || value.toLowerCase() === 'true') {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: \"parseRow\",\n    value: function parseRow(line) {\n      var validateElementCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var result = [];\n      var readOffset = 0;\n      var readLength = line.length;\n      var currentState = STATE_OUT;\n\n      for (var i = 0; i < readLength; i++) {\n        switch (currentState) {\n          case STATE_OUT:\n            switch (line.charAt(i)) {\n              case CODE_QUOTE:\n                readOffset = i + 1;\n                currentState = STATE_QUOTE;\n                break;\n\n              case this.delimiter:\n                readOffset = i + 1;\n\n                if (this.delimiter === ' ' && this.delimWhitespace) {\n                  break;\n                }\n\n                result.push('');\n                currentState = STATE_OUT;\n                break;\n\n              default:\n                currentState = STATE_FIELD;\n                readOffset = i;\n                break;\n            }\n\n            break;\n\n          case STATE_FIELD:\n            switch (line.charAt(i)) {\n              case this.delimiter:\n                result.push(line.substring(readOffset, i));\n                currentState = STATE_OUT;\n                readOffset = i + 1;\n                break;\n\n              default:\n            }\n\n            break;\n\n          case STATE_QUOTE:\n            switch (line.charAt(i)) {\n              case CODE_QUOTE:\n                currentState = STATE_QUOTE_AFTER_QUOTE;\n                break;\n\n              default:\n            }\n\n            break;\n\n          case STATE_QUOTE_AFTER_QUOTE:\n            switch (line.charAt(i)) {\n              case this.delimiter:\n                result.push(line.substring(readOffset, i - 1));\n                currentState = STATE_OUT;\n                readOffset = i + 1;\n                break;\n\n              case CODE_QUOTE:\n                currentState = STATE_QUOTE;\n                break;\n\n              default:\n                currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n                break;\n            }\n\n            break;\n\n          case STATE_WITHIN_QUOTE_IN_QUOTE:\n            switch (line.charAt(i)) {\n              case CODE_QUOTE:\n                currentState = STATE_QUOTE;\n                break;\n\n              default:\n            }\n\n            break;\n\n          default:\n        }\n      }\n\n      if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n        result.push(line.substring(readOffset, readLength - 1));\n      } else {\n        result.push(line.substring(readOffset));\n      }\n\n      if (validateElementCount && result.length !== this.fullColumnNames.length) {\n        throw new Error(\"Invalid row in csv file. Should have \" + this.fullColumnNames.length + \" elements in a row, but got \" + result);\n      }\n\n      return result;\n    }\n  }]);\n\n  return CSVDataset;\n}(Dataset);","map":{"version":3,"sources":["../../src/datasets/csv_dataset.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { Dataset } from '../dataset';\nimport { TextLineDataset } from './text_line_dataset';\nconst CODE_QUOTE = '\"';\nconst STATE_OUT = Symbol('out');\nconst STATE_FIELD = Symbol('field');\nconst STATE_QUOTE = Symbol('quote');\nconst STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nconst STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\n/**\n * Represents a potentially large collection of delimited text records.\n *\n * The produced `TensorContainer`s each contain one key-value pair for\n * every column of the table.  When a field is empty in the incoming data, the\n * resulting value is `undefined`, or throw error if it is required.  Values\n * that can be parsed as numbers are emitted as type `number`, other values\n * are parsed as `string`.\n *\n * The results are not batched.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\nexport class CSVDataset extends Dataset {\n    /**\n     * Create a `CSVDataset`.\n     *\n     * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n     * @param csvConfig (Optional) A CSVConfig object that contains configurations\n     *     of reading and decoding from CSV file(s).\n     *\n     *     hasHeader: (Optional) A boolean value that indicates whether the first\n     *     row of provided CSV file is a header line with column names, and should\n     *     not be included in the data. Defaults to `true`.\n     *\n     *     columnNames: (Optional) A list of strings that corresponds to\n     *     the CSV column names, in order. If provided, it ignores the column\n     *     names inferred from the header row. If not provided, infers the column\n     *     names from the first row of the records. If hasHeader is false and\n     *     columnNames is not provided, this method throws an error.\n     *\n     *     columnConfigs: (Optional) A dictionary whose key is column names, value\n     *     is an object stating if this column is required, column's data type,\n     *     default value, and if this column is label. If provided, keys must\n     *     correspond to names provided in columnNames or inferred from the file\n     *     header lines. If isLabel is true any column, returns an array of two\n     *     items: the first item is a dict of features key/value pairs, the second\n     *     item is a dict of labels key/value pairs. If no feature is marked as\n     *     label, returns a dict of features only.\n     *\n     *     configuredColumnsOnly (Optional) If true, only columns provided in\n     *     columnConfigs will be parsed and provided during iteration.\n     *\n     *     delimiter (Optional) The string used to parse each line of the input\n     *     file. Defaults to `,`.\n     */\n    constructor(input, csvConfig) {\n        super();\n        this.input = input;\n        this.hasHeader = true;\n        this.fullColumnNames = null;\n        this.columnNamesValidated = false;\n        this.columnConfigs = null;\n        this.configuredColumnsOnly = false;\n        this.delimiter = ',';\n        this.delimWhitespace = false;\n        this.base = new TextLineDataset(input);\n        if (!csvConfig) {\n            csvConfig = {};\n        }\n        this.hasHeader = csvConfig.hasHeader === false ? false : true;\n        this.fullColumnNames = csvConfig.columnNames;\n        this.columnConfigs = csvConfig.columnConfigs;\n        this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n        if (csvConfig.delimWhitespace) {\n            util.assert(csvConfig.delimiter == null, () => 'Delimiter should not be provided when delimWhitespace is true.');\n            this.delimWhitespace = true;\n            this.delimiter = ' ';\n        }\n        else {\n            this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n        }\n    }\n    /**\n     * Returns column names of the csv dataset. If `configuredColumnsOnly` is\n     * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is\n     * false and `columnNames` is provided, `columnNames`. If\n     * `configuredColumnsOnly` is false and `columnNames` is not provided, return\n     * all column names parsed from the csv file. For example usage please go to\n     * `tf.data.csv`.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    async columnNames() {\n        if (!this.columnNamesValidated) {\n            await this.setColumnNames();\n        }\n        return this.configuredColumnsOnly ? Object.keys(this.columnConfigs) :\n            this.fullColumnNames;\n    }\n    /* 1) If `columnNames` is provided as string[], use this string[] as output\n     * keys in corresponding order. The length must match the number of inferred\n     * columns if `hasHeader` is true .\n     * 2) If `columnNames` is not provided, parse header line as `columnNames` if\n     * hasHeader is true. If `hasHeader` is false, throw an error.\n     * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must\n     * exist in parsed `columnNames`.\n     */\n    async setColumnNames() {\n        const columnNamesFromFile = await this.maybeReadHeaderLine();\n        if (!this.fullColumnNames && !columnNamesFromFile) {\n            // Throw an error if columnNames is not provided and no header line.\n            throw new Error('Column names must be provided if there is no header line.');\n        }\n        else if (this.fullColumnNames && columnNamesFromFile) {\n            // Check provided columnNames match header line.\n            util.assert(columnNamesFromFile.length === this.fullColumnNames.length, () => 'The length of provided columnNames (' +\n                this.fullColumnNames.length.toString() +\n                ') does not match the length of the header line read from ' +\n                'file (' + columnNamesFromFile.length.toString() + ').');\n        }\n        if (!this.fullColumnNames) {\n            this.fullColumnNames = columnNamesFromFile;\n        }\n        // Check if there are duplicate column names.\n        const counts = this.fullColumnNames.reduce((countAcc, name) => {\n            countAcc[name] = (countAcc[name] + 1) || 1;\n            return countAcc;\n        }, {});\n        const duplicateNames = Object.keys(counts).filter((name) => (counts[name] > 1));\n        util.assert(duplicateNames.length === 0, () => 'Duplicate column names found: ' + duplicateNames.toString());\n        // Check if keys in columnConfigs match columnNames.\n        if (this.columnConfigs) {\n            for (const key of Object.keys(this.columnConfigs)) {\n                const index = this.fullColumnNames.indexOf(key);\n                if (index === -1) {\n                    throw new Error('The key \"' + key +\n                        '\" provided in columnConfigs does not match any of the column ' +\n                        'names (' + this.fullColumnNames.toString() + ').');\n                }\n            }\n        }\n        this.columnNamesValidated = true;\n    }\n    async maybeReadHeaderLine() {\n        if (this.hasHeader) {\n            const iter = await this.base.iterator();\n            const firstElement = await iter.next();\n            if (firstElement.done) {\n                throw new Error('No data was found for CSV parsing.');\n            }\n            const firstLine = firstElement.value;\n            const headers = this.parseRow(firstLine, false);\n            return headers;\n        }\n        else {\n            return null;\n        }\n    }\n    async iterator() {\n        if (!this.columnNamesValidated) {\n            await this.setColumnNames();\n        }\n        let lines = await this.base.iterator();\n        if (this.hasHeader) {\n            // We previously read the first line to get the columnNames.\n            // Now that we're providing data, skip it.\n            lines = lines.skip(1);\n        }\n        return lines.map(x => this.makeDataElement(x));\n    }\n    makeDataElement(line) {\n        const values = this.parseRow(line);\n        const features = {};\n        const labels = {};\n        for (let i = 0; i < this.fullColumnNames.length; i++) {\n            const key = this.fullColumnNames[i];\n            const config = this.columnConfigs ? this.columnConfigs[key] : null;\n            if (this.configuredColumnsOnly && !config) {\n                // This column is not selected.\n                continue;\n            }\n            else {\n                const value = values[i];\n                let parsedValue = null;\n                if (value === '') {\n                    // If default value is provided, use it. If default value is not\n                    // provided, set as undefined.\n                    if (config && config.default !== undefined) {\n                        parsedValue = config.default;\n                    }\n                    else if (config && (config.required || config.isLabel)) {\n                        throw new Error(`Required column ${key} is empty in this line: ${line}`);\n                    }\n                    else {\n                        parsedValue = undefined;\n                    }\n                }\n                else {\n                    // A value is present, so parse it based on type\n                    const valueAsNum = Number(value);\n                    if (isNaN(valueAsNum)) {\n                        // The value is a string and this column is declared as boolean\n                        // in config, parse it as boolean.\n                        if (config && config.dtype === 'bool') {\n                            parsedValue = this.getBoolean(value);\n                        }\n                        else {\n                            // Set value as string\n                            parsedValue = value;\n                        }\n                    }\n                    else if (!config || !config.dtype) {\n                        // If this value is a number and no type config is provided, return\n                        // it as number.\n                        parsedValue = valueAsNum;\n                    }\n                    else {\n                        // If this value is a number and data type is provided, parse it\n                        // according to provided data type.\n                        switch (config.dtype) {\n                            case 'float32':\n                                parsedValue = valueAsNum;\n                                break;\n                            case 'int32':\n                                parsedValue = Math.floor(valueAsNum);\n                                break;\n                            case 'bool':\n                                parsedValue = this.getBoolean(value);\n                                break;\n                            default:\n                                parsedValue = valueAsNum;\n                        }\n                    }\n                }\n                // Check if this column is label.\n                (config && config.isLabel) ? labels[key] = parsedValue :\n                    features[key] = parsedValue;\n            }\n        }\n        // If label exists, return an object of features and labels as {xs:features,\n        // ys:labels}, otherwise return features only.\n        if (Object.keys(labels).length === 0) {\n            return features;\n        }\n        else {\n            return { xs: features, ys: labels };\n        }\n    }\n    getBoolean(value) {\n        if (value === '1' || value.toLowerCase() === 'true') {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    // adapted from https://beta.observablehq.com/@mbostock/streaming-csv\n    parseRow(line, validateElementCount = true) {\n        const result = [];\n        let readOffset = 0;\n        const readLength = line.length;\n        let currentState = STATE_OUT;\n        // Goes through the line to parse quote.\n        for (let i = 0; i < readLength; i++) {\n            switch (currentState) {\n                // Before enter a new field\n                case STATE_OUT:\n                    switch (line.charAt(i)) {\n                        // Enter a quoted field\n                        case CODE_QUOTE:\n                            readOffset = i + 1;\n                            currentState = STATE_QUOTE;\n                            break;\n                        // Read an empty field\n                        case this.delimiter:\n                            readOffset = i + 1;\n                            // If delimiter is white space and configured to collapse\n                            // multiple white spaces, ignore this white space.\n                            if (this.delimiter === ' ' && this.delimWhitespace) {\n                                break;\n                            }\n                            result.push('');\n                            currentState = STATE_OUT;\n                            break;\n                        // Enter an unquoted field\n                        default:\n                            currentState = STATE_FIELD;\n                            readOffset = i;\n                            break;\n                    }\n                    break;\n                // In an unquoted field\n                case STATE_FIELD:\n                    switch (line.charAt(i)) {\n                        // Exit an unquoted field, add it to result\n                        case this.delimiter:\n                            result.push(line.substring(readOffset, i));\n                            currentState = STATE_OUT;\n                            readOffset = i + 1;\n                            break;\n                        default:\n                    }\n                    break;\n                // In a quoted field\n                case STATE_QUOTE:\n                    switch (line.charAt(i)) {\n                        // Read a quote after a quote\n                        case CODE_QUOTE:\n                            currentState = STATE_QUOTE_AFTER_QUOTE;\n                            break;\n                        default:\n                    }\n                    break;\n                // This state means it's right after a second quote in a field\n                case STATE_QUOTE_AFTER_QUOTE:\n                    switch (line.charAt(i)) {\n                        // Finished a quoted field\n                        case this.delimiter:\n                            result.push(line.substring(readOffset, i - 1));\n                            currentState = STATE_OUT;\n                            readOffset = i + 1;\n                            break;\n                        // Finished a quoted part in a quoted field\n                        case CODE_QUOTE:\n                            currentState = STATE_QUOTE;\n                            break;\n                        // In a quoted part in a quoted field\n                        default:\n                            currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n                            break;\n                    }\n                    break;\n                case STATE_WITHIN_QUOTE_IN_QUOTE:\n                    switch (line.charAt(i)) {\n                        // Exit a quoted part in a quoted field\n                        case CODE_QUOTE:\n                            currentState = STATE_QUOTE;\n                            break;\n                        default:\n                    }\n                    break;\n                default:\n            }\n        }\n        // Adds last item based on if it is quoted.\n        if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n            result.push(line.substring(readOffset, readLength - 1));\n        }\n        else {\n            result.push(line.substring(readOffset));\n        }\n        // Check if each row has the same number of elements as column names.\n        if (validateElementCount && result.length !== this.fullColumnNames.length) {\n            throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${result}`);\n        }\n        return result;\n    }\n}\n// TODO(soergel): add more basic datasets for parity with tf.data\n// tf.data.FixedLengthRecordDataset()\n// tf.data.TFRecordDataset()\n//# sourceMappingURL=csv_dataset.js.map"]},"metadata":{},"sourceType":"module"}